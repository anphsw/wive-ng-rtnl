diff -uNrw miniupnpd-1.7.20121005/bsd/getroute.c miniupnpd-1.8.20130207/bsd/getroute.c
--- miniupnpd-1.7.20121005/bsd/getroute.c	1970-01-01 06:00:00.000000000 +0600
+++ miniupnpd-1.8.20130207/bsd/getroute.c	2013-02-06 20:14:42.000000000 +0700
@@ -0,0 +1,122 @@
+/* $Id: getroute.c,v 1.3 2013/02/06 13:11:45 nanard Exp $ */
+/* MiniUPnP project
+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
+ * (c) 2006-2013 Thomas Bernard
+ * This software is subject to the conditions detailed
+ * in the LICENCE file provided within the distribution */
+
+#include <stdio.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#ifdef AF_LINK
+#include <net/if_dl.h>
+#endif
+
+#include "../config.h"
+#include "../upnputils.h"
+
+
+int
+get_src_for_route_to(const struct sockaddr * dst,
+                     void * src, size_t * src_len,
+                     int * index)
+{
+	int found = 0;
+	int s;
+	int l, i;
+	char * p;
+	struct sockaddr * sa;
+	struct {
+	  struct rt_msghdr m_rtm;
+	  char       m_space[512];
+	} m_rtmsg;
+#define rtm m_rtmsg.m_rtm
+
+	if(dst == NULL)
+		return -1;
+#ifdef __APPLE__
+	if(dst->sa_family == AF_INET6) {
+		syslog(LOG_ERR, "Sorry, get_src_for_route_to() is known to fail with IPV6 on OS X...");
+		return -1;
+	}
+#endif
+	s = socket(PF_ROUTE, SOCK_RAW, dst->sa_family);
+	if(s < 0) {
+		syslog(LOG_ERR, "socket(PF_ROUTE) failed : %m");
+		return -1;
+	}
+	memset(&rtm, 0, sizeof(rtm));
+	rtm.rtm_type = RTM_GET;
+	rtm.rtm_flags = RTF_UP;
+	rtm.rtm_version = RTM_VERSION;
+	rtm.rtm_seq = 1;
+	rtm.rtm_addrs = RTA_DST;	/* destination address */
+	memcpy(m_rtmsg.m_space, dst, sizeof(struct sockaddr));
+	rtm.rtm_msglen = sizeof(struct rt_msghdr) + sizeof(struct sockaddr);
+	if(write(s, &m_rtmsg, rtm.rtm_msglen) < 0) {
+		syslog(LOG_ERR, "write: %m");
+		close(s);
+		return -1;
+	}
+
+	do {
+		l = read(s, &m_rtmsg, sizeof(m_rtmsg));
+		if(l<0) {
+			syslog(LOG_ERR, "read: %m");
+			close(s);
+			return -1;
+		}
+		syslog(LOG_DEBUG, "read l=%d seq=%d pid=%d",
+		       l, rtm.rtm_seq, rtm.rtm_pid);
+	} while(l > 0 && (rtm.rtm_pid != getpid() || rtm.rtm_seq != 1));
+	close(s);
+	p = m_rtmsg.m_space;
+	if(rtm.rtm_addrs) {
+		for(i=1; i<0x8000; i <<= 1) {
+			if(i & rtm.rtm_addrs) {
+				char tmp[256] = { 0 };
+				sa = (struct sockaddr *)p;
+				sockaddr_to_string(sa, tmp, sizeof(tmp));
+				syslog(LOG_DEBUG, "type=%d sa_len=%d sa_family=%d %s",
+				       i, sa->sa_len, sa->sa_family, tmp);
+				if((i == RTA_DST || i == RTA_GATEWAY) &&
+				   (src_len && src)) {
+					size_t len = 0;
+					void * paddr = NULL;
+					if(sa->sa_family == AF_INET) {
+						paddr = &((struct sockaddr_in *)sa)->sin_addr;
+						len = sizeof(struct in_addr);
+					} else if(sa->sa_family == AF_INET6) {
+						paddr = &((struct sockaddr_in6 *)sa)->sin6_addr;
+						len = sizeof(struct in6_addr);
+					}
+					if(paddr) {
+						if(*src_len < len) {
+							syslog(LOG_WARNING, "cannot copy src. %u<%u",
+							       (unsigned)*src_len, (unsigned)len);
+							return -1;
+						}
+						memcpy(src, paddr, len);
+						*src_len = len;
+						found = 1;
+					}
+				}
+#ifdef AF_LINK
+				if(sa->sa_family == AF_LINK) {
+					struct sockaddr_dl * sdl = (struct sockaddr_dl *)sa;
+					if(index)
+						*index = sdl->sdl_index;
+				}
+#endif
+				p += sa->sa_len;
+			}
+		}
+	}
+	return found ? 0 : -1;
+}
+
diff -uNrw miniupnpd-1.7.20121005/Changelog.txt miniupnpd-1.8.20130207/Changelog.txt
--- miniupnpd-1.7.20121005/Changelog.txt	2012-10-05 05:34:08.000000000 +0700
+++ miniupnpd-1.8.20130207/Changelog.txt	2013-02-07 19:28:39.000000000 +0700
@@ -1,4 +1,35 @@
-$Id: Changelog.txt,v 1.318 2012/10/04 22:11:55 nanard Exp $
+$Id: Changelog.txt,v 1.330 2013/02/07 12:22:23 nanard Exp $
+
+2013/02/07:
+  Add DATE: header in SSDP packets
+  Fix SSDP packets sent with uuid as ST: header to conform to UDA
+  ignore SSDP packets missing the MX: header in UPNP_STRICT mode
+  Added Ext: header to HTTP responses to conform to UDA
+  Refactored SendSSDPNotifies() and SendSSDPGoodbye() and add
+    missing ssdp:alive and ssdp:byebye with NT uuid value.
+
+VERSION 1.8 : released on 2013/02/06
+
+2013/02/06:
+  Check source address of incomining HTTP connections and SSDP
+    packets in order to filter out WAN SSDP and HTTP trafic.
+  Implement get_src_for_route_to() for *BSD
+  fix 2 potential memory leaks in GetListOfPortMappings()
+
+2013/01/29:
+  upnphttp.c: Fix and comment the findendheaders() function
+  upnphttp.c: remove strchr() call in ParseHttpHeaders()
+    add comments to explain how buffer is checked before calls
+    to ParseHttpHeaders()
+
+2013/01/27:
+  upnphttp.c: ParseHttpHeaders() now checks atoi() return
+
+2012/12/11:
+  More return value check for malloc() and realloc()
+
+2012/10/23:
+  minor modifications to linux/getroute.c and testgetroute.c
 
 2012/10/04:
   updated DEFAULTCONNECTIONSERVICE_MAGICALVALUE for IGDv2
diff -uNrw miniupnpd-1.7.20121005/getroute.h miniupnpd-1.8.20130207/getroute.h
--- miniupnpd-1.7.20121005/getroute.h	2012-10-05 05:34:08.000000000 +0700
+++ miniupnpd-1.8.20130207/getroute.h	2013-02-06 17:51:05.000000000 +0700
@@ -1,7 +1,7 @@
-/* $Id: getroute.h,v 1.2 2012/09/27 16:00:10 nanard Exp $ */
+/* $Id: getroute.h,v 1.3 2013/02/06 10:50:04 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006-2012 Thomas Bernard
+ * (c) 2006-2013 Thomas Bernard
  * This software is subject to the conditions detailed
  * in the LICENCE file provided within the distribution */
 
@@ -10,7 +10,8 @@
 
 int
 get_src_for_route_to(const struct sockaddr * dst,
-                     void * src, size_t * src_len);
+                     void * src, size_t * src_len,
+                     int * index);
 
 #endif
 
diff -uNrw miniupnpd-1.7.20121005/linux/getroute.c miniupnpd-1.8.20130207/linux/getroute.c
--- miniupnpd-1.7.20121005/linux/getroute.c	2012-06-24 06:34:42.000000000 +0700
+++ miniupnpd-1.8.20130207/linux/getroute.c	2013-02-06 17:51:06.000000000 +0700
@@ -1,7 +1,7 @@
-/* $Id: getroute.c,v 1.2 2012/06/23 23:34:42 nanard Exp $ */
+/* $Id: getroute.c,v 1.4 2013/02/06 10:50:04 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006-2012 Thomas Bernard
+ * (c) 2006-2013 Thomas Bernard
  * This software is subject to the conditions detailed
  * in the LICENCE file provided within the distribution */
 
@@ -23,7 +23,8 @@
 
 int
 get_src_for_route_to(const struct sockaddr * dst,
-                     void * src, size_t * src_len)
+                     void * src, size_t * src_len,
+                     int * index)
 {
 	int fd = -1;
 	struct nlmsghdr *h;
@@ -76,6 +77,10 @@
 	}
 
 	fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+	if (fd < 0) {
+		syslog(LOG_ERR, "socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE) : %m");
+		return -1;
+	}
 
 	memset(&nladdr, 0, sizeof(nladdr));
 	nladdr.nl_family = AF_NETLINK;
@@ -87,7 +92,7 @@
 
 	if (status < 0) {
 		syslog(LOG_ERR, "sendmsg(rtnetlink) : %m");
-		return -1;
+		goto error;
 	}
 
 	memset(&req, 0, sizeof(req));
@@ -137,6 +142,7 @@
 				for(rta = RTM_RTA(NLMSG_DATA((h))); RTA_OK(rta, len); rta = RTA_NEXT(rta,len)) {
 					unsigned char * data = RTA_DATA(rta);
 					if(rta->rta_type == RTA_PREFSRC) {
+						if(src_len && src) {
 						if(*src_len < RTA_PAYLOAD(rta)) {
 							syslog(LOG_WARNING, "cannot copy src: %u<%lu",
 							       (unsigned)*src_len, RTA_PAYLOAD(rta));
@@ -145,6 +151,10 @@
 						*src_len = RTA_PAYLOAD(rta);
 						memcpy(src, data, RTA_PAYLOAD(rta));
 					}
+					} else if(rta->rta_type == RTA_OIF) {
+						if(index)
+							memcpy(index, data, sizeof(int));
+					}
 				}
 				close(fd);
 				return 0;
diff -uNrw miniupnpd-1.7.20121005/Makefile miniupnpd-1.8.20130207/Makefile
--- miniupnpd-1.7.20121005/Makefile	2012-10-05 05:34:08.000000000 +0700
+++ miniupnpd-1.8.20130207/Makefile	2013-02-06 20:14:42.000000000 +0700
@@ -1,4 +1,4 @@
-# $Id: Makefile,v 1.71 2012/09/20 12:45:59 nanard Exp $
+# $Id: Makefile,v 1.73 2013/02/06 13:11:45 nanard Exp $
 # MiniUPnP project
 # http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
 # Author: Thomas Bernard
@@ -81,9 +81,9 @@
           options.o upnppermissions.o minissdp.o natpmp.o \
           upnpevents.o upnputils.o getconnstatus.o \
           upnppinhole.o
-BSDOBJS = bsd/getifstats.o bsd/ifacewatcher.o
-SUNOSOBJS = solaris/getifstats.o bsd/ifacewatcher.o
-MACOBJS = mac/getifstats.o bsd/ifacewatcher.o
+BSDOBJS = bsd/getifstats.o bsd/ifacewatcher.o bsd/getroute.o
+SUNOSOBJS = solaris/getifstats.o bsd/ifacewatcher.o bsd/getroute.o
+MACOBJS = mac/getifstats.o bsd/ifacewatcher.o bsd/getroute.o
 PFOBJS = pf/obsdrdr.o pf/pfpinhole.o
 IPFOBJS = ipf/ipfrdr.o
 IPFWOBJS = ipfw/ipfwrdr.o ipfw/ipfwaux.o
@@ -93,12 +93,15 @@
 .if $(OSNAME) == "SunOS"
 ALLOBJS += $(SUNOSOBJS)
 TESTGETIFSTATSOBJS = testgetifstats.o solaris/getifstats.o
+TESTGETROUTEOBJS = testgetroute.o upnputils.o bsd/getroute.o
 .elif $(OSNAME) == "Darwin"
 ALLOBJS += $(MACOBJS)
 TESTGETIFSTATSOBJS = testgetifstats.o mac/getifstats.o
+TESTGETROUTEOBJS = testgetroute.o upnputils.o bsd/getroute.o
 .else
 ALLOBJS += $(BSDOBJS)
 TESTGETIFSTATSOBJS = testgetifstats.o bsd/getifstats.o
+TESTGETROUTEOBJS = testgetroute.o upnputils.o bsd/getroute.o
 .endif
 
 .if $(FWNAME) == "pf"
@@ -116,7 +119,7 @@
 
 EXECUTABLES = miniupnpd testupnpdescgen testgetifstats \
               testupnppermissions miniupnpdctl \
-              testgetifaddr
+              testgetifaddr testgetroute
 .if $(OSNAME) == "Darwin"
 LIBS =
 .else
@@ -139,7 +142,7 @@
 	$(RM) $(STDOBJS) $(BSDOBJS) $(SUNOSOBJS) $(MACOBJS) $(EXECUTABLES) \
 	testupnpdescgen.o \
 	$(MISCOBJS) config.h testgetifstats.o testupnppermissions.o \
-	miniupnpdctl.o testgetifaddr.o \
+	miniupnpdctl.o testgetifaddr.o testgetroute.o \
 	$(PFOBJS) $(IPFOBJS) $(IPFWOBJS)
 
 install:	miniupnpd genuuid
@@ -169,7 +172,8 @@
 
 depend:	config.h
 	mkdep $(ALLOBJS:.o=.c) testupnpdescgen.c testgetifstats.c \
-    testupnppermissions.c miniupnpdctl.c testgetifaddr.c
+    testupnppermissions.c miniupnpdctl.c testgetifaddr.c \
+	testgetroute.c
 
 miniupnpd: config.h $(ALLOBJS)
 	$(CC) $(CFLAGS) -o $@ $(ALLOBJS) $(LIBS)
@@ -192,6 +196,9 @@
 testupnppermissions:	config.h $(TESTUPNPPERMISSIONSOBJS)
 	$(CC) $(CFLAGS) -o $@ $(TESTUPNPPERMISSIONSOBJS)
 
+testgetroute:	config.h $(TESTGETROUTEOBJS)
+	$(CC) $(CFLAGS) -o $@ $(TESTGETROUTEOBJS)
+
 # gmake :
 #	$(CC) $(CFLAGS) -o $@ $^
 # BSDmake :
diff -uNrw miniupnpd-1.7.20121005/minissdp.c miniupnpd-1.8.20130207/minissdp.c
--- miniupnpd-1.7.20121005/minissdp.c	2012-10-05 05:34:08.000000000 +0700
+++ miniupnpd-1.8.20130207/minissdp.c	2013-02-07 19:28:40.000000000 +0700
@@ -1,7 +1,7 @@
-/* $Id: minissdp.c,v 1.43 2012/10/03 15:21:48 nanard Exp $ */
+/* $Id: minissdp.c,v 1.48 2013/02/07 12:22:25 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006-2012 Thomas Bernard
+ * (c) 2006-2013 Thomas Bernard
  * This software is subject to the conditions detailed
  * in the LICENCE file provided within the distribution */
 
@@ -324,6 +324,20 @@
 	char buf[512];
 	char addr_str[64];
 	socklen_t addrlen;
+	int st_is_uuid;
+#ifdef ENABLE_HTTP_DATE
+	char http_date[64];
+	time_t t;
+	struct tm tm;
+
+	time(&t);
+	gmtime_r(&t, &tm);
+	strftime(http_date, sizeof(http_date),
+		    "%a, %d %b %Y %H:%M:%S GMT", &tm);
+#endif
+
+	st_is_uuid = (st_len == (int)strlen(uuidvalue)) &&
+	              (memcmp(uuidvalue, st, st_len) == 0);
 	/*
 	 * follow guideline from document "UPnP Device Architecture 1.0"
 	 * uppercase is recommended.
@@ -334,9 +348,11 @@
 	 * have a look at the document "UPnP Device Architecture v1.1 */
 	l = snprintf(buf, sizeof(buf), "HTTP/1.1 200 OK\r\n"
 		"CACHE-CONTROL: max-age=120\r\n"
-		/*"DATE: ...\r\n"*/
+#ifdef ENABLE_HTTP_DATE
+		"DATE: %s\r\n"
+#endif
 		"ST: %.*s%s\r\n"
-		"USN: %s::%.*s%s\r\n"
+		"USN: %s%s%.*s%s\r\n"
 		"EXT:\r\n"
 		"SERVER: " MINIUPNPD_SERVER_STRING "\r\n"
 		"LOCATION: http://%s:%u" ROOTDESC_PATH "\r\n"
@@ -345,8 +361,12 @@
 		"BOOTID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
 		"CONFIGID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
 		"\r\n",
+#ifdef ENABLE_HTTP_DATE
+		http_date,
+#endif
 		st_len, st, suffix,
-		uuidvalue, st_len, st, suffix,
+		uuidvalue, st_is_uuid ? "" : "::",
+		st_is_uuid ? 0 : st_len, st, suffix,
 		host, (unsigned int)port,
 		upnp_bootid, upnp_bootid, upnp_configid);
 	addrlen = (addr->sa_family == AF_INET6)
@@ -394,50 +414,23 @@
 };
 
 static void
-SendSSDPNotifies(int s, const char * host, unsigned short port,
+SendSSDPNotify(int s, const struct sockaddr * dest,
+               const char * host, unsigned short port,
+               const char * nt, const char * suffix,
+               const char * usn1, const char * usn2, const char * usn3,
                  unsigned int lifetime, int ipv6)
 {
-#ifdef ENABLE_IPV6
-	struct sockaddr_storage sockname;
-#else
-	struct sockaddr_in sockname;
-#endif
-	int l, n, i=0;
 	char bufr[512];
-	char ver_str[4];
-
-	memset(&sockname, 0, sizeof(sockname));
-#ifdef ENABLE_IPV6
-	if(ipv6)
-	{
-		struct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockname;
-		p->sin6_family = AF_INET6;
-		p->sin6_port = htons(SSDP_PORT);
-		inet_pton(AF_INET6, LL_SSDP_MCAST_ADDR, &(p->sin6_addr));
-	}
-	else
-#endif
-	{
-		struct sockaddr_in *p = (struct sockaddr_in *)&sockname;
-		p->sin_family = AF_INET;
-		p->sin_port = htons(SSDP_PORT);
-		p->sin_addr.s_addr = inet_addr(SSDP_MCAST_ADDR);
-	}
+	int n, l;
 
-	while(known_service_types[i].s)
-	{
-		if(i==0)
-			ver_str[0] = '\0';
-		else
-			snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
 		l = snprintf(bufr, sizeof(bufr),
 			"NOTIFY * HTTP/1.1\r\n"
 			"HOST: %s:%d\r\n"
 			"CACHE-CONTROL: max-age=%u\r\n"
-			"lOCATION: http://%s:%d" ROOTDESC_PATH"\r\n"
+		"LOCATION: http://%s:%d" ROOTDESC_PATH"\r\n"
 			"SERVER: " MINIUPNPD_SERVER_STRING "\r\n"
 			"NT: %s%s\r\n"
-			"USN: %s::%s%s\r\n"
+		"USN: %s%s%s%s\r\n"
 			"NTS: ssdp:alive\r\n"
 			"OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n" /* UDA v1.1 */
 			"01-NLS: %u\r\n" /* same as BOOTID field. UDA v1.1 */
@@ -448,21 +441,20 @@
 			SSDP_PORT,
 			lifetime,
 			host, port,
-			known_service_types[i].s, ver_str,
-			uuidvalue, known_service_types[i].s, ver_str,
+		nt, suffix, /* NT: */
+		usn1, usn2, usn3, suffix, /* USN: */
 			upnp_bootid, upnp_bootid, upnp_configid );
 		if(l<0)
 		{
 			syslog(LOG_ERR, "SendSSDPNotifies() snprintf error");
-			continue;
+		return;
 		}
-		if((unsigned int)l >= sizeof(bufr))
+	else if((unsigned int)l >= sizeof(bufr))
 		{
 			syslog(LOG_WARNING, "SendSSDPNotifies(): truncated output");
 			l = sizeof(bufr);
 		}
-		n = sendto(s, bufr, l, 0,
-			(struct sockaddr *)&sockname,
+	n = sendto(s, bufr, l, 0, dest,
 #ifdef ENABLE_IPV6
 			ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)
 #else
@@ -475,6 +467,57 @@
 			syslog(LOG_ERR, "sendto(udp_notify=%d, %s): %m", s,
 			       host ? host : "NULL");
 		}
+	else if(n != l)
+	{
+		syslog(LOG_NOTICE, "sendto() sent %d out of %d bytes", n, l);
+	}
+}
+
+static void
+SendSSDPNotifies(int s, const char * host, unsigned short port,
+                 unsigned int lifetime, int ipv6)
+{
+#ifdef ENABLE_IPV6
+	struct sockaddr_storage sockname;
+#else
+	struct sockaddr_in sockname;
+#endif
+	int i=0;
+	char ver_str[4];
+
+	memset(&sockname, 0, sizeof(sockname));
+#ifdef ENABLE_IPV6
+	if(ipv6)
+	{
+		struct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockname;
+		p->sin6_family = AF_INET6;
+		p->sin6_port = htons(SSDP_PORT);
+		inet_pton(AF_INET6, LL_SSDP_MCAST_ADDR, &(p->sin6_addr));
+	}
+	else
+#endif
+	{
+		struct sockaddr_in *p = (struct sockaddr_in *)&sockname;
+		p->sin_family = AF_INET;
+		p->sin_port = htons(SSDP_PORT);
+		p->sin_addr.s_addr = inet_addr(SSDP_MCAST_ADDR);
+	}
+
+	while(known_service_types[i].s)
+	{
+		if(i==0)
+			ver_str[0] = '\0';
+		else
+			snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
+		SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
+		               known_service_types[i].s, ver_str,	/* NT: */
+		               uuidvalue, "::", known_service_types[i].s, /* ver_str,	USN: */
+		               lifetime, ipv6);
+		if(i==0) /* rootdevice */
+			SendSSDPNotify(s, (struct sockaddr *)&sockname, host, port,
+			               uuidvalue, "",	/* NT: */
+			               uuidvalue, "", "", /* ver_str,	USN: */
+			               lifetime, ipv6);
 		i++;
 	}
 }
@@ -546,14 +589,22 @@
 	char sender_str[64];
 	char ver_str[4];
 	const char * announced_host = NULL;
-#ifdef ENABLE_IPV6
 #ifdef UPNP_STRICT
+#ifdef ENABLE_IPV6
 	char announced_host_buf[64];
 #endif
+	int mx_value = -1;
 #endif
 
 	/* get the string representation of the sender address */
 	sockaddr_to_string(sender, sender_str, sizeof(sender_str));
+	lan_addr = get_lan_for_peer(sender);
+	if(lan_addr == NULL)
+	{
+		syslog(LOG_WARNING, "SSDP packet sender %s not from a LAN, ignoring",
+		       sender_str);
+		return;
+	}
 
 	if(memcmp(bufr, "NOTIFY", 6) == 0)
 	{
@@ -586,7 +637,29 @@
 				/*while(bufr[i+j]!='\r') j++;*/
 				/*syslog(LOG_INFO, "%.*s", j, bufr+i);*/
 			}
+#ifdef UPNP_STRICT
+			else if((i < n - 3) && (strncasecmp(bufr+i, "mx:", 3) == 0))
+			{
+				const char * mx;
+				int mx_len;
+				mx = bufr+i+3;
+				mx_len = 0;
+				while((*mx == ' ' || *mx == '\t') && (mx < bufr + n))
+					mx++;
+				while(mx[mx_len]!='\r' && mx[mx_len]!='\n'
+				     && (mx + mx_len < bufr + n))
+					mx_len++;
+				mx_value = atoi(mx);
+				syslog(LOG_DEBUG, "MX: %.*s (value=%d)", mx_len, mx, mx_value);
+			}
+#endif
 		}
+#ifdef UPNP_STRICT
+		if(mx_value < 0) {
+			syslog(LOG_INFO, "ignoring SSDP packet missing MX: header");
+			return;
+		}
+#endif
 		/*syslog(LOG_INFO, "SSDP M-SEARCH packet received from %s",
 	           sender_str );*/
 		if(st && (st_len > 0))
@@ -597,14 +670,6 @@
 			/* find in which sub network the client is */
 			if(sender->sa_family == AF_INET)
 			{
-				for(lan_addr = lan_addrs.lh_first;
-				    lan_addr != NULL;
-				    lan_addr = lan_addr->list.le_next)
-				{
-					if( (((const struct sockaddr_in *)sender)->sin_addr.s_addr & lan_addr->mask.s_addr)
-					   == (lan_addr->addr.s_addr & lan_addr->mask.s_addr))
-						break;
-				}
 				if (lan_addr == NULL)
 				{
 					syslog(LOG_ERR, "Can't find in which sub network the client is");
@@ -617,12 +682,13 @@
 			{
 				/* IPv6 address with brackets */
 #ifdef UPNP_STRICT
+				int index;
 				struct in6_addr addr6;
 				size_t addr6_len = sizeof(addr6);
 				/* retrieve the IPv6 address which
 				 * will be used locally to reach sender */
 				memset(&addr6, 0, sizeof(addr6));
-				if(get_src_for_route_to (sender, &addr6, &addr6_len) < 0) {
+				if(get_src_for_route_to (sender, &addr6, &addr6_len, &index) < 0) {
 					syslog(LOG_WARNING, "get_src_for_route_to() failed, using %s", ipv6_addr_for_http_with_brackets);
 					announced_host = ipv6_addr_for_http_with_brackets;
 				} else {
@@ -707,6 +773,61 @@
 	}
 }
 
+static int
+SendSSDPbyebye(int s, const struct sockaddr * dest,
+               const char * nt, const char * suffix,
+               const char * usn1, const char * usn2, const char * usn3,
+               int ipv6)
+{
+	int n, l;
+	char bufr[512];
+
+	l = snprintf(bufr, sizeof(bufr),
+	             "NOTIFY * HTTP/1.1\r\n"
+	             "HOST: %s:%d\r\n"
+	             "NT: %s%s\r\n"
+	             "USN: %s%s%s%s\r\n"
+	             "NTS: ssdp:byebye\r\n"
+	             "OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n" /* UDA v1.1 */
+	             "01-NLS: %u\r\n" /* same as BOOTID field. UDA v1.1 */
+	             "BOOTID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
+	             "CONFIGID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
+	             "\r\n",
+	             ipv6 ? "[" LL_SSDP_MCAST_ADDR "]" : SSDP_MCAST_ADDR,
+	             SSDP_PORT,
+	             nt, suffix,	/* NT: */
+	             usn1, usn2, usn3, suffix,	/* USN: */
+	             upnp_bootid, upnp_bootid, upnp_configid);
+	if(l<0)
+	{
+		syslog(LOG_ERR, "SendSSDPbyebye() snprintf error");
+		return -1;
+	}
+	else if((unsigned int)l >= sizeof(bufr))
+	{
+		syslog(LOG_WARNING, "SendSSDPbyebye(): truncated output");
+		l = sizeof(bufr);
+	}
+	n = sendto(s, bufr, l, 0, dest,
+#ifdef ENABLE_IPV6
+	           ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)
+#else
+	           sizeof(struct sockaddr_in)
+#endif
+	          );
+	if(n < 0)
+	{
+		syslog(LOG_ERR, "sendto(udp_shutdown=%d): %m", s);
+		return -1;
+	}
+	else if(n != l)
+	{
+		syslog(LOG_NOTICE, "sendto() sent %d out of %d bytes", n, l);
+		return -1;
+	}
+	return 0;
+}
+
 /* This will broadcast ssdp:byebye notifications to inform
  * the network that UPnP is going down. */
 int
@@ -716,9 +837,7 @@
 #ifdef ENABLE_IPV6
 	struct sockaddr_in6 sockname6;
 #endif
-	int n, l;
 	int i, j;
-	char bufr[512];
 	char ver_str[4];
 	int ret = 0;
 	int ipv6 = 0;
@@ -745,36 +864,26 @@
 				ver_str[0] = '\0';
 			else
 				snprintf(ver_str, sizeof(ver_str), "%d", known_service_types[i].version);
-	        l = snprintf(bufr, sizeof(bufr),
-                 "NOTIFY * HTTP/1.1\r\n"
-                 "HOST: %s:%d\r\n"
-                 "NT: %s%s\r\n"
-                 "USN: %s::%s%s\r\n"
-                 "NTS: ssdp:byebye\r\n"
-				 "OPT: \"http://schemas.upnp.org/upnp/1/0/\"; ns=01\r\n" /* UDA v1.1 */
-				 "01-NLS: %u\r\n" /* same as BOOTID field. UDA v1.1 */
-				 "BOOTID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
-				 "CONFIGID.UPNP.ORG: %u\r\n" /* UDA v1.1 */
-                 "\r\n",
-                 ipv6 ? "[" LL_SSDP_MCAST_ADDR "]" : SSDP_MCAST_ADDR,
-			     SSDP_PORT,
-				 known_service_types[i].s, ver_str,
-                 uuidvalue, known_service_types[i].s, ver_str,
-                 upnp_bootid, upnp_bootid, upnp_configid);
-	        n = sendto(sockets[j], bufr, l, 0,
+			ret += SendSSDPbyebye(sockets[j],
 #ifdef ENABLE_IPV6
 	                   ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
-	                   ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)
 #else
 	                   (struct sockaddr *)&sockname,
-	                   sizeof(struct sockaddr_in)
 #endif
-	                 );
-			if(n < 0)
+			                      known_service_types[i].s, ver_str,	/* NT: */
+			                      uuidvalue, "::", known_service_types[i].s, /* ver_str, USN: */
+			                      ipv6);
+			if(i==0)	/* root device */
 			{
-				syslog(LOG_ERR, "SendSSDPGoodbye: sendto(udp_shutdown=%d): %m",
-				       sockets[j]);
-				ret = -1;
+				ret += SendSSDPbyebye(sockets[j],
+#ifdef ENABLE_IPV6
+				                      ipv6 ? (struct sockaddr *)&sockname6 : (struct sockaddr *)&sockname,
+#else
+				                      (struct sockaddr *)&sockname,
+#endif
+				                      uuidvalue, "",	/* NT: */
+				                      uuidvalue, "", "", /* ver_str, USN: */
+				                      ipv6);
 			}
     	}
 	}
diff -uNrw miniupnpd-1.7.20121005/miniupnpd.c miniupnpd-1.8.20130207/miniupnpd.c
--- miniupnpd-1.7.20121005/miniupnpd.c	2012-10-05 05:36:46.000000000 +0700
+++ miniupnpd-1.8.20130207/miniupnpd.c	2013-02-06 17:51:05.000000000 +0700
@@ -1,7 +1,7 @@
-/* $Id: miniupnpd.c,v 1.171 2012/10/04 22:36:46 nanard Exp $ */
+/* $Id: miniupnpd.c,v 1.173 2013/02/06 10:50:04 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006-2012 Thomas Bernard
+ * (c) 2006-2013 Thomas Bernard
  * This software is subject to the conditions detailed
  * in the LICENCE file provided within the distribution */
 
@@ -1706,9 +1706,17 @@
 			           &clientnamelen);
 			syslog(LOG_DEBUG, "sctl! : '%s'", clientname.sun_path);
 			tmp = malloc(sizeof(struct ctlelem));
+			if (tmp == NULL)
+			{
+				syslog(LOG_ERR, "Unable to allocate memory for ctlelem in main()");
+				close(s);
+			}
+			else
+			{
 			tmp->socket = s;
 			LIST_INSERT_HEAD(&ctllisthead, tmp, entries);
 		}
+		}
 #endif
 #ifdef ENABLE_EVENTS
 		upnpevents_processfds(&readset, &writeset);
@@ -1781,6 +1789,16 @@
 
 				sockaddr_to_string((struct sockaddr *)&clientname, addr_str, sizeof(addr_str));
 				syslog(LOG_INFO, "HTTP connection from %s", addr_str);
+				if(get_lan_for_peer((struct sockaddr *)&clientname) == NULL)
+				{
+					/* The peer is not a LAN ! */
+					syslog(LOG_WARNING,
+					       "HTTP peer %s is not from a LAN, closing the connection",
+					       addr_str);
+					close(shttp);
+				}
+				else
+				{
 				/* Create a new upnphttp object and add it to
 				 * the active upnphttp object list */
 				tmp = New_upnphttp(shttp);
@@ -1820,6 +1838,7 @@
 				}
 			}
 		}
+		}
 #ifdef ENABLE_NFQUEUE
 		/* process NFQ packets */
 		if(nfqh >= 0 && FD_ISSET(nfqh, &readset))
diff -uNrw miniupnpd-1.7.20121005/testgetroute.c miniupnpd-1.8.20130207/testgetroute.c
--- miniupnpd-1.7.20121005/testgetroute.c	2012-06-24 06:32:32.000000000 +0700
+++ miniupnpd-1.8.20130207/testgetroute.c	2013-02-06 19:07:36.000000000 +0700
@@ -1,7 +1,7 @@
-/* $Id: testgetroute.c,v 1.2 2012/06/23 23:32:32 nanard Exp $ */
+/* $Id: testgetroute.c,v 1.5 2013/02/06 12:07:36 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006-2012 Thomas Bernard
+ * (c) 2006-2013 Thomas Bernard
  * This software is subject to the conditions detailed
  * in the LICENCE file provided within the distribution */
 
@@ -15,12 +15,15 @@
 
 #include "getroute.h"
 #include "upnputils.h"
+#include "upnpglobalvars.h"
 
 #ifndef LOG_PERROR
 /* solaris does not define LOG_PERROR */
 #define LOG_PERROR 0
 #endif
 
+struct lan_addr_list lan_addrs;
+
 int
 main(int argc, char ** argv)
 {
@@ -30,6 +33,7 @@
 	void * src;
 	size_t src_len;
 	int r;
+	int index = -1;
 
 	memset(&dst4, 0, sizeof(dst4));
 	memset(&dst6, 0, sizeof(dst6));
@@ -43,19 +47,25 @@
 	r = inet_pton (AF_INET, argv[1], &dst4.sin_addr);
 	if(r < 0) {
 		syslog(LOG_ERR, "inet_pton(AF_INET, %s) : %m", argv[1]);
+		closelog();
 		return 2;
 	}
 	if (r == 0) {
 		r = inet_pton (AF_INET6, argv[1], &dst6.sin6_addr);
 		if(r < 0) {
 			syslog(LOG_ERR, "inet_pton(AF_INET6, %s) : %m", argv[1]);
+			closelog();
 			return 2;
-		}
-		if(r > 0) {
+		} else if(r > 0) {
 			dst6.sin6_family = AF_INET6;
 			dst = (struct sockaddr *)&dst6;
 			src = &dst6.sin6_addr;
 			src_len = sizeof(dst6.sin6_addr);
+		} else {
+			/* r == 0 */
+			syslog(LOG_ERR, "%s is not a correct IPv4 or IPv6 address", argv[1]);
+			closelog();
+			return 1;
 		}
 	} else {
 		dst4.sin_family = AF_INET;
@@ -65,14 +75,18 @@
 	}
 
 	if (dst) {
-		r = get_src_for_route_to (dst, src, &src_len);
+		syslog(LOG_DEBUG, "calling get_src_for_route_to(%p, %p, %p(%u), %p)",
+		       dst, src, &src_len, (unsigned)src_len, &index);
+		r = get_src_for_route_to (dst, src, &src_len, &index);
 		syslog(LOG_DEBUG, "get_src_for_route_to() returned %d", r);
 		if(r >= 0) {
 			char src_str[128];
 			sockaddr_to_string(dst, src_str, sizeof(src_str));
 			syslog(LOG_DEBUG, "src=%s", src_str);
+			syslog(LOG_DEBUG, "index=%d", index);
 		}
 	}
+	closelog();
 	return 0;
 }
 
diff -uNrw miniupnpd-1.7.20121005/upnphttp.c miniupnpd-1.8.20130207/upnphttp.c
--- miniupnpd-1.7.20121005/upnphttp.c	2012-10-05 05:34:08.000000000 +0700
+++ miniupnpd-1.8.20130207/upnphttp.c	2013-02-07 19:28:40.000000000 +0700
@@ -1,4 +1,4 @@
-/* $Id: upnphttp.c,v 1.81 2012/10/04 22:09:34 nanard Exp $ */
+/* $Id: upnphttp.c,v 1.86 2013/02/07 10:26:07 nanard Exp $ */
 /* Project :  miniupnp
  * Website :  http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
  * Author :   Thomas Bernard
@@ -71,7 +71,9 @@
 	}
 }
 
-/* parse HttpHeaders of the REQUEST */
+/* parse HttpHeaders of the REQUEST
+ * This function is called after the \r\n\r\n character
+ * sequence has been found in h->req_buf */
 static void
 ParseHttpHeaders(struct upnphttp * h)
 {
@@ -79,11 +81,21 @@
 	char * colon;
 	char * p;
 	int n;
+	if((h->req_buf == NULL) || (h->req_contentoff <= 0))
+		return;
 	line = h->req_buf;
-	/* TODO : check if req_buf, contentoff are ok */
 	while(line < (h->req_buf + h->req_contentoff))
 	{
-		colon = strchr(line, ':');
+		colon = line;
+		while(*colon != ':')
+		{
+			if(*colon == '\r' || *colon == '\n')
+			{
+				colon = NULL;	/* no ':' character found on the line */
+				break;
+			}
+			colon++;
+		}
 		if(colon)
 		{
 			if(strncasecmp(line, "Content-Length", 14)==0)
@@ -92,6 +104,10 @@
 				while(*p < '0' || *p > '9')
 					p++;
 				h->req_contentlen = atoi(p);
+				if(h->req_contentlen < 0) {
+					syslog(LOG_WARNING, "ParseHttpHeaders() invalid Content-Length %d", h->req_contentlen);
+					h->req_contentlen = 0;
+				}
 				/*printf("*** Content-Lenght = %d ***\n", h->req_contentlen);
 				printf("    readbufflen=%d contentoff = %d\n",
 					h->req_buflen, h->req_contentoff);*/
@@ -103,9 +119,7 @@
 				while(*p == ':' || *p == ' ' || *p == '\t')
 					p++;
 				while(p[n]>=' ')
-				{
 					n++;
-				}
 				if((p[0] == '"' && p[n-1] == '"')
 				  || (p[0] == '\'' && p[n-1] == '\''))
 				{
@@ -199,6 +213,9 @@
 #endif
 #endif
 		}
+		/* the loop below won't run off the end of the buffer
+		 * because the buffer is guaranteed to contain the \r\n\r\n
+		 * character sequence */
 		while(!(line[0] == '\r' && line[1] == '\n'))
 			line++;
 		line += 2;
@@ -249,10 +266,13 @@
 	SendRespAndClose_upnphttp(h);
 }
 
+/* findendheaders() find the \r\n\r\n character sequence and
+ * return a pointer to it.
+ * It returns NULL if not found */
 static const char *
 findendheaders(const char * s, int len)
 {
-	while(len-->0)
+	while(len-->3)
 	{
 		if(s[0]=='\r' && s[1]=='\n' && s[2]=='\r' && s[3]=='\n')
 			return s;
@@ -518,7 +538,9 @@
 #endif
 
 /* Parse and process Http Query
- * called once all the HTTP headers have been received. */
+ * called once all the HTTP headers have been received,
+ * so it is guaranteed that h->req_buf contains the \r\n\r\n
+ * character sequence */
 static void
 ProcessHttpQuery_upnphttp(struct upnphttp * h)
 {
@@ -551,6 +573,9 @@
 	p = h->req_buf;
 	if(!p)
 		return;
+	/* note : checking (*p != '\r') is enough to avoid runing off the
+	 * end of the buffer, because h->req_buf is guaranteed to contain
+	 * the \r\n\r\n character sequence */
 	for(i = 0; i<15 && *p != ' ' && *p != '\r'; i++)
 		HttpCommand[i] = *(p++);
 	HttpCommand[i] = '\0';
@@ -637,6 +662,7 @@
 void
 Process_upnphttp(struct upnphttp * h)
 {
+	char * h_tmp;
 	char buf[2048];
 	int n;
 
@@ -667,14 +693,25 @@
 			const char * endheaders;
 			/* if 1st arg of realloc() is null,
 			 * realloc behaves the same as malloc() */
-			h->req_buf = (char *)realloc(h->req_buf, n + h->req_buflen + 1);
+			h_tmp = (char *)realloc(h->req_buf, n + h->req_buflen + 1);
+			if (h_tmp == NULL)
+			{
+				syslog(LOG_WARNING, "Unable to allocate new memory for h->req_buf)");
+				h->state = EToDelete;
+			}
+			else
+			{
+				h->req_buf = h_tmp;
 			memcpy(h->req_buf + h->req_buflen, buf, n);
 			h->req_buflen += n;
 			h->req_buf[h->req_buflen] = '\0';
+			}
 			/* search for the string "\r\n\r\n" */
 			endheaders = findendheaders(h->req_buf, h->req_buflen);
 			if(endheaders)
 			{
+				/* at this point, the request buffer (h->req_buf)
+				 * is guaranteed to contain the \r\n\r\n character sequence */
 				h->req_contentoff = endheaders - h->req_buf + 4;
 				ProcessHttpQuery_upnphttp(h);
 			}
@@ -736,6 +773,7 @@
 	"Connection: close\r\n"
 	"Content-Length: %d\r\n"
 	"Server: " MINIUPNPD_SERVER_STRING "\r\n"
+	"Ext:\r\n"
 	;	/*"\r\n";*/
 /*
 		"<?xml version=\"1.0\"?>\n"
diff -uNrw miniupnpd-1.7.20121005/upnpsoap.c miniupnpd-1.8.20130207/upnpsoap.c
--- miniupnpd-1.7.20121005/upnpsoap.c	2012-10-05 05:34:08.000000000 +0700
+++ miniupnpd-1.8.20130207/upnpsoap.c	2013-02-06 19:40:31.000000000 +0700
@@ -1,4 +1,4 @@
-/* $Id: upnpsoap.c,v 1.113 2012/10/04 22:10:26 nanard Exp $ */
+/* $Id: upnpsoap.c,v 1.114 2013/02/06 12:40:25 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
  * (c) 2006-2012 Thomas Bernard
@@ -952,6 +952,7 @@
 	if(bodylen < 0)
 	{
 		SoapError(h, 501, "ActionFailed");
+		free(body);
 		return;
 	}
 	memcpy(body+bodylen, list_start, sizeof(list_start));
@@ -965,12 +966,14 @@
 		/* have a margin of 1024 bytes to store the new entry */
 		if((unsigned int)bodylen + 1024 > bodyalloc)
 		{
+			char * body_sav = body;
 			bodyalloc += 4096;
 			body = realloc(body, bodyalloc);
 			if(!body)
 			{
 				ClearNameValueList(&data);
 				SoapError(h, 501, "ActionFailed");
+				free(body_sav);
 				free(port_list);
 				return;
 			}
diff -uNrw miniupnpd-1.7.20121005/upnputils.c miniupnpd-1.8.20130207/upnputils.c
--- miniupnpd-1.7.20121005/upnputils.c	2012-05-25 01:05:48.000000000 +0700
+++ miniupnpd-1.8.20130207/upnputils.c	2013-02-06 17:51:05.000000000 +0700
@@ -1,13 +1,15 @@
-/* $Id: upnputils.c,v 1.5 2012/05/24 16:51:09 nanard Exp $ */
+/* $Id: upnputils.c,v 1.6 2013/02/06 10:50:04 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006-2012 Thomas Bernard
+ * (c) 2006-2013 Thomas Bernard
  * This software is subject to the conditions detailed
  * in the LICENCE file provided within the distribution */
 
 #include "config.h"
 
 #include <stdio.h>
+#include <string.h>
+#include <syslog.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/types.h>
@@ -19,6 +21,10 @@
 #endif
 
 #include "upnputils.h"
+#include "upnpglobalvars.h"
+#ifdef ENABLE_IPV6
+#include "getroute.h"
+#endif
 
 int
 sockaddr_to_string(const struct sockaddr * addr, char * str, size_t size)
@@ -83,3 +89,70 @@
 	return 1;
 }
 
+struct lan_addr_s *
+get_lan_for_peer(const struct sockaddr * peer)
+{
+	struct lan_addr_s * lan_addr = NULL;
+
+#ifdef ENABLE_IPV6
+	if(peer->sa_family == AF_INET6)
+	{
+		struct sockaddr_in6 * peer6 = (struct sockaddr_in6 *)peer;
+		if(IN6_IS_ADDR_V4MAPPED(&peer6->sin6_addr))
+		{
+			struct in_addr peer_addr;
+			memcpy(&peer_addr, &peer6->sin6_addr.s6_addr[12], 4);
+			for(lan_addr = lan_addrs.lh_first;
+			    lan_addr != NULL;
+			    lan_addr = lan_addr->list.le_next)
+			{
+				if( (peer_addr.s_addr & lan_addr->mask.s_addr)
+				   == (lan_addr->addr.s_addr & lan_addr->mask.s_addr))
+					break;
+			}
+		}
+		else
+		{
+			int index = -1;
+			if(get_src_for_route_to(peer, NULL, NULL, &index) < 0)
+				return NULL;
+			syslog(LOG_DEBUG, "%s looking for LAN interface index=%d",
+			       "get_lan_for_peer()", index);
+			for(lan_addr = lan_addrs.lh_first;
+			    lan_addr != NULL;
+			    lan_addr = lan_addr->list.le_next)
+			{
+				syslog(LOG_DEBUG,
+				       "ifname=%s index=%u str=%s addr=%08x mask=%08x",
+				       lan_addr->ifname, lan_addr->index,
+				       lan_addr->str,
+				       ntohl(lan_addr->addr.s_addr),
+				       ntohl(lan_addr->mask.s_addr));
+				if(index == (int)lan_addr->index)
+					break;
+			}
+		}
+	}
+	else if(peer->sa_family == AF_INET)
+	{
+#endif
+		for(lan_addr = lan_addrs.lh_first;
+		    lan_addr != NULL;
+		    lan_addr = lan_addr->list.le_next)
+		{
+			if( (((const struct sockaddr_in *)peer)->sin_addr.s_addr & lan_addr->mask.s_addr)
+			   == (lan_addr->addr.s_addr & lan_addr->mask.s_addr))
+				break;
+		}
+#ifdef ENABLE_IPV6
+	}
+#endif
+
+	if(lan_addr)
+		syslog(LOG_DEBUG, "%s: found in LAN %s %s",
+		       "get_lan_for_peer()", lan_addr->ifname, lan_addr->str);
+	else
+		syslog(LOG_DEBUG, "%s: not found !", "get_lan_for_peer()");
+	return lan_addr;
+}
+
diff -uNrw miniupnpd-1.7.20121005/upnputils.h miniupnpd-1.8.20130207/upnputils.h
--- miniupnpd-1.7.20121005/upnputils.h	2012-10-05 05:34:08.000000000 +0700
+++ miniupnpd-1.8.20130207/upnputils.h	2013-02-06 17:51:05.000000000 +0700
@@ -1,7 +1,7 @@
-/* $Id: upnputils.h,v 1.3 2012/09/27 15:46:18 nanard Exp $ */
+/* $Id: upnputils.h,v 1.4 2013/02/06 10:50:04 nanard Exp $ */
 /* MiniUPnP project
  * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2011-2012 Thomas Bernard
+ * (c) 2011-2013 Thomas Bernard
  * This software is subject to the conditions detailed
  * in the LICENCE file provided within the distribution */
 
@@ -23,5 +23,11 @@
 int
 set_non_blocking(int fd);
 
+/**
+ * get the LAN which the peer belongs to
+ */
+struct lan_addr_s *
+get_lan_for_peer(const struct sockaddr * peer);
+
 #endif
 
diff -uNrw miniupnpd-1.7.20121005/VERSION miniupnpd-1.8.20130207/VERSION
--- miniupnpd-1.7.20121005/VERSION	2012-05-23 15:33:28.000000000 +0700
+++ miniupnpd-1.8.20130207/VERSION	2013-02-06 20:14:42.000000000 +0700
@@ -1 +1 @@
-1.7
+1.8
