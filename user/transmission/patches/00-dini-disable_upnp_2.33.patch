diff --git a/cli/Makefile.am b/user/transmission/cli/Makefile.am
index 9d618f2..aedb736 100644
--- a/cli/Makefile.am
+++ b/user/transmission/cli/Makefile.am
@@ -18,8 +18,6 @@ transmission_cli_SOURCES = cli.c
 
 transmission_cli_LDADD = \
     $(top_builddir)/libtransmission/libtransmission.a \
-    $(top_builddir)/third-party/libnatpmp/libnatpmp.a \
-    $(top_builddir)/third-party/miniupnp/libminiupnp.a \
     @DHT_LIBS@ \
     @LIBUTP_LIBS@ \
     @LIBEVENT_LIBS@ \
diff --git a/configure.ac b/user/transmission/configure.ac
index 52c1105..0db60df 100644
--- a/configure.ac
+++ b/user/transmission/configure.ac
@@ -462,8 +462,6 @@ AC_CONFIG_FILES([Makefile
                  libtransmission/Makefile
                  utils/Makefile
                  third-party/Makefile
-                 third-party/miniupnp/Makefile
-                 third-party/libnatpmp/Makefile
                  third-party/libutp/Makefile
                  third-party/dht/Makefile
                  macosx/Makefile
diff --git a/daemon/Makefile.am b/user/transmission/daemon/Makefile.am
index 9e2a10a..74cd5d9 100644
--- a/daemon/Makefile.am
+++ b/user/transmission/daemon/Makefile.am
@@ -20,8 +20,6 @@ bin_PROGRAMS = \
 
 LDADD = \
     $(top_builddir)/libtransmission/libtransmission.a \
-    $(top_builddir)/third-party/miniupnp/libminiupnp.a \
-    $(top_builddir)/third-party/libnatpmp/libnatpmp.a \
     @DHT_LIBS@ \
     @LIBUTP_LIBS@ \
     @LIBEVENT_LIBS@ \
diff --git a/libtransmission/Makefile.am b/user/transmission/libtransmission/Makefile.am
index 0dd244a..226bfdc 100644
--- a/libtransmission/Makefile.am
+++ b/user/transmission/libtransmission/Makefile.am
@@ -39,13 +39,11 @@ libtransmission_a_SOURCES = \
     magnet.c \
     makemeta.c \
     metainfo.c \
-    natpmp.c \
     net.c \
     peer-io.c \
     peer-mgr.c \
     peer-msgs.c \
     platform.c \
-    port-forwarding.c \
     ptrarray.c \
     resume.c \
     rpcimpl.c \
@@ -61,7 +59,6 @@ libtransmission_a_SOURCES = \
     tr-utp.c \
     tr-getopt.c \
     trevent.c \
-    upnp.c \
     utils.c \
     verify.c \
     web.c \
@@ -90,14 +87,12 @@ noinst_HEADERS = \
     magnet.h \
     makemeta.h \
     metainfo.h \
-    natpmp.h \
     net.h \
     peer-common.h \
     peer-io.h \
     peer-mgr.h \
     peer-msgs.h \
     platform.h \
-    port-forwarding.h \
     ptrarray.h \
     resume.h \
     rpcimpl.h \
@@ -113,7 +108,6 @@ noinst_HEADERS = \
     tr-utp.h \
     tr-lpd.h \
     trevent.h \
-    upnp.h \
     utils.h \
     verify.h \
     version.h \
@@ -139,8 +133,6 @@ apps_ldflags = \
 
 apps_ldadd = \
     ./libtransmission.a  \
-    $(top_builddir)/third-party/miniupnp/libminiupnp.a \
-    $(top_builddir)/third-party/libnatpmp/libnatpmp.a \
     @INTLLIBS@ \
     @DHT_LIBS@ \
     @LIBUTP_LIBS@ \
diff --git a/libtransmission/natpmp.c b/user/transmission/libtransmission/natpmp.c
deleted file mode 100644
index c64d030..0000000
--- a/libtransmission/natpmp.c
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * This file Copyright (C) Mnemosyne LLC
- *
- * This file is licensed by the GPL version 2. Works owned by the
- * Transmission project are granted a special exemption to clause 2(b)
- * so that the bulk of its code can remain under the MIT license.
- * This exemption does not extend to derived works not owned by
- * the Transmission project.
- *
- * $Id: natpmp.c 12225 2011-03-24 22:57:39Z jordan $
- */
-
-#include <errno.h>
-#include <time.h>
-#include <inttypes.h>
-
-#include <event2/util.h> /* evutil_inet_ntop() */
-
-#define ENABLE_STRNATPMPERR
-#include <libnatpmp/natpmp.h>
-
-#include "transmission.h"
-#include "natpmp.h"
-#include "net.h" /* tr_netCloseSocket */
-#include "port-forwarding.h"
-#include "utils.h"
-
-#define LIFETIME_SECS 3600
-#define COMMAND_WAIT_SECS 8
-
-static const char *
-getKey( void ) { return _( "Port Forwarding (NAT-PMP)" ); }
-
-typedef enum
-{
-    TR_NATPMP_IDLE,
-    TR_NATPMP_ERR,
-    TR_NATPMP_DISCOVER,
-    TR_NATPMP_RECV_PUB,
-    TR_NATPMP_SEND_MAP,
-    TR_NATPMP_RECV_MAP,
-    TR_NATPMP_SEND_UNMAP,
-    TR_NATPMP_RECV_UNMAP
-}
-tr_natpmp_state;
-
-struct tr_natpmp
-{
-    bool              has_discovered;
-    bool              is_mapped;
-
-    tr_port           public_port;
-    tr_port           private_port;
-
-    time_t            renew_time;
-    time_t            command_time;
-    tr_natpmp_state   state;
-    natpmp_t          natpmp;
-};
-
-/**
-***
-**/
-
-static void
-logVal( const char * func,
-        int          ret )
-{
-    if( ret == NATPMP_TRYAGAIN )
-        return;
-    if( ret >= 0 )
-        tr_ninf( getKey( ), _( "%s succeeded (%d)" ), func, ret );
-    else
-        tr_ndbg(
-             getKey( ),
-            "%s failed. Natpmp returned %d (%s); errno is %d (%s)",
-            func, ret, strnatpmperr( ret ), errno, tr_strerror( errno ) );
-}
-
-struct tr_natpmp*
-tr_natpmpInit( void )
-{
-    struct tr_natpmp * nat;
-
-    nat = tr_new0( struct tr_natpmp, 1 );
-    nat->state = TR_NATPMP_DISCOVER;
-    nat->public_port = 0;
-    nat->private_port = 0;
-    nat->natpmp.s = -1; /* socket */
-    return nat;
-}
-
-void
-tr_natpmpClose( tr_natpmp * nat )
-{
-    if( nat )
-    {
-        if( nat->natpmp.s >= 0 )
-            tr_netCloseSocket( nat->natpmp.s );
-        tr_free( nat );
-    }
-}
-
-static int
-canSendCommand( const struct tr_natpmp * nat )
-{
-    return tr_time( ) >= nat->command_time;
-}
-
-static void
-setCommandTime( struct tr_natpmp * nat )
-{
-    nat->command_time = tr_time( ) + COMMAND_WAIT_SECS;
-}
-
-int
-tr_natpmpPulse( struct tr_natpmp * nat, tr_port private_port, bool is_enabled, tr_port * public_port )
-{
-    int ret;
-
-    if( is_enabled && ( nat->state == TR_NATPMP_DISCOVER ) )
-    {
-        int val = initnatpmp( &nat->natpmp );
-        logVal( "initnatpmp", val );
-        val = sendpublicaddressrequest( &nat->natpmp );
-        logVal( "sendpublicaddressrequest", val );
-        nat->state = val < 0 ? TR_NATPMP_ERR : TR_NATPMP_RECV_PUB;
-        nat->has_discovered = true;
-        setCommandTime( nat );
-    }
-
-    if( ( nat->state == TR_NATPMP_RECV_PUB ) && canSendCommand( nat ) )
-    {
-        natpmpresp_t response;
-        const int val = readnatpmpresponseorretry( &nat->natpmp, &response );
-        logVal( "readnatpmpresponseorretry", val );
-        if( val >= 0 )
-        {
-            char str[128];
-            evutil_inet_ntop( AF_INET, &response.pnu.publicaddress.addr, str, sizeof( str ) );
-            tr_ninf( getKey( ), _( "Found public address \"%s\"" ), str );
-            nat->state = TR_NATPMP_IDLE;
-        }
-        else if( val != NATPMP_TRYAGAIN )
-        {
-            nat->state = TR_NATPMP_ERR;
-        }
-    }
-
-    if( ( nat->state == TR_NATPMP_IDLE ) || ( nat->state == TR_NATPMP_ERR ) )
-    {
-        if( nat->is_mapped && ( !is_enabled || ( nat->private_port != private_port ) ) )
-            nat->state = TR_NATPMP_SEND_UNMAP;
-    }
-
-    if( ( nat->state == TR_NATPMP_SEND_UNMAP ) && canSendCommand( nat ) )
-    {
-        const int val = sendnewportmappingrequest( &nat->natpmp, NATPMP_PROTOCOL_TCP,
-                                                   nat->private_port,
-                                                   nat->public_port,
-                                                   0 );
-        logVal( "sendnewportmappingrequest", val );
-        nat->state = val < 0 ? TR_NATPMP_ERR : TR_NATPMP_RECV_UNMAP;
-        setCommandTime( nat );
-    }
-
-    if( nat->state == TR_NATPMP_RECV_UNMAP )
-    {
-        natpmpresp_t resp;
-        const int val = readnatpmpresponseorretry( &nat->natpmp, &resp );
-        logVal( "readnatpmpresponseorretry", val );
-        if( val >= 0 )
-        {
-            const int private_port = resp.pnu.newportmapping.privateport;
-
-            tr_ninf( getKey( ), _( "no longer forwarding port %d" ), private_port );
-
-            if( nat->private_port == private_port )
-            {
-                nat->private_port = 0;
-                nat->public_port = 0;
-                nat->state = TR_NATPMP_IDLE;
-                nat->is_mapped = false;
-            }
-        }
-        else if( val != NATPMP_TRYAGAIN )
-        {
-            nat->state = TR_NATPMP_ERR;
-        }
-    }
-
-    if( nat->state == TR_NATPMP_IDLE )
-    {
-        if( is_enabled && !nat->is_mapped && nat->has_discovered )
-            nat->state = TR_NATPMP_SEND_MAP;
-
-        else if( nat->is_mapped && tr_time( ) >= nat->renew_time )
-            nat->state = TR_NATPMP_SEND_MAP;
-    }
-
-    if( ( nat->state == TR_NATPMP_SEND_MAP ) && canSendCommand( nat ) )
-    {
-        const int val = sendnewportmappingrequest( &nat->natpmp, NATPMP_PROTOCOL_TCP, private_port, private_port, LIFETIME_SECS );
-        logVal( "sendnewportmappingrequest", val );
-        nat->state = val < 0 ? TR_NATPMP_ERR : TR_NATPMP_RECV_MAP;
-        setCommandTime( nat );
-    }
-
-    if( nat->state == TR_NATPMP_RECV_MAP )
-    {
-        natpmpresp_t resp;
-        const int    val = readnatpmpresponseorretry( &nat->natpmp, &resp );
-        logVal( "readnatpmpresponseorretry", val );
-        if( val >= 0 )
-        {
-            nat->state = TR_NATPMP_IDLE;
-            nat->is_mapped = true;
-            nat->renew_time = tr_time( ) + ( resp.pnu.newportmapping.lifetime / 2 );
-            nat->private_port = resp.pnu.newportmapping.privateport;
-            nat->public_port = resp.pnu.newportmapping.mappedpublicport;
-            tr_ninf( getKey( ), _( "Port %d forwarded successfully" ), nat->private_port );
-        }
-        else if( val != NATPMP_TRYAGAIN )
-        {
-            nat->state = TR_NATPMP_ERR;
-        }
-    }
-
-    switch( nat->state )
-    {
-        case TR_NATPMP_IDLE:
-            *public_port = nat->public_port;
-            return nat->is_mapped ? TR_PORT_MAPPED : TR_PORT_UNMAPPED;
-            break;
-
-        case TR_NATPMP_DISCOVER:
-            ret = TR_PORT_UNMAPPED; break;
-
-        case TR_NATPMP_RECV_PUB:
-        case TR_NATPMP_SEND_MAP:
-        case TR_NATPMP_RECV_MAP:
-            ret = TR_PORT_MAPPING; break;
-
-        case TR_NATPMP_SEND_UNMAP:
-        case TR_NATPMP_RECV_UNMAP:
-            ret = TR_PORT_UNMAPPING; break;
-
-        default:
-            ret = TR_PORT_ERROR; break;
-    }
-    return ret;
-}
-
diff --git a/libtransmission/natpmp.h b/user/transmission/libtransmission/natpmp.h
deleted file mode 100644
index 0ed7ef1..0000000
--- a/libtransmission/natpmp.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * This file Copyright (C) Mnemosyne LLC
- *
- * This file is licensed by the GPL version 2. Works owned by the
- * Transmission project are granted a special exemption to clause 2(b)
- * so that the bulk of its code can remain under the MIT license.
- * This exemption does not extend to derived works not owned by
- * the Transmission project.
- *
- * $Id: natpmp.h 12204 2011-03-22 15:19:54Z jordan $
- */
-
-#ifndef __TRANSMISSION__
-#error only libtransmission should #include this header.
-#endif
-
-#ifndef TR_NATPMP_H
-#define TR_NATPMP_H 1
-
-/**
- * @addtogroup port_forwarding Port Forwarding
- * @{
- */
-
-typedef struct tr_natpmp tr_natpmp;
-
-tr_natpmp * tr_natpmpInit( void );
-
-void tr_natpmpClose( tr_natpmp * );
-
-int tr_natpmpPulse( tr_natpmp *, tr_port port, bool isEnabled, tr_port * public_port );
-
-/* @} */
-#endif
diff --git a/libtransmission/port-forwarding.c b/user/transmission/libtransmission/port-forwarding.c
deleted file mode 100644
index bca8b58..0000000
--- a/libtransmission/port-forwarding.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * This file Copyright (C) Mnemosyne LLC
- *
- * This file is licensed by the GPL version 2. Works owned by the
- * Transmission project are granted a special exemption to clause 2(b)
- * so that the bulk of its code can remain under the MIT license.
- * This exemption does not extend to derived works not owned by
- * the Transmission project.
- *
- * $Id: port-forwarding.c 12228 2011-03-25 01:41:57Z jordan $
- */
-
-#include <assert.h>
-#include <stdio.h>
-
-#include <sys/types.h>
-
-#include <event2/event.h>
-
-#include "transmission.h"
-#include "natpmp.h"
-#include "net.h"
-#include "peer-mgr.h"
-#include "port-forwarding.h"
-#include "session.h"
-#include "torrent.h"
-#include "upnp.h"
-#include "utils.h"
-
-static const char *
-getKey( void ) { return _( "Port Forwarding" ); }
-
-struct tr_shared
-{
-    bool               isEnabled;
-    bool               isShuttingDown;
-    bool               doPortCheck;
-
-    tr_port_forwarding    natpmpStatus;
-    tr_port_forwarding    upnpStatus;
-
-    tr_upnp             * upnp;
-    tr_natpmp           * natpmp;
-    tr_session          * session;
-
-    struct event        * timer;
-};
-
-/***
-****
-***/
-
-static const char*
-getNatStateStr( int state )
-{
-    switch( state )
-    {
-        case TR_PORT_MAPPING:   return _( "Starting" );
-        case TR_PORT_MAPPED:    return _( "Forwarded" );
-        case TR_PORT_UNMAPPING: return _( "Stopping" );
-        case TR_PORT_UNMAPPED:  return _( "Not forwarded" );
-        default:                return "???";
-    }
-}
-
-static void
-natPulse( tr_shared * s, bool do_check )
-{
-    const tr_port private_peer_port = s->session->private_peer_port;
-    const int is_enabled = s->isEnabled && !s->isShuttingDown;
-    tr_port public_peer_port;
-    int oldStatus;
-    int newStatus;
-
-    if( s->natpmp == NULL )
-        s->natpmp = tr_natpmpInit( );
-    if( s->upnp == NULL )
-        s->upnp = tr_upnpInit( );
-
-    oldStatus = tr_sharedTraversalStatus( s );
-
-    s->natpmpStatus = tr_natpmpPulse( s->natpmp, private_peer_port, is_enabled, &public_peer_port );
-    if( s->natpmpStatus == TR_PORT_MAPPED )
-        s->session->public_peer_port = public_peer_port;
-
-    s->upnpStatus = tr_upnpPulse( s->upnp, private_peer_port, is_enabled, do_check );
-
-    newStatus = tr_sharedTraversalStatus( s );
-
-    if( newStatus != oldStatus )
-        tr_ninf( getKey( ), _( "State changed from \"%1$s\" to \"%2$s\"" ),
-                getNatStateStr( oldStatus ),
-                getNatStateStr( newStatus ) );
-}
-
-static void
-set_evtimer_from_status( tr_shared * s )
-{
-    int sec=0, msec=0;
-
-    /* when to wake up again */
-    switch( tr_sharedTraversalStatus( s ) )
-    {
-        case TR_PORT_MAPPED:
-            /* if we're mapped, everything is fine... check back in 20 minutes
-             * to renew the port forwarding if it's expired */
-            s->doPortCheck = true;
-            sec = 60 * 20;
-            break;
-
-        case TR_PORT_ERROR:
-            /* some kind of an error. wait 60 seconds and retry */
-            sec = 60;
-            break;
-
-        default:
-            /* in progress. pulse frequently. */
-            msec = 333000;
-            break;
-    }
-
-    if( s->timer != NULL )
-        tr_timerAdd( s->timer, sec, msec );
-}
-
-static void
-onTimer( int fd UNUSED, short what UNUSED, void * vshared )
-{
-    tr_shared * s = vshared;
-
-    assert( s );
-    assert( s->timer );
-
-    /* do something */
-    natPulse( s, s->doPortCheck );
-    s->doPortCheck = false;
-
-    /* set up the timer for the next pulse */
-    set_evtimer_from_status( s );
-}
-
-/***
-****
-***/
-
-tr_shared *
-tr_sharedInit( tr_session  * session )
-{
-    tr_shared * s = tr_new0( tr_shared, 1 );
-
-    s->session      = session;
-    s->isEnabled    = false;
-    s->upnpStatus   = TR_PORT_UNMAPPED;
-    s->natpmpStatus = TR_PORT_UNMAPPED;
-
-#if 0
-    if( isEnabled )
-    {
-        s->timer = tr_new0( struct event, 1 );
-        evtimer_set( s->timer, onTimer, s );
-        tr_timerAdd( s->timer, 0, 333000 );
-    }
-#endif
-
-    return s;
-}
-
-static void
-stop_timer( tr_shared * s )
-{
-    if( s->timer != NULL )
-    {
-        event_free( s->timer );
-        s->timer = NULL;
-    }
-}
-
-static void
-stop_forwarding( tr_shared * s )
-{
-    tr_ninf( getKey( ), "%s", _( "Stopped" ) );
-    natPulse( s, false );
-
-    tr_natpmpClose( s->natpmp );
-    s->natpmp = NULL;
-    s->natpmpStatus = TR_PORT_UNMAPPED;
-
-    tr_upnpClose( s->upnp );
-    s->upnp = NULL;
-    s->upnpStatus = TR_PORT_UNMAPPED;
-
-    stop_timer( s );
-}
-
-void
-tr_sharedClose( tr_session * session )
-{
-    tr_shared * s = session->shared;
-
-    s->isShuttingDown = true;
-    stop_forwarding( s );
-    s->session->shared = NULL;
-    tr_free( s );
-}
-
-static void
-start_timer( tr_shared * s )
-{
-    s->timer = evtimer_new( s->session->event_base, onTimer, s );
-    set_evtimer_from_status( s );
-}
-
-void
-tr_sharedTraversalEnable( tr_shared * s, bool isEnabled )
-{
-    if(( s->isEnabled = isEnabled ))
-        start_timer( s );
-    else
-        stop_forwarding( s );
-}
-
-void
-tr_sharedPortChanged( tr_session * session )
-{
-    tr_shared * s = session->shared;
-
-    if( s->isEnabled )
-    {
-        stop_timer( s );
-        natPulse( s, false );
-        start_timer( s );
-    }
-}
-
-bool
-tr_sharedTraversalIsEnabled( const tr_shared * s )
-{
-    return s->isEnabled;
-}
-
-int
-tr_sharedTraversalStatus( const tr_shared * s )
-{
-    return MAX( s->natpmpStatus, s->upnpStatus );
-}
diff --git a/libtransmission/port-forwarding.h b/user/transmission/libtransmission/port-forwarding.h
deleted file mode 100644
index 76eb22f..0000000
--- a/libtransmission/port-forwarding.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * This file Copyright (C) Mnemosyne LLC
- *
- * This file is licensed by the GPL version 2. Works owned by the
- * Transmission project are granted a special exemption to clause 2(b)
- * so that the bulk of its code can remain under the MIT license.
- * This exemption does not extend to derived works not owned by
- * the Transmission project.
- *
- * $Id: port-forwarding.h 12224 2011-03-24 22:45:04Z jordan $
- */
-
-#ifndef __TRANSMISSION__
-#error only libtransmission should #include this header.
-#endif
-
-#ifndef SHARED_H
-#define SHARED_H 1
-
-#include "transmission.h"
-
-/**
- * @addtogroup port_forwarding Port Forwarding
- * @{
- */
-
-struct tr_bindsockets;
-
-typedef struct tr_shared tr_shared;
-
-tr_shared* tr_sharedInit( tr_session* );
-
-void       tr_sharedClose( tr_session * );
-
-void       tr_sharedPortChanged( tr_session * );
-
-void       tr_sharedTraversalEnable( tr_shared *, bool isEnabled );
-
-tr_port    tr_sharedGetPeerPort( const tr_shared * s );
-
-bool       tr_sharedTraversalIsEnabled( const tr_shared * s );
-
-int        tr_sharedTraversalStatus( const tr_shared * );
-
-/** @} */
-#endif
diff --git a/libtransmission/rpcimpl.c b/user/transmission/libtransmission/rpcimpl.c
index 042284b..c42e7fe 100644
--- a/libtransmission/rpcimpl.c
+++ b/user/transmission/libtransmission/rpcimpl.c
@@ -1487,8 +1487,6 @@ sessionSet( tr_session               * session,
         tr_sessionSetPeerPortRandomOnStart( session, boolVal );
     if( tr_bencDictFindInt( args_in, TR_PREFS_KEY_PEER_PORT, &i ) )
         tr_sessionSetPeerPort( session, i );
-    if( tr_bencDictFindBool( args_in, TR_PREFS_KEY_PORT_FORWARDING, &boolVal ) )
-        tr_sessionSetPortForwardingEnabled( session, boolVal );
     if( tr_bencDictFindBool( args_in, TR_PREFS_KEY_RENAME_PARTIAL_FILES, &boolVal ) )
         tr_sessionSetIncompleteFileNamingEnabled( session, boolVal );
     if( tr_bencDictFindReal( args_in, "seedRatioLimit", &d ) )
@@ -1610,7 +1608,6 @@ sessionGet( tr_session               * s,
     tr_bencDictAddBool( d, TR_PREFS_KEY_LPD_ENABLED, tr_sessionIsLPDEnabled( s ) );
     tr_bencDictAddInt ( d, TR_PREFS_KEY_PEER_PORT, tr_sessionGetPeerPort( s ) );
     tr_bencDictAddBool( d, TR_PREFS_KEY_PEER_PORT_RANDOM_ON_START, tr_sessionGetPeerPortRandomOnStart( s ) );
-    tr_bencDictAddBool( d, TR_PREFS_KEY_PORT_FORWARDING, tr_sessionIsPortForwardingEnabled( s ) );
     tr_bencDictAddBool( d, TR_PREFS_KEY_RENAME_PARTIAL_FILES, tr_sessionIsIncompleteFileNamingEnabled( s ) );
     tr_bencDictAddInt ( d, "rpc-version", RPC_VERSION );
     tr_bencDictAddInt ( d, "rpc-version-minimum", RPC_VERSION_MIN );
diff --git a/libtransmission/session.c b/user/transmission/libtransmission/session.c
index b4f4d22..b522868 100644
--- a/libtransmission/session.c
+++ b/user/transmission/libtransmission/session.c
@@ -38,7 +38,6 @@
 #include "peer-io.h"
 #include "peer-mgr.h"
 #include "platform.h" /* tr_lock, tr_getTorrentDir(), tr_getFreeSpace() */
-#include "port-forwarding.h"
 #include "rpc-server.h"
 #include "session.h"
 #include "stats.h"
@@ -327,7 +326,6 @@ tr_sessionGetDefaultSettings( tr_benc * d )
     tr_bencDictAddInt ( d, TR_PREFS_KEY_PEER_PORT_RANDOM_HIGH,    65535 );
     tr_bencDictAddStr ( d, TR_PREFS_KEY_PEER_SOCKET_TOS,          TR_DEFAULT_PEER_SOCKET_TOS_STR );
     tr_bencDictAddBool( d, TR_PREFS_KEY_PEX_ENABLED,              true );
-    tr_bencDictAddBool( d, TR_PREFS_KEY_PORT_FORWARDING,          true );
     tr_bencDictAddInt ( d, TR_PREFS_KEY_PREALLOCATION,            TR_PREALLOCATE_SPARSE );
     tr_bencDictAddBool( d, TR_PREFS_KEY_PREFETCH_ENABLED,         DEFAULT_PREFETCH_ENABLED );
     tr_bencDictAddReal( d, TR_PREFS_KEY_RATIO,                    2.0 );
@@ -391,7 +389,6 @@ tr_sessionGetSettings( tr_session * s, struct tr_benc * d )
     tr_bencDictAddStr ( d, TR_PREFS_KEY_PEER_SOCKET_TOS,          format_tos(s->peerSocketTOS) );
     tr_bencDictAddStr ( d, TR_PREFS_KEY_PEER_CONGESTION_ALGORITHM, s->peer_congestion_algorithm );
     tr_bencDictAddBool( d, TR_PREFS_KEY_PEX_ENABLED,              s->isPexEnabled );
-    tr_bencDictAddBool( d, TR_PREFS_KEY_PORT_FORWARDING,          tr_sessionIsPortForwardingEnabled( s ) );
     tr_bencDictAddInt ( d, TR_PREFS_KEY_PREALLOCATION,            s->preallocationMode );
     tr_bencDictAddInt ( d, TR_PREFS_KEY_PREFETCH_ENABLED,         s->isPrefetchEnabled );
     tr_bencDictAddReal( d, TR_PREFS_KEY_RATIO,                    s->desiredRatio );
@@ -679,8 +676,6 @@ tr_sessionInitImpl( void * vdata )
 
     session->peerMgr = tr_peerMgrNew( session );
 
-    session->shared = tr_sharedInit( session );
-
     /**
     ***  Blocklist
     **/
@@ -824,8 +819,6 @@ sessionSetImpl( void * vdata )
     if( !tr_bencDictFindInt( settings, TR_PREFS_KEY_PEER_PORT, &i ) )
         i = session->private_peer_port;
     setPeerPort( session, boolVal ? getRandomPort( session ) : i );
-    if( tr_bencDictFindBool( settings, TR_PREFS_KEY_PORT_FORWARDING, &boolVal ) )
-        tr_sessionSetPortForwardingEnabled( session, boolVal );
 
     if( tr_bencDictFindInt( settings, TR_PREFS_KEY_PEER_LIMIT_GLOBAL, &i ) )
         session->peerLimit = i;
@@ -1040,7 +1033,6 @@ peerPortChanged( void * session )
 
     close_incoming_peer_port( session );
     open_incoming_peer_port( session );
-    tr_sharedPortChanged( session );
 
     while(( tor = tr_torrentNext( session, tor )))
         tr_torrentChangeMyPort( tor );
@@ -1096,14 +1088,6 @@ tr_sessionGetPeerPortRandomOnStart( tr_session * session )
     return session->isPortRandom;
 }
 
-tr_port_forwarding
-tr_sessionGetPortForwarding( const tr_session * session )
-{
-    assert( tr_isSession( session ) );
-
-    return tr_sharedTraversalStatus( session->shared );
-}
-
 /***
 ****
 ***/
@@ -1715,7 +1699,6 @@ sessionCloseImpl( void * vsession )
     session->nowTimer = NULL;
 
     tr_verifyClose( session );
-    tr_sharedClose( session );
     tr_rpcClose( &session->rpcServer );
 
     /* Close the torrents. Get the most active ones first so that
@@ -2092,42 +2075,6 @@ tr_sessionGetCacheLimit_MB( const tr_session * session )
 ****
 ***/
 
-struct port_forwarding_data
-{
-    bool enabled;
-    struct tr_shared * shared;
-};
-
-static void
-setPortForwardingEnabled( void * vdata )
-{
-    struct port_forwarding_data * data = vdata;
-    tr_sharedTraversalEnable( data->shared, data->enabled );
-    tr_free( data );
-}
-
-void
-tr_sessionSetPortForwardingEnabled( tr_session  * session, bool enabled )
-{
-    struct port_forwarding_data * d;
-    d = tr_new0( struct port_forwarding_data, 1 );
-    d->shared = session->shared;
-    d->enabled = enabled;
-    tr_runInEventThread( session, setPortForwardingEnabled, d );
-}
-
-bool
-tr_sessionIsPortForwardingEnabled( const tr_session * session )
-{
-    assert( tr_isSession( session ) );
-
-    return tr_sharedTraversalIsEnabled( session->shared );
-}
-
-/***
-****
-***/
-
 static int
 tr_stringEndsWith( const char * str, const char * end )
 {
diff --git a/libtransmission/upnp.c b/user/transmission/libtransmission/upnp.c
deleted file mode 100644
index 2059864..0000000
--- a/libtransmission/upnp.c
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * This file Copyright (C) Mnemosyne LLC
- *
- * This file is licensed by the GPL version 2. Works owned by the
- * Transmission project are granted a special exemption to clause 2(b)
- * so that the bulk of its code can remain under the MIT license.
- * This exemption does not extend to derived works not owned by
- * the Transmission project.
- *
- * $Id: upnp.c 12204 2011-03-22 15:19:54Z jordan $
- */
-
-#include <assert.h>
-#include <errno.h>
-
-#include <miniupnp/miniupnpc.h>
-#include <miniupnp/upnpcommands.h>
-
-#include "transmission.h"
-#include "port-forwarding.h"
-#include "session.h"
-#include "upnp.h"
-#include "utils.h"
-
-static const char *
-getKey( void ) { return _( "Port Forwarding (UPnP)" ); }
-
-typedef enum
-{
-    TR_UPNP_IDLE,
-    TR_UPNP_ERR,
-    TR_UPNP_DISCOVER,
-    TR_UPNP_MAP,
-    TR_UPNP_UNMAP
-}
-tr_upnp_state;
-
-struct tr_upnp
-{
-    bool               hasDiscovered;
-    struct UPNPUrls    urls;
-    struct IGDdatas    data;
-    int                port;
-    char               lanaddr[16];
-    unsigned int       isMapped;
-    tr_upnp_state      state;
-};
-
-/**
-***
-**/
-
-tr_upnp*
-tr_upnpInit( void )
-{
-    tr_upnp * ret = tr_new0( tr_upnp, 1 );
-
-    ret->state = TR_UPNP_DISCOVER;
-    ret->port = -1;
-    return ret;
-}
-
-void
-tr_upnpClose( tr_upnp * handle )
-{
-    assert( !handle->isMapped );
-    assert( ( handle->state == TR_UPNP_IDLE )
-          || ( handle->state == TR_UPNP_ERR )
-          || ( handle->state == TR_UPNP_DISCOVER ) );
-
-    if( handle->hasDiscovered )
-        FreeUPNPUrls( &handle->urls );
-    tr_free( handle );
-}
-
-/**
-***
-**/
-
-enum
-{
-  UPNP_IGD_NONE = 0,
-  UPNP_IGD_VALID_CONNECTED = 1,
-  UPNP_IGD_VALID_NOT_CONNECTED = 2,
-  UPNP_IGD_INVALID = 3
-};
-
-int
-tr_upnpPulse( tr_upnp * handle,
-              int       port,
-              int       isEnabled,
-              int       doPortCheck )
-{
-    int ret;
-
-    if( isEnabled && ( handle->state == TR_UPNP_DISCOVER ) )
-    {
-        struct UPNPDev * devlist;
-        errno = 0;
-        devlist = upnpDiscover( 2000, NULL, NULL, 0 );
-        if( devlist == NULL )
-        {
-            tr_ndbg(
-                 getKey( ), "upnpDiscover failed (errno %d - %s)", errno,
-                tr_strerror( errno ) );
-        }
-        errno = 0;
-        if( UPNP_GetValidIGD( devlist, &handle->urls, &handle->data,
-                             handle->lanaddr, sizeof( handle->lanaddr ) ) == UPNP_IGD_VALID_CONNECTED )
-        {
-            tr_ninf( getKey( ), _(
-                         "Found Internet Gateway Device \"%s\"" ),
-                     handle->urls.controlURL );
-            tr_ninf( getKey( ), _(
-                         "Local Address is \"%s\"" ), handle->lanaddr );
-            handle->state = TR_UPNP_IDLE;
-            handle->hasDiscovered = 1;
-        }
-        else
-        {
-            handle->state = TR_UPNP_ERR;
-            tr_ndbg(
-                 getKey( ), "UPNP_GetValidIGD failed (errno %d - %s)",
-                errno,
-                tr_strerror( errno ) );
-            tr_ndbg(
-                getKey( ),
-                "If your router supports UPnP, please make sure UPnP is enabled!" );
-        }
-        freeUPNPDevlist( devlist );
-    }
-
-    if( handle->state == TR_UPNP_IDLE )
-    {
-        if( handle->isMapped && ( !isEnabled || ( handle->port != port ) ) )
-            handle->state = TR_UPNP_UNMAP;
-    }
-
-    if( isEnabled && handle->isMapped && doPortCheck )
-    {
-        char portStr[8];
-        char intPort[8];
-        char intClient[16];
-
-        tr_snprintf( portStr, sizeof( portStr ), "%d", handle->port );
-        if( UPNP_GetSpecificPortMappingEntry( handle->urls.controlURL, handle->data.first.servicetype,
-            portStr, "TCP", intClient, intPort ) != UPNPCOMMAND_SUCCESS  ||
-            UPNP_GetSpecificPortMappingEntry( handle->urls.controlURL, handle->data.first.servicetype,
-            portStr, "UDP", intClient, intPort ) != UPNPCOMMAND_SUCCESS )
-        {
-            tr_ninf( getKey( ), _( "Port %d isn't forwarded" ), handle->port );
-            handle->isMapped = false;
-        }
-    }
-
-    if( handle->state == TR_UPNP_UNMAP )
-    {
-        char portStr[16];
-        tr_snprintf( portStr, sizeof( portStr ), "%d", handle->port );
-        UPNP_DeletePortMapping( handle->urls.controlURL,
-                                handle->data.first.servicetype,
-                                portStr, "TCP", NULL );
-        UPNP_DeletePortMapping( handle->urls.controlURL,
-                                handle->data.first.servicetype,
-                                portStr, "UDP", NULL );
-        tr_ninf( getKey( ),
-                 _(
-                     "Stopping port forwarding through \"%s\", service \"%s\"" ),
-                 handle->urls.controlURL, handle->data.first.servicetype );
-        handle->isMapped = 0;
-        handle->state = TR_UPNP_IDLE;
-        handle->port = -1;
-    }
-
-    if( handle->state == TR_UPNP_IDLE )
-    {
-        if( isEnabled && !handle->isMapped )
-            handle->state = TR_UPNP_MAP;
-    }
-
-    if( handle->state == TR_UPNP_MAP )
-    {
-        int  err_tcp = -1;
-        int  err_udp = -1;
-        errno = 0;
-
-        if( !handle->urls.controlURL || !handle->data.first.servicetype )
-            handle->isMapped = 0;
-        else
-        {
-            char portStr[16];
-            char desc[64];
-            const int prev_errno = errno;
-            tr_snprintf( portStr, sizeof( portStr ), "%d", port );
-            tr_snprintf( desc, sizeof( desc ), "%s at %d", TR_NAME, port );
-
-            errno = 0;
-            err_tcp = UPNP_AddPortMapping( handle->urls.controlURL,
-                                       handle->data.first.servicetype,
-                                       portStr, portStr, handle->lanaddr,
-                                       desc, "TCP", NULL );
-            if( err_tcp )
-                tr_ndbg( getKey( ), "TCP Port forwarding failed with error %d (errno %d - %s)",
-                         err_tcp, errno, tr_strerror( errno ) );
-
-            errno = 0;
-            err_udp = UPNP_AddPortMapping( handle->urls.controlURL,
-                                       handle->data.first.servicetype,
-                                       portStr, portStr, handle->lanaddr,
-                                       desc, "UDP", NULL );
-            if( err_udp )
-                tr_ndbg( getKey( ), "UDP Port forwarding failed with error %d (errno %d - %s)",
-                         err_udp, errno, tr_strerror( errno ) );
-
-            errno = prev_errno;
-            handle->isMapped = !err_tcp | !err_udp;
-        }
-        tr_ninf( getKey( ),
-                 _( "Port forwarding through \"%s\", service \"%s\". (local address: %s:%d)" ),
-                 handle->urls.controlURL, handle->data.first.servicetype,
-                 handle->lanaddr, port );
-        if( handle->isMapped )
-        {
-            tr_ninf( getKey( ), "%s", _( "Port forwarding successful!" ) );
-            handle->port = port;
-            handle->state = TR_UPNP_IDLE;
-        }
-        else
-        {
-            tr_ndbg( getKey( ), "If your router supports UPnP, please make sure UPnP is enabled!" );
-            handle->port = -1;
-            handle->state = TR_UPNP_ERR;
-        }
-    }
-
-    switch( handle->state )
-    {
-        case TR_UPNP_DISCOVER:
-            ret = TR_PORT_UNMAPPED; break;
-
-        case TR_UPNP_MAP:
-            ret = TR_PORT_MAPPING; break;
-
-        case TR_UPNP_UNMAP:
-            ret = TR_PORT_UNMAPPING; break;
-
-        case TR_UPNP_IDLE:
-            ret = handle->isMapped ? TR_PORT_MAPPED
-                  : TR_PORT_UNMAPPED; break;
-
-        default:
-            ret = TR_PORT_ERROR; break;
-    }
-
-    return ret;
-}
-
diff --git a/libtransmission/upnp.h b/user/transmission/libtransmission/upnp.h
deleted file mode 100644
index 2c316cb..0000000
--- a/libtransmission/upnp.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * This file Copyright (C) Mnemosyne LLC
- *
- * This file is licensed by the GPL version 2. Works owned by the
- * Transmission project are granted a special exemption to clause 2(b)
- * so that the bulk of its code can remain under the MIT license.
- * This exemption does not extend to derived works not owned by
- * the Transmission project.
- *
- * $Id: upnp.h 11709 2011-01-19 13:48:47Z jordan $
- */
-
-#ifndef __TRANSMISSION__
-#error only libtransmission should #include this header.
-#endif
-
-#ifndef TR_UPNP_H
-#define TR_UPNP_H 1
-
-/**
- * @addtogroup port_forwarding Port Forwarding
- * @{
- */
-
-typedef struct tr_upnp tr_upnp;
-
-tr_upnp * tr_upnpInit( void );
-
-void      tr_upnpClose( tr_upnp * );
-
-int       tr_upnpPulse(         tr_upnp *,
-                            int port,
-                            int isEnabled,
-                            int doPortCheck );
-/* @} */
-#endif
diff --git a/third-party/Makefile.am b/user/transmission/third-party/Makefile.am
index 39eb5ee..540bccd 100644
--- a/third-party/Makefile.am
+++ b/user/transmission/third-party/Makefile.am
@@ -4,8 +4,6 @@ endif
 
 SUBDIRS = \
   dht \
-  libnatpmp \
-  miniupnp \
   $(UTP_DIR)
 
 EXTRA_DIST = \
diff --git a/third-party/libnatpmp/LICENSE b/user/transmission/third-party/libnatpmp/LICENSE
deleted file mode 100644
index 14db2fe..0000000
--- a/third-party/libnatpmp/LICENSE
+++ /dev/null
@@ -1,26 +0,0 @@
-Copyright (c) 2007-2009, Thomas BERNARD 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice,
-      this list of conditions and the following disclaimer in the documentation
-      and/or other materials provided with the distribution.
-    * The name of the author may not be used to endorse or promote products
-	  derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
diff --git a/third-party/libnatpmp/Makefile.am b/user/transmission/third-party/libnatpmp/Makefile.am
deleted file mode 100644
index de9fb74..0000000
--- a/third-party/libnatpmp/Makefile.am
+++ /dev/null
@@ -1,18 +0,0 @@
-noinst_LIBRARIES = libnatpmp.a
-
-AM_CFLAGS = @PTHREAD_CFLAGS@ -DENABLE_STRNATPMPERR
-
-libnatpmp_a_SOURCES = \
-    getgateway.c \
-    natpmp.c \
-    wingettimeofday.c
-
-noinst_HEADERS = \
-    declspec.h \
-    getgateway.h \
-    natpmp.h \
-    wingettimeofday.h
-
-EXTRA_DIST = \
-    README \
-    LICENSE
diff --git a/third-party/libnatpmp/Makefile.in b/user/transmission/third-party/libnatpmp/Makefile.in
deleted file mode 100644
index 01560b9..0000000
--- a/third-party/libnatpmp/Makefile.in
+++ /dev/null
@@ -1,584 +0,0 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = third-party/libnatpmp
-DIST_COMMON = README $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/acx-pthread.m4 \
-	$(top_srcdir)/m4/check-ssl.m4 $(top_srcdir)/m4/glib-gettext.m4 \
-	$(top_srcdir)/m4/intltool.m4 $(top_srcdir)/m4/libtool.m4 \
-	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
-	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
-	$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/m4/zlib.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-ARFLAGS = cru
-AM_V_AR = $(am__v_AR_$(V))
-am__v_AR_ = $(am__v_AR_$(AM_DEFAULT_VERBOSITY))
-am__v_AR_0 = @echo "  AR    " $@;
-AM_V_at = $(am__v_at_$(V))
-am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
-am__v_at_0 = @
-libnatpmp_a_AR = $(AR) $(ARFLAGS)
-libnatpmp_a_LIBADD =
-am_libnatpmp_a_OBJECTS = getgateway.$(OBJEXT) natpmp.$(OBJEXT) \
-	wingettimeofday.$(OBJEXT)
-libnatpmp_a_OBJECTS = $(am_libnatpmp_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-AM_V_lt = $(am__v_lt_$(V))
-am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
-am__v_lt_0 = --silent
-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-AM_V_CC = $(am__v_CC_$(V))
-am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
-am__v_CC_0 = @echo "  CC    " $@;
-CCLD = $(CC)
-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CCLD = $(am__v_CCLD_$(V))
-am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_$(V))
-am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
-am__v_GEN_0 = @echo "  GEN   " $@;
-SOURCES = $(libnatpmp_a_SOURCES)
-DIST_SOURCES = $(libnatpmp_a_SOURCES)
-HEADERS = $(noinst_HEADERS)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-ALL_LINGUAS = @ALL_LINGUAS@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CANBERRA_MINIMUM = @CANBERRA_MINIMUM@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CURL_MINIMUM = @CURL_MINIMUM@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DBUS_BINDING_TOOL = @DBUS_BINDING_TOOL@
-DBUS_GLIB_CFLAGS = @DBUS_GLIB_CFLAGS@
-DBUS_GLIB_LIBS = @DBUS_GLIB_LIBS@
-DBUS_GLIB_MINIMUM = @DBUS_GLIB_MINIMUM@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DHT_CFLAGS = @DHT_CFLAGS@
-DHT_LIBS = @DHT_LIBS@
-DLLTOOL = @DLLTOOL@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GIO_CFLAGS = @GIO_CFLAGS@
-GIO_LIBS = @GIO_LIBS@
-GIO_MINIMUM = @GIO_MINIMUM@
-GLIB_MINIMUM = @GLIB_MINIMUM@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-GTK_CFLAGS = @GTK_CFLAGS@
-GTK_LIBS = @GTK_LIBS@
-GTK_MINIMUM = @GTK_MINIMUM@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
-INTLTOOL_MERGE = @INTLTOOL_MERGE@
-INTLTOOL_PERL = @INTLTOOL_PERL@
-INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBAPPINDICATOR_CFLAGS = @LIBAPPINDICATOR_CFLAGS@
-LIBAPPINDICATOR_LIBS = @LIBAPPINDICATOR_LIBS@
-LIBAPPINDICATOR_MINIMUM = @LIBAPPINDICATOR_MINIMUM@
-LIBCANBERRA_CFLAGS = @LIBCANBERRA_CFLAGS@
-LIBCANBERRA_LIBS = @LIBCANBERRA_LIBS@
-LIBCURL_CFLAGS = @LIBCURL_CFLAGS@
-LIBCURL_LIBS = @LIBCURL_LIBS@
-LIBEVENT_CFLAGS = @LIBEVENT_CFLAGS@
-LIBEVENT_LIBS = @LIBEVENT_LIBS@
-LIBEVENT_MINIUM = @LIBEVENT_MINIUM@
-LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
-LIBNOTIFY_LIBS = @LIBNOTIFY_LIBS@
-LIBNOTIFY_MINIMUM = @LIBNOTIFY_MINIMUM@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBUTP_CFLAGS = @LIBUTP_CFLAGS@
-LIBUTP_LIBS = @LIBUTP_LIBS@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MSGFMT = @MSGFMT@
-MSGMERGE = @MSGMERGE@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OPENSSL_CFLAGS = @OPENSSL_CFLAGS@
-OPENSSL_LIBS = @OPENSSL_LIBS@
-OPENSSL_MINIMUM = @OPENSSL_MINIMUM@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PEERID_PREFIX = @PEERID_PREFIX@
-PKG_CONFIG = @PKG_CONFIG@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-PTHREAD_CC = @PTHREAD_CC@
-PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
-PTHREAD_LIBS = @PTHREAD_LIBS@
-RANLIB = @RANLIB@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-USERAGENT_PREFIX = @USERAGENT_PREFIX@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WINDRES = @WINDRES@
-XGETTEXT = @XGETTEXT@
-ZLIB_CFLAGS = @ZLIB_CFLAGS@
-ZLIB_LDFLAGS = @ZLIB_LDFLAGS@
-ZLIB_LIBS = @ZLIB_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-acx_pthread_config = @acx_pthread_config@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-transmissionlocaledir = @transmissionlocaledir@
-noinst_LIBRARIES = libnatpmp.a
-AM_CFLAGS = @PTHREAD_CFLAGS@ -DENABLE_STRNATPMPERR
-libnatpmp_a_SOURCES = \
-    getgateway.c \
-    natpmp.c \
-    wingettimeofday.c
-
-noinst_HEADERS = \
-    declspec.h \
-    getgateway.h \
-    natpmp.h \
-    wingettimeofday.h
-
-EXTRA_DIST = \
-    README \
-    LICENSE
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu third-party/libnatpmp/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu third-party/libnatpmp/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-clean-noinstLIBRARIES:
-	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
-libnatpmp.a: $(libnatpmp_a_OBJECTS) $(libnatpmp_a_DEPENDENCIES) 
-	$(AM_V_at)-rm -f libnatpmp.a
-	$(AM_V_AR)$(libnatpmp_a_AR) libnatpmp.a $(libnatpmp_a_OBJECTS) $(libnatpmp_a_LIBADD)
-	$(AM_V_at)$(RANLIB) libnatpmp.a
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getgateway.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/natpmp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wingettimeofday.Po@am__quote@
-
-.c.o:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
-
-.c.obj:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	set x; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(LIBRARIES) $(HEADERS)
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstLIBRARIES ctags distclean \
-	distclean-compile distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
-	pdf pdf-am ps ps-am tags uninstall uninstall-am
-
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff --git a/third-party/libnatpmp/README b/user/transmission/third-party/libnatpmp/README
deleted file mode 100644
index 269392d..0000000
--- a/third-party/libnatpmp/README
+++ /dev/null
@@ -1,7 +0,0 @@
-libnatpmp (c) 2007-2009 Thomas Bernard
-contact : miniupnp@free.fr
-
-see http://miniupnp.free.fr/libnatpmp.html
-or http://miniupnp.tuxfamily.org/libnatpmp.html
-for some documentation and code samples.
-
diff --git a/third-party/libnatpmp/declspec.h b/user/transmission/third-party/libnatpmp/declspec.h
deleted file mode 100644
index ea479d1..0000000
--- a/third-party/libnatpmp/declspec.h
+++ /dev/null
@@ -1,15 +0,0 @@
-#ifndef __DECLSPEC_H__
-#define __DECLSPEC_H__
-
-#if defined(WIN32) && !defined(STATICLIB)
-	#ifdef NATPMP_EXPORTS
-		#define LIBSPEC __declspec(dllexport)
-	#else
-		#define LIBSPEC __declspec(dllimport)
-	#endif
-#else
-	#define LIBSPEC
-#endif
-
-#endif
-
diff --git a/third-party/libnatpmp/getgateway.c b/user/transmission/third-party/libnatpmp/getgateway.c
deleted file mode 100644
index bcde3ad..0000000
--- a/third-party/libnatpmp/getgateway.c
+++ /dev/null
@@ -1,554 +0,0 @@
-/* $Id: getgateway.c,v 1.19 2009/12/19 15:20:45 nanard Exp $ */
-/* libnatpmp
- * Copyright (c) 2007-2009, Thomas BERNARD <miniupnp@free.fr>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
-#include <stdio.h>
-#include <ctype.h>
-#ifndef WIN32
-#include <netinet/in.h>
-#endif
-#if !defined(_MSC_VER)
-#include <sys/param.h>
-#endif
-/* There is no portable method to get the default route gateway.
- * So below are four (or five ?) differents functions implementing this.
- * Parsing /proc/net/route is for linux.
- * sysctl is the way to access such informations on BSD systems.
- * Many systems should provide route information through raw PF_ROUTE
- * sockets.
- * In MS Windows, default gateway is found by looking into the registry
- * or by using GetBestRoute(). */
-#ifdef __linux__
-#define USE_PROC_NET_ROUTE
-#undef USE_SOCKET_ROUTE
-#undef USE_SYSCTL_NET_ROUTE
-#endif
-
-#ifdef BSD
-#undef USE_PROC_NET_ROUTE
-#define USE_SOCKET_ROUTE
-#undef USE_SYSCTL_NET_ROUTE
-#endif
-
-#ifdef __APPLE__
-#undef USE_PROC_NET_ROUTE
-#undef USE_SOCKET_ROUTE
-#define USE_SYSCTL_NET_ROUTE
-#endif
-
-#if (defined(sun) && defined(__SVR4))
-#undef USE_PROC_NET_ROUTE
-#define USE_SOCKET_ROUTE
-#undef USE_SYSCTL_NET_ROUTE
-#endif
-
-#ifdef WIN32
-#undef USE_PROC_NET_ROUTE
-#undef USE_SOCKET_ROUTE
-#undef USE_SYSCTL_NET_ROUTE
-//#define USE_WIN32_CODE
-#define USE_WIN32_CODE_2
-#endif
-
-#ifdef __CYGWIN__
-#undef USE_PROC_NET_ROUTE
-#undef USE_SOCKET_ROUTE
-#undef USE_SYSCTL_NET_ROUTE
-#define USE_WIN32_CODE
-#include <stdarg.h>
-#include <w32api/windef.h>
-#include <w32api/winbase.h>
-#include <w32api/winreg.h>
-#endif 
-
-#ifdef __HAIKU__
-#include <stdlib.h>
-#include <unistd.h>
-#include <net/if.h>
-#include <sys/sockio.h>
-#define USE_HAIKU_CODE
-#endif 
-
-#ifdef USE_SYSCTL_NET_ROUTE
-#include <stdlib.h>
-#include <sys/sysctl.h>
-#include <sys/socket.h>
-#include <net/route.h>
-#endif
-#ifdef USE_SOCKET_ROUTE
-#include <unistd.h>
-#include <string.h>
-#include <sys/socket.h>
-#include <net/if.h>
-#include <net/route.h>
-#endif
-
-#ifdef USE_WIN32_CODE
-#include <unknwn.h>
-#include <winreg.h>
-#define MAX_KEY_LENGTH 255
-#define MAX_VALUE_LENGTH 16383
-#endif
-
-#ifdef USE_WIN32_CODE_2
-#include <windows.h>
-#include <iphlpapi.h>
-#endif
-
-#include "getgateway.h"
-
-#ifndef WIN32
-#define SUCCESS (0)
-#define FAILED  (-1)
-#endif
-
-#ifdef USE_PROC_NET_ROUTE
-/*
- parse /proc/net/route which is as follow :
-
-Iface   Destination     Gateway         Flags   RefCnt  Use     Metric  Mask            MTU     Window  IRTT           
-wlan0   0001A8C0        00000000        0001    0       0       0       00FFFFFF        0       0       0              
-eth0    0000FEA9        00000000        0001    0       0       0       0000FFFF        0       0       0              
-wlan0   00000000        0101A8C0        0003    0       0       0       00000000        0       0       0              
-eth0    00000000        00000000        0001    0       0       1000    00000000        0       0       0              
-
- One header line, and then one line by route by route table entry.
-*/
-int getdefaultgateway(in_addr_t * addr)
-{
-	unsigned long d, g;
-	char buf[256];
-	int line = 0;
-	FILE * f;
-	char * p;
-	f = fopen("/proc/net/route", "r");
-	if(!f)
-		return FAILED;
-	while(fgets(buf, sizeof(buf), f)) {
-		if(line > 0) {	/* skip the first line */
-			p = buf;
-			/* skip the interface name */
-			while(*p && !isspace(*p))
-				p++;
-			while(*p && isspace(*p))
-				p++;
-			if(sscanf(p, "%lx%lx", &d, &g)==2) {
-				if(d == 0 && g != 0) { /* default */
-					*addr = g;
-					fclose(f);
-					return SUCCESS;
-				}
-			}
-		}
-		line++;
-	}
-	/* default route not found ! */
-	if(f)
-		fclose(f);
-	return FAILED;
-}
-#endif /* #ifdef USE_PROC_NET_ROUTE */
-
-
-#ifdef USE_SYSCTL_NET_ROUTE
-
-#define ROUNDUP(a) \
-	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
-
-int getdefaultgateway(in_addr_t * addr)
-{
-#if 0
-	/* net.route.0.inet.dump.0.0 ? */
-	int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET,
-	             NET_RT_DUMP, 0, 0/*tableid*/};
-#endif
-	/* net.route.0.inet.flags.gateway */
-	int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET,
-	             NET_RT_FLAGS, RTF_GATEWAY};
-	size_t l;
-	char * buf, * p;
-	struct rt_msghdr * rt;
-	struct sockaddr * sa;
-	struct sockaddr * sa_tab[RTAX_MAX];
-	int i;
-	int r = FAILED;
-	if(sysctl(mib, sizeof(mib)/sizeof(int), 0, &l, 0, 0) < 0) {
-		return FAILED;
-	}
-	if(l>0) {
-		buf = malloc(l);
-		if(sysctl(mib, sizeof(mib)/sizeof(int), buf, &l, 0, 0) < 0) {
-			free(buf);
-			return FAILED;
-		}
-		for(p=buf; p<buf+l; p+=rt->rtm_msglen) {
-			rt = (struct rt_msghdr *)p;
-			sa = (struct sockaddr *)(rt + 1);
-			for(i=0; i<RTAX_MAX; i++) {
-				if(rt->rtm_addrs & (1 << i)) {
-					sa_tab[i] = sa;
-					sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa->sa_len));
-				} else {
-					sa_tab[i] = NULL;
-				}
-			}
-			if( ((rt->rtm_addrs & (RTA_DST|RTA_GATEWAY)) == (RTA_DST|RTA_GATEWAY))
-              && sa_tab[RTAX_DST]->sa_family == AF_INET
-              && sa_tab[RTAX_GATEWAY]->sa_family == AF_INET) {
-				if(((struct sockaddr_in *)sa_tab[RTAX_DST])->sin_addr.s_addr == 0) {
-					*addr = ((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))->sin_addr.s_addr;
-					r = SUCCESS;
-				}
-			}
-		}
-		free(buf);
-	}
-	return r;
-}
-#endif /* #ifdef USE_SYSCTL_NET_ROUTE */
-
-
-#ifdef USE_SOCKET_ROUTE
-/* Thanks to Darren Kenny for this code */
-#define NEXTADDR(w, u) \
-        if (rtm_addrs & (w)) {\
-            l = sizeof(struct sockaddr); memmove(cp, &(u), l); cp += l;\
-        }
-
-#define rtm m_rtmsg.m_rtm
-
-struct {
-  struct rt_msghdr m_rtm;
-  char       m_space[512];
-} m_rtmsg;
-
-int getdefaultgateway(in_addr_t *addr)
-{
-  int s, seq, l, rtm_addrs, i;
-  pid_t pid;
-  struct sockaddr so_dst, so_mask;
-  char *cp = m_rtmsg.m_space; 
-  struct sockaddr *gate = NULL, *sa;
-  struct rt_msghdr *msg_hdr;
-
-  pid = getpid();
-  seq = 0;
-  rtm_addrs = RTA_DST | RTA_NETMASK;
-
-  memset(&so_dst, 0, sizeof(so_dst));
-  memset(&so_mask, 0, sizeof(so_mask));
-  memset(&rtm, 0, sizeof(struct rt_msghdr));
-
-  rtm.rtm_type = RTM_GET;
-  rtm.rtm_flags = RTF_UP | RTF_GATEWAY;
-  rtm.rtm_version = RTM_VERSION;
-  rtm.rtm_seq = ++seq;
-  rtm.rtm_addrs = rtm_addrs; 
-
-  so_dst.sa_family = AF_INET;
-  so_mask.sa_family = AF_INET;
-
-  NEXTADDR(RTA_DST, so_dst);
-  NEXTADDR(RTA_NETMASK, so_mask);
-
-  rtm.rtm_msglen = l = cp - (char *)&m_rtmsg;
-
-  s = socket(PF_ROUTE, SOCK_RAW, 0);
-
-  if (write(s, (char *)&m_rtmsg, l) < 0) {
-      close(s);
-      return FAILED;
-  }
-
-  do {
-    l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));
-  } while (l > 0 && (rtm.rtm_seq != seq || rtm.rtm_pid != pid));
-                        
-  close(s);
-
-  msg_hdr = &rtm;
-
-  cp = ((char *)(msg_hdr + 1));
-  if (msg_hdr->rtm_addrs) {
-    for (i = 1; i; i <<= 1)
-      if (i & msg_hdr->rtm_addrs) {
-        sa = (struct sockaddr *)cp;
-        if (i == RTA_GATEWAY )
-          gate = sa;
-
-        cp += sizeof(struct sockaddr);
-      }
-  } else {
-      return FAILED;
-  }
-
-
-  if (gate != NULL ) {
-      *addr = ((struct sockaddr_in *)gate)->sin_addr.s_addr;
-      return SUCCESS;
-  } else {
-      return FAILED;
-  }
-}
-#endif /* #ifdef USE_SOCKET_ROUTE */
-
-#ifdef USE_WIN32_CODE
-LIBSPEC int getdefaultgateway(in_addr_t * addr)
-{
-	HKEY networkCardsKey;
-	HKEY networkCardKey;
-	HKEY interfacesKey;
-	HKEY interfaceKey;
-	DWORD i = 0;
-	DWORD numSubKeys = 0;
-	TCHAR keyName[MAX_KEY_LENGTH];
-	DWORD keyNameLength = MAX_KEY_LENGTH;
-	TCHAR keyValue[MAX_VALUE_LENGTH];
-	DWORD keyValueLength = MAX_VALUE_LENGTH;
-	DWORD keyValueType = REG_SZ;
-	TCHAR gatewayValue[MAX_VALUE_LENGTH];
-	DWORD gatewayValueLength = MAX_VALUE_LENGTH;
-	DWORD gatewayValueType = REG_MULTI_SZ;
-	int done = 0;
-	
-	//const char * networkCardsPath = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
-	//const char * interfacesPath = "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces";
-#ifdef UNICODE
-	LPCTSTR networkCardsPath = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
-	LPCTSTR interfacesPath = L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces";
-#define STR_SERVICENAME	 L"ServiceName"
-#define STR_DHCPDEFAULTGATEWAY L"DhcpDefaultGateway"
-#define STR_DEFAULTGATEWAY	L"DefaultGateway"
-#else
-	LPCTSTR networkCardsPath = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
-	LPCTSTR interfacesPath = "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces";
-#define STR_SERVICENAME	 "ServiceName"
-#define STR_DHCPDEFAULTGATEWAY "DhcpDefaultGateway"
-#define STR_DEFAULTGATEWAY	"DefaultGateway"
-#endif
-	// The windows registry lists its primary network devices in the following location:
-	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards
-	// 
-	// Each network device has its own subfolder, named with an index, with various properties:
-	// -NetworkCards
-	//   -5
-	//     -Description = Broadcom 802.11n Network Adapter
-	//     -ServiceName = {E35A72F8-5065-4097-8DFE-C7790774EE4D}
-	//   -8
-	//     -Description = Marvell Yukon 88E8058 PCI-E Gigabit Ethernet Controller
-	//     -ServiceName = {86226414-5545-4335-A9D1-5BD7120119AD}
-	// 
-	// The above service name is the name of a subfolder within:
-	// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces
-	// 
-	// There may be more subfolders in this interfaces path than listed in the network cards path above:
-	// -Interfaces
-	//   -{3a539854-6a70-11db-887c-806e6f6e6963}
-	//     -DhcpIPAddress = 0.0.0.0
-	//     -[more]
-	//   -{E35A72F8-5065-4097-8DFE-C7790774EE4D}
-	//     -DhcpIPAddress = 10.0.1.4
-	//     -DhcpDefaultGateway = 10.0.1.1
-	//     -[more]
-	//   -{86226414-5545-4335-A9D1-5BD7120119AD}
-	//     -DhcpIpAddress = 10.0.1.5
-	//     -DhcpDefaultGateay = 10.0.1.1
-	//     -[more]
-	// 
-	// In order to extract this information, we enumerate each network card, and extract the ServiceName value.
-	// This is then used to open the interface subfolder, and attempt to extract a DhcpDefaultGateway value.
-	// Once one is found, we're done.
-	// 
-	// It may be possible to simply enumerate the interface folders until we find one with a DhcpDefaultGateway value.
-	// However, the technique used is the technique most cited on the web, and we assume it to be more correct.
-	
-	if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predifined key 
-	                                 networkCardsPath,   // Name of registry subkey to open
-	                                 0,                  // Reserved - must be zero
-	                                 KEY_READ,           // Mask - desired access rights
-	                                 &networkCardsKey))  // Pointer to output key
-	{
-		// Unable to open network cards keys
-		return -1;
-	}
-	
-	if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predefined key
-	                                 interfacesPath,     // Name of registry subkey to open
-	                                 0,                  // Reserved - must be zero
-	                                 KEY_READ,           // Mask - desired access rights
-	                                 &interfacesKey))    // Pointer to output key
-	{
-		// Unable to open interfaces key
-		RegCloseKey(networkCardsKey);
-		return -1;
-	}
-	
-	// Figure out how many subfolders are within the NetworkCards folder
-	RegQueryInfoKey(networkCardsKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
-	
-	//printf( "Number of subkeys: %u\n", (unsigned int)numSubKeys);
-	
-	// Enumrate through each subfolder within the NetworkCards folder
-	for(i = 0; i < numSubKeys && !done; i++)
-	{
-		keyNameLength = MAX_KEY_LENGTH;
-		if(ERROR_SUCCESS == RegEnumKeyEx(networkCardsKey, // Open registry key
-		                                 i,               // Index of subkey to retrieve
-		                                 keyName,         // Buffer that receives the name of the subkey
-		                                 &keyNameLength,  // Variable that receives the size of the above buffer
-		                                 NULL,            // Reserved - must be NULL
-		                                 NULL,            // Buffer that receives the class string
-		                                 NULL,            // Variable that receives the size of the above buffer
-		                                 NULL))           // Variable that receives the last write time of subkey
-		{
-			if(RegOpenKeyEx(networkCardsKey,  keyName, 0, KEY_READ, &networkCardKey) == ERROR_SUCCESS)
-			{
-				keyValueLength = MAX_VALUE_LENGTH;
-				if(ERROR_SUCCESS == RegQueryValueEx(networkCardKey,   // Open registry key
-				                                    STR_SERVICENAME,    // Name of key to query
-				                                    NULL,             // Reserved - must be NULL
-				                                    &keyValueType,    // Receives value type
-				                                    (LPBYTE)keyValue, // Receives value
-				                                    &keyValueLength)) // Receives value length in bytes
-				{
-//					printf("keyValue: %s\n", keyValue);				
-					if(RegOpenKeyEx(interfacesKey, keyValue, 0, KEY_READ, &interfaceKey) == ERROR_SUCCESS)
-					{
-						gatewayValueLength = MAX_VALUE_LENGTH;
-						if(ERROR_SUCCESS == RegQueryValueEx(interfaceKey,         // Open registry key
-						                                    STR_DHCPDEFAULTGATEWAY, // Name of key to query
-						                                    NULL,                 // Reserved - must be NULL
-						                                    &gatewayValueType,    // Receives value type
-						                                    (LPBYTE)gatewayValue, // Receives value
-						                                    &gatewayValueLength)) // Receives value length in bytes
-						{
-							// Check to make sure it's a string
-							if((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1))
-							{
-								//printf("gatewayValue: %s\n", gatewayValue);
-								done = 1;
-							}
-						}
-						else if(ERROR_SUCCESS == RegQueryValueEx(interfaceKey,         // Open registry key
-						                                    STR_DEFAULTGATEWAY, // Name of key to query
-						                                    NULL,                 // Reserved - must be NULL
-						                                    &gatewayValueType,    // Receives value type
-						                                    (LPBYTE)gatewayValue,// Receives value
-						                                    &gatewayValueLength)) // Receives value length in bytes
-						{
-							// Check to make sure it's a string
-							if((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1))
-							{
-								//printf("gatewayValue: %s\n", gatewayValue);
-								done = 1;
-							}
-						}
-						RegCloseKey(interfaceKey);
-					}
-				}
-				RegCloseKey(networkCardKey);
-			}
-		}
-	}
-	
-	RegCloseKey(interfacesKey);
-	RegCloseKey(networkCardsKey);
-	
-	if(done)
-	{
-#if UNICODE
-		char tmp[32];
-		for(i = 0; i < 32; i++) {
-			tmp[i] = (char)gatewayValue[i];
-			if(!tmp[i])
-				break;
-		}
-		tmp[31] = '\0';
-		*addr = inet_addr(tmp);
-#else
-		*addr = inet_addr(gatewayValue);
-#endif
-		return 0;
-	}
-	
-	return -1;
-}
-#endif /* #ifdef USE_WIN32_CODE */
-
-#ifdef USE_WIN32_CODE_2
-int getdefaultgateway(in_addr_t *addr)
-{
-	MIB_IPFORWARDROW ip_forward;
-	memset(&ip_forward, 0, sizeof(ip_forward));
-	if(GetBestRoute(inet_addr("0.0.0.0"), 0, &ip_forward) != NO_ERROR)
-		return -1;
-	*addr = ip_forward.dwForwardNextHop;
-	return 0;
-}
-#endif /* #ifdef USE_WIN32_CODE_2 */
-
-#ifdef USE_HAIKU_CODE
-int getdefaultgateway(in_addr_t *addr)
-{
-    int fd, ret = -1;
-    struct ifconf config;
-    void *buffer = NULL;
-    struct ifreq *interface;
-
-    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-        return -1;
-    }
-    if (ioctl(fd, SIOCGRTSIZE, &config, sizeof(config)) != 0) {
-        goto fail;
-    }
-    if (config.ifc_value < 1) {
-        goto fail; /* No routes */
-    }
-    if ((buffer = malloc(config.ifc_value)) == NULL) {
-        goto fail;
-    }
-    config.ifc_len = config.ifc_value;
-    config.ifc_buf = buffer;
-    if (ioctl(fd, SIOCGRTTABLE, &config, sizeof(config)) != 0) {
-        goto fail;
-    }
-    for (interface = buffer;
-      (uint8_t *)interface < (uint8_t *)buffer + config.ifc_len; ) {
-        struct route_entry route = interface->ifr_route;
-        int intfSize;
-        if (route.flags & (RTF_GATEWAY | RTF_DEFAULT)) {
-            *addr = ((struct sockaddr_in *)route.gateway)->sin_addr.s_addr;
-            ret = 0;
-            break;
-        }
-        intfSize = sizeof(route) + IF_NAMESIZE;
-        if (route.destination != NULL) {
-            intfSize += route.destination->sa_len;
-        }
-        if (route.mask != NULL) {
-            intfSize += route.mask->sa_len;
-        }
-        if (route.gateway != NULL) {
-            intfSize += route.gateway->sa_len;
-        }
-        interface = (struct ifreq *)((uint8_t *)interface + intfSize);
-    }
-fail:
-    free(buffer);
-    close(fd);
-    return ret;
-}
-#endif /* #ifdef USE_HAIKU_CODE */
-
-
diff --git a/third-party/libnatpmp/getgateway.h b/user/transmission/third-party/libnatpmp/getgateway.h
deleted file mode 100644
index 9432528..0000000
--- a/third-party/libnatpmp/getgateway.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* $Id: getgateway.h,v 1.4 2009/12/19 12:00:00 nanard Exp $ */
-/* libnatpmp
- * Copyright (c) 2007, Thomas BERNARD <miniupnp@free.fr>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
-#ifndef __GETGATEWAY_H__
-#define __GETGATEWAY_H__
-
-#ifdef WIN32
-#if !defined(_MSC_VER)
-#include <stdint.h>
-#else
-typedef unsigned long uint32_t;
-typedef unsigned short uint16_t;
-#endif
-#define in_addr_t uint32_t
-#endif
-#include "declspec.h"
-
-/* getdefaultgateway() :
- * return value :
- *    0 : success
- *   -1 : failure    */
-LIBSPEC int getdefaultgateway(in_addr_t * addr);
-
-#endif
diff --git a/third-party/libnatpmp/natpmp.c b/user/transmission/third-party/libnatpmp/natpmp.c
deleted file mode 100644
index 055ba4f..0000000
--- a/third-party/libnatpmp/natpmp.c
+++ /dev/null
@@ -1,346 +0,0 @@
-/* $Id: natpmp.c,v 1.12 2009/12/19 14:10:09 nanard Exp $ */
-/* libnatpmp
- * Copyright (c) 2007-2009, Thomas BERNARD <miniupnp@free.fr>
- * http://miniupnp.free.fr/libnatpmp.html
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
-#ifdef __linux__
-#define _BSD_SOURCE 1
-#endif
-#include <string.h>
-#include <time.h>
-#if !defined(_MSC_VER)
-#include <sys/time.h>
-#endif
-#ifdef WIN32
-#include <errno.h>
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#include <io.h>
-#define EWOULDBLOCK WSAEWOULDBLOCK
-#define ECONNREFUSED WSAECONNREFUSED
-#include "wingettimeofday.h"
-#else
-#include <errno.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#define closesocket close
-#endif
-#include "natpmp.h"
-#include "getgateway.h"
-
-LIBSPEC int initnatpmp(natpmp_t * p)
-{
-#ifdef WIN32
-	u_long ioctlArg = 1;
-#else
-	int flags; 
-#endif
-	struct sockaddr_in addr;
-	if(!p)
-		return NATPMP_ERR_INVALIDARGS;
-	memset(p, 0, sizeof(natpmp_t));
-	p->s = socket(PF_INET, SOCK_DGRAM, 0);
-	if(p->s < 0)
-		return NATPMP_ERR_SOCKETERROR;
-#ifdef WIN32
-	if(ioctlsocket(p->s, FIONBIO, &ioctlArg) == SOCKET_ERROR)
-		return NATPMP_ERR_FCNTLERROR;
-#else
-	if((flags = fcntl(p->s, F_GETFL, 0)) < 0)
-		return NATPMP_ERR_FCNTLERROR;
-	if(fcntl(p->s, F_SETFL, flags | O_NONBLOCK) < 0)
-		return NATPMP_ERR_FCNTLERROR;
-#endif
-
-	if(getdefaultgateway(&(p->gateway)) < 0)
-		return NATPMP_ERR_CANNOTGETGATEWAY;
-	
-	memset(&addr, 0, sizeof(addr));
-	addr.sin_family = AF_INET;
-	addr.sin_port = htons(NATPMP_PORT);
-	addr.sin_addr.s_addr = p->gateway;
-	if(connect(p->s, (struct sockaddr *)&addr, sizeof(addr)) < 0)
-		return NATPMP_ERR_CONNECTERR;
-	return 0;
-}
-
-LIBSPEC int closenatpmp(natpmp_t * p)
-{
-	if(!p)
-		return NATPMP_ERR_INVALIDARGS;
-	if(closesocket(p->s) < 0)
-		return NATPMP_ERR_CLOSEERR;
-	return 0;
-}
-
-int sendpendingrequest(natpmp_t * p)
-{
-	int r;
-/*	struct sockaddr_in addr;*/
-	if(!p)
-		return NATPMP_ERR_INVALIDARGS;
-/*	memset(&addr, 0, sizeof(addr));
-	addr.sin_family = AF_INET;
-	addr.sin_port = htons(NATPMP_PORT);
-	addr.sin_addr.s_addr = p->gateway;
-	r = (int)sendto(p->s, p->pending_request, p->pending_request_len, 0,
-	                   (struct sockaddr *)&addr, sizeof(addr));*/
-	r = (int)send(p->s, p->pending_request, p->pending_request_len, 0);
-	return (r<0) ? NATPMP_ERR_SENDERR : r;
-}
-
-int sendnatpmprequest(natpmp_t * p)
-{
-	int n;
-	if(!p)
-		return NATPMP_ERR_INVALIDARGS;
-	/* TODO : check if no request is allready pending */
-	p->has_pending_request = 1;
-	p->try_number = 1;
-	n = sendpendingrequest(p);
-	gettimeofday(&p->retry_time, NULL);	// check errors !
-	p->retry_time.tv_usec += 250000;	/* add 250ms */
-	if(p->retry_time.tv_usec >= 1000000) {
-		p->retry_time.tv_usec -= 1000000;
-		p->retry_time.tv_sec++;
-	}
-	return n;
-}
-
-LIBSPEC int getnatpmprequesttimeout(natpmp_t * p, struct timeval * timeout)
-{
-	struct timeval now;
-	if(!p || !timeout)
-		return NATPMP_ERR_INVALIDARGS;
-	if(!p->has_pending_request)
-		return NATPMP_ERR_NOPENDINGREQ;
-	if(gettimeofday(&now, NULL) < 0)
-		return NATPMP_ERR_GETTIMEOFDAYERR;
-	timeout->tv_sec = p->retry_time.tv_sec - now.tv_sec;
-	timeout->tv_usec = p->retry_time.tv_usec - now.tv_usec;
-	if(timeout->tv_usec < 0) {
-		timeout->tv_usec += 1000000;
-		timeout->tv_sec--;
-	}
-	return 0;
-}
-
-LIBSPEC int sendpublicaddressrequest(natpmp_t * p)
-{
-	if(!p)
-		return NATPMP_ERR_INVALIDARGS;
-	//static const unsigned char request[] = { 0, 0 };
-	p->pending_request[0] = 0;
-	p->pending_request[1] = 0;
-	p->pending_request_len = 2;
-	// TODO: return 0 instead of sizeof(request) ??
-	return sendnatpmprequest(p);
-}
-
-LIBSPEC int sendnewportmappingrequest(natpmp_t * p, int protocol,
-                              uint16_t privateport, uint16_t publicport,
-							  uint32_t lifetime)
-{
-	if(!p || (protocol!=NATPMP_PROTOCOL_TCP && protocol!=NATPMP_PROTOCOL_UDP))
-		return NATPMP_ERR_INVALIDARGS;
-	p->pending_request[0] = 0;
-	p->pending_request[1] = protocol;
-	p->pending_request[2] = 0;
-	p->pending_request[3] = 0;
-	*((uint16_t *)(p->pending_request + 4)) = htons(privateport);
-	*((uint16_t *)(p->pending_request + 6)) = htons(publicport);
-	*((uint32_t *)(p->pending_request + 8)) = htonl(lifetime);
-	p->pending_request_len = 12;
-	return sendnatpmprequest(p);
-}
-
-LIBSPEC int readnatpmpresponse(natpmp_t * p, natpmpresp_t * response)
-{
-	unsigned char buf[16];
-	struct sockaddr_in addr;
-	socklen_t addrlen = sizeof(addr);
-	int n;
-	if(!p)
-		return NATPMP_ERR_INVALIDARGS;
-	n = recvfrom(p->s, buf, sizeof(buf), 0,
-	             (struct sockaddr *)&addr, &addrlen);
-	if(n<0)
-		switch(errno) {
-		/*case EAGAIN:*/
-		case EWOULDBLOCK:
-			n = NATPMP_TRYAGAIN;
-			break;
-		case ECONNREFUSED:
-			n = NATPMP_ERR_NOGATEWAYSUPPORT;
-			break;
-		default:
-			n = NATPMP_ERR_RECVFROM;
-		}
-	/* check that addr is correct (= gateway) */
-	else if(addr.sin_addr.s_addr != p->gateway)
-		n = NATPMP_ERR_WRONGPACKETSOURCE;
-	else {
-		response->resultcode = ntohs(*((uint16_t *)(buf + 2)));
-		response->epoch = ntohl(*((uint32_t *)(buf + 4)));
-		if(buf[0] != 0)
-			n = NATPMP_ERR_UNSUPPORTEDVERSION;
-		else if(buf[1] < 128 || buf[1] > 130)
-			n = NATPMP_ERR_UNSUPPORTEDOPCODE;
-		else if(response->resultcode != 0) {
-			switch(response->resultcode) {
-			case 1:
-				n = NATPMP_ERR_UNSUPPORTEDVERSION;
-				break;
-			case 2:
-				n = NATPMP_ERR_NOTAUTHORIZED;
-				break;
-			case 3:
-				n = NATPMP_ERR_NETWORKFAILURE;
-				break;
-			case 4:
-				n = NATPMP_ERR_OUTOFRESOURCES;
-				break;
-			case 5:
-				n = NATPMP_ERR_UNSUPPORTEDOPCODE;
-				break;
-			default:
-				n = NATPMP_ERR_UNDEFINEDERROR;
-			}
-		} else {
-			response->type = buf[1] & 0x7f;
-			if(buf[1] == 128)
-				//response->publicaddress.addr = *((uint32_t *)(buf + 8));
-				response->pnu.publicaddress.addr.s_addr = *((uint32_t *)(buf + 8));
-			else {
-				response->pnu.newportmapping.privateport = ntohs(*((uint16_t *)(buf + 8)));
-				response->pnu.newportmapping.mappedpublicport = ntohs(*((uint16_t *)(buf + 10)));
-				response->pnu.newportmapping.lifetime = ntohl(*((uint32_t *)(buf + 12)));
-			}
-			n = 0;
-		}
-	}
-	return n;
-}
-
-int readnatpmpresponseorretry(natpmp_t * p, natpmpresp_t * response)
-{
-	int n;
-	if(!p || !response)
-		return NATPMP_ERR_INVALIDARGS;
-	if(!p->has_pending_request)
-		return NATPMP_ERR_NOPENDINGREQ;
-	n = readnatpmpresponse(p, response);
-	if(n<0) {
-		if(n==NATPMP_TRYAGAIN) {
-			struct timeval now;
-			gettimeofday(&now, NULL);	// check errors !
-			if(timercmp(&now, &p->retry_time, >=)) {
-				int delay, r;
-				if(p->try_number >= 9) {
-					return NATPMP_ERR_NOGATEWAYSUPPORT;
-				}
-				/*printf("retry! %d\n", p->try_number);*/
-				delay = 250 * (1<<p->try_number);	// ms
-				/*for(i=0; i<p->try_number; i++)
-					delay += delay;*/
-				p->retry_time.tv_sec += (delay / 1000);
-				p->retry_time.tv_usec += (delay % 1000) * 1000;
-				if(p->retry_time.tv_usec >= 1000000) {
-					p->retry_time.tv_usec -= 1000000;
-					p->retry_time.tv_sec++;
-				}
-				p->try_number++;
-				r = sendpendingrequest(p);
-				if(r<0)
-					return r;
-			}
-		}
-	} else {
-		p->has_pending_request = 0;
-	}
-	return n;
-}
-
-#ifdef ENABLE_STRNATPMPERR
-LIBSPEC const char * strnatpmperr(int r)
-{
-	const char * s;
-	switch(r) {
-	case NATPMP_ERR_INVALIDARGS:
-		s = "invalid arguments";
-		break;
-	case NATPMP_ERR_SOCKETERROR:
-		s = "socket() failed";
-		break;
-	case NATPMP_ERR_CANNOTGETGATEWAY:
-		s = "cannot get default gateway ip address";
-		break;
-	case NATPMP_ERR_CLOSEERR:
-#ifdef WIN32
-		s = "closesocket() failed";
-#else
-		s = "close() failed";
-#endif
-		break;
-	case NATPMP_ERR_RECVFROM:
-		s = "recvfrom() failed";
-		break;
-	case NATPMP_ERR_NOPENDINGREQ:
-		s = "no pending request";
-		break;
-	case NATPMP_ERR_NOGATEWAYSUPPORT:
-		s = "the gateway does not support nat-pmp";
-		break;
-	case NATPMP_ERR_CONNECTERR:
-		s = "connect() failed";
-		break;
-	case NATPMP_ERR_WRONGPACKETSOURCE:
-		s = "packet not received from the default gateway";
-		break;
-	case NATPMP_ERR_SENDERR:
-		s = "send() failed";
-		break;
-	case NATPMP_ERR_FCNTLERROR:
-		s = "fcntl() failed";
-		break;
-	case NATPMP_ERR_GETTIMEOFDAYERR:
-		s = "gettimeofday() failed";
-		break;
-	case NATPMP_ERR_UNSUPPORTEDVERSION:
-		s = "unsupported nat-pmp version error from server";
-		break;
-	case NATPMP_ERR_UNSUPPORTEDOPCODE:
-		s = "unsupported nat-pmp opcode error from server";
-		break;
-	case NATPMP_ERR_UNDEFINEDERROR:
-		s = "undefined nat-pmp server error";
-		break;
-	case NATPMP_ERR_NOTAUTHORIZED:
-		s = "not authorized";
-		break;
-	case NATPMP_ERR_NETWORKFAILURE:
-		s = "network failure";
-		break;
-	case NATPMP_ERR_OUTOFRESOURCES:
-		s = "nat-pmp server out of resources";
-		break;
-	default:
-		s = "Unknown libnatpmp error";
-	}
-	return s;
-}
-#endif
-
diff --git a/third-party/libnatpmp/natpmp.h b/user/transmission/third-party/libnatpmp/natpmp.h
deleted file mode 100644
index d4c513e..0000000
--- a/third-party/libnatpmp/natpmp.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/* $Id: natpmp.h,v 1.12 2009/12/19 12:00:00 nanard Exp $ */
-/* libnatpmp
- * Copyright (c) 2007-2008, Thomas BERNARD <miniupnp@free.fr>
- * http://miniupnp.free.fr/libnatpmp.html
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
-#ifndef __NATPMP_H__
-#define __NATPMP_H__
-
-/* NAT-PMP Port as defined by the NAT-PMP draft */
-#define NATPMP_PORT (5351)
-
-#include <time.h>
-#if !defined(_MSC_VER)
-#include <sys/time.h>
-#endif
-#ifdef WIN32
-#include <winsock2.h>
-#if !defined(_MSC_VER)
-#include <stdint.h>
-#else
-typedef unsigned long uint32_t;
-typedef unsigned short uint16_t;
-#endif
-#define in_addr_t uint32_t
-#include "declspec.h"
-#else
-#define LIBSPEC
-#include <netinet/in.h>
-#endif
-
-typedef struct {
-	int s;	/* socket */
-	in_addr_t gateway;	/* default gateway (IPv4) */
-	int has_pending_request;
-	unsigned char pending_request[12];
-	int pending_request_len;
-	int try_number;
-	struct timeval retry_time;
-} natpmp_t;
-
-typedef struct {
-	uint16_t type;	/* NATPMP_RESPTYPE_* */
-	uint16_t resultcode;	/* NAT-PMP response code */
-	uint32_t epoch;	/* Seconds since start of epoch */
-	union {
-		struct {
-			//in_addr_t addr;
-			struct in_addr addr;
-		} publicaddress;
-		struct {
-			uint16_t privateport;
-			uint16_t mappedpublicport;
-			uint32_t lifetime;
-		} newportmapping;
-	} pnu;
-} natpmpresp_t;
-
-/* possible values for type field of natpmpresp_t */
-#define NATPMP_RESPTYPE_PUBLICADDRESS (0)
-#define NATPMP_RESPTYPE_UDPPORTMAPPING (1)
-#define NATPMP_RESPTYPE_TCPPORTMAPPING (2)
-
-/* Values to pass to sendnewportmappingrequest() */
-#define NATPMP_PROTOCOL_UDP (1)
-#define NATPMP_PROTOCOL_TCP (2)
-
-/* return values */
-/* NATPMP_ERR_INVALIDARGS : invalid arguments passed to the function */
-#define NATPMP_ERR_INVALIDARGS (-1)
-/* NATPMP_ERR_SOCKETERROR : socket() failed. check errno for details */
-#define NATPMP_ERR_SOCKETERROR (-2)
-/* NATPMP_ERR_CANNOTGETGATEWAY : can't get default gateway IP */
-#define NATPMP_ERR_CANNOTGETGATEWAY (-3)
-/* NATPMP_ERR_CLOSEERR : close() failed. check errno for details */
-#define NATPMP_ERR_CLOSEERR (-4)
-/* NATPMP_ERR_RECVFROM : recvfrom() failed. check errno for details */
-#define NATPMP_ERR_RECVFROM (-5)
-/* NATPMP_ERR_NOPENDINGREQ : readnatpmpresponseorretry() called while
- * no NAT-PMP request was pending */
-#define NATPMP_ERR_NOPENDINGREQ (-6)
-/* NATPMP_ERR_NOGATEWAYSUPPORT : the gateway does not support NAT-PMP */
-#define NATPMP_ERR_NOGATEWAYSUPPORT (-7)
-/* NATPMP_ERR_CONNECTERR : connect() failed. check errno for details */
-#define NATPMP_ERR_CONNECTERR (-8)
-/* NATPMP_ERR_WRONGPACKETSOURCE : packet not received from the network gateway */
-#define NATPMP_ERR_WRONGPACKETSOURCE (-9)
-/* NATPMP_ERR_SENDERR : send() failed. check errno for details */
-#define NATPMP_ERR_SENDERR (-10)
-/* NATPMP_ERR_FCNTLERROR : fcntl() failed. check errno for details */
-#define NATPMP_ERR_FCNTLERROR (-11)
-/* NATPMP_ERR_GETTIMEOFDAYERR : gettimeofday() failed. check errno for details */
-#define NATPMP_ERR_GETTIMEOFDAYERR (-12)
-
-/* */
-#define NATPMP_ERR_UNSUPPORTEDVERSION (-14)
-#define NATPMP_ERR_UNSUPPORTEDOPCODE (-15)
-
-/* Errors from the server : */
-#define NATPMP_ERR_UNDEFINEDERROR (-49)
-#define NATPMP_ERR_NOTAUTHORIZED (-51)
-#define NATPMP_ERR_NETWORKFAILURE (-52)
-#define NATPMP_ERR_OUTOFRESOURCES (-53)
-
-/* NATPMP_TRYAGAIN : no data available for the moment. try again later */
-#define NATPMP_TRYAGAIN (-100)
-
-/* initnatpmp()
- * initialize a natpmp_t object
- * Return values :
- * 0 = OK
- * NATPMP_ERR_INVALIDARGS
- * NATPMP_ERR_SOCKETERROR
- * NATPMP_ERR_FCNTLERROR
- * NATPMP_ERR_CANNOTGETGATEWAY
- * NATPMP_ERR_CONNECTERR */
-LIBSPEC int initnatpmp(natpmp_t * p);
-
-/* closenatpmp()
- * close resources associated with a natpmp_t object
- * Return values :
- * 0 = OK
- * NATPMP_ERR_INVALIDARGS
- * NATPMP_ERR_CLOSEERR */
-LIBSPEC int closenatpmp(natpmp_t * p);
-
-/* sendpublicaddressrequest()
- * send a public address NAT-PMP request to the network gateway
- * Return values :
- * 2 = OK (size of the request)
- * NATPMP_ERR_INVALIDARGS
- * NATPMP_ERR_SENDERR */
-LIBSPEC int sendpublicaddressrequest(natpmp_t * p);
-
-/* sendnewportmappingrequest()
- * send a new port mapping NAT-PMP request to the network gateway
- * Arguments :
- * protocol is either NATPMP_PROTOCOL_TCP or NATPMP_PROTOCOL_UDP,
- * lifetime is in seconds.
- * To remove a port mapping, set lifetime to zero.
- * To remove all port mappings to the host, set lifetime and both ports
- * to zero.
- * Return values :
- * 12 = OK (size of the request)
- * NATPMP_ERR_INVALIDARGS
- * NATPMP_ERR_SENDERR */
-LIBSPEC int sendnewportmappingrequest(natpmp_t * p, int protocol,
-                              uint16_t privateport, uint16_t publicport,
-							  uint32_t lifetime);
-
-/* getnatpmprequesttimeout()
- * fills the timeval structure with the timeout duration of the
- * currently pending NAT-PMP request.
- * Return values :
- * 0 = OK
- * NATPMP_ERR_INVALIDARGS
- * NATPMP_ERR_GETTIMEOFDAYERR
- * NATPMP_ERR_NOPENDINGREQ */
-LIBSPEC int getnatpmprequesttimeout(natpmp_t * p, struct timeval * timeout);
-
-/* readnatpmpresponseorretry()
- * fills the natpmpresp_t structure if possible
- * Return values :
- * 0 = OK
- * NATPMP_TRYAGAIN
- * NATPMP_ERR_INVALIDARGS
- * NATPMP_ERR_NOPENDINGREQ
- * NATPMP_ERR_NOGATEWAYSUPPORT
- * NATPMP_ERR_RECVFROM
- * NATPMP_ERR_WRONGPACKETSOURCE
- * NATPMP_ERR_UNSUPPORTEDVERSION
- * NATPMP_ERR_UNSUPPORTEDOPCODE
- * NATPMP_ERR_NOTAUTHORIZED
- * NATPMP_ERR_NETWORKFAILURE
- * NATPMP_ERR_OUTOFRESOURCES
- * NATPMP_ERR_UNSUPPORTEDOPCODE
- * NATPMP_ERR_UNDEFINEDERROR */
-LIBSPEC int readnatpmpresponseorretry(natpmp_t * p, natpmpresp_t * response);
-
-#ifdef ENABLE_STRNATPMPERR
-LIBSPEC const char * strnatpmperr(int t);
-#endif
-
-#endif
diff --git a/third-party/libnatpmp/wingettimeofday.c b/user/transmission/third-party/libnatpmp/wingettimeofday.c
deleted file mode 100644
index 5b1b8a6..0000000
--- a/third-party/libnatpmp/wingettimeofday.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/* $Id: wingettimeofday.c,v 1.3 2009/12/19 12:00:00 nanard Exp $ */
-/* libnatpmp
- * Copyright (c) 2007-2008, Thomas BERNARD <miniupnp@free.fr>
- * http://miniupnp.free.fr/libnatpmp.html
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
-#ifdef WIN32
-#if defined(_MSC_VER)
-struct timeval {
-	long    tv_sec;
-	long    tv_usec;
-};
-#else
-#include <sys/time.h>
-#endif
-
-typedef struct _FILETIME {
-    unsigned long dwLowDateTime;
-    unsigned long dwHighDateTime;
-} FILETIME;
-
-void __stdcall GetSystemTimeAsFileTime(FILETIME*);
-  
-//int gettimeofday(struct timeval* p, void* tz /* IGNORED */);
-
-int gettimeofday(struct timeval* p, void* tz /* IGNORED */) {
-  union {
-   long long ns100; /*time since 1 Jan 1601 in 100ns units */
-   FILETIME ft;
-  } _now;
-
-	if(!p)
-		return -1;
-  GetSystemTimeAsFileTime( &(_now.ft) );
-  p->tv_usec =(long)((_now.ns100 / 10LL) % 1000000LL );
-  p->tv_sec = (long)((_now.ns100-(116444736000000000LL))/10000000LL);
-  return 0;
-}
-#endif
-
diff --git a/third-party/libnatpmp/wingettimeofday.h b/user/transmission/third-party/libnatpmp/wingettimeofday.h
deleted file mode 100644
index ed6c599..0000000
--- a/third-party/libnatpmp/wingettimeofday.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/* $Id: wingettimeofday.h,v 1.1 2009/12/19 12:02:42 nanard Exp $ */
-/* libnatpmp
- * Copyright (c) 2007-2008, Thomas BERNARD <miniupnp@free.fr>
- * http://miniupnp.free.fr/libnatpmp.html
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
-#ifndef __WINGETTIMEOFDAY_H__
-#define __WINGETTIMEOFDAY_H__
-#ifdef WIN32
-#if defined(_MSC_VER)
-#include <time.h>
-#else
-#include <sys/time.h>
-#endif
-int gettimeofday(struct timeval* p, void* tz /* IGNORED */);
-#endif
-#endif
diff --git a/third-party/miniupnp/LICENSE b/user/transmission/third-party/miniupnp/LICENSE
deleted file mode 100644
index 2b561fb..0000000
--- a/third-party/miniupnp/LICENSE
+++ /dev/null
@@ -1,26 +0,0 @@
-Copyright (c) 2005-2009, Thomas BERNARD 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice,
-      this list of conditions and the following disclaimer in the documentation
-      and/or other materials provided with the distribution.
-    * The name of the author may not be used to endorse or promote products
-	  derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
diff --git a/third-party/miniupnp/Makefile.am b/user/transmission/third-party/miniupnp/Makefile.am
deleted file mode 100644
index 0cbdb06..0000000
--- a/third-party/miniupnp/Makefile.am
+++ /dev/null
@@ -1,42 +0,0 @@
-noinst_LIBRARIES = libminiupnp.a
-
-AM_CFLAGS = @PTHREAD_CFLAGS@ -DNDEBUG
-
-libminiupnp_a_SOURCES = \
-    connecthostport.c \
-    igd_desc_parse.c \
-    minisoap.c \
-    minissdpc.c \
-    miniupnpc.c \
-    miniwget.c \
-    minixml.c \
-    upnpcommands.c \
-    upnpreplyparse.c
-
-noinst_HEADERS = \
-    bsdqueue.h \
-    codelength.h \
-    connecthostport.h \
-    declspec.h \
-    igd_desc_parse.h \
-    minisoap.h \
-    minissdpc.h \
-    miniupnpc.h \
-    miniwget.h \
-    minixml.h \
-    upnpcommands.h \
-    upnpreplyparse.h
-
-EXTRA_DIST = \
-    README \
-    LICENSE \
-    miniupnpcstrings.h.in \
-    updateminiupnpcstrings.sh
-
-BUILT_SOURCES = \
-    miniupnpcstrings.h
-
-miniupnpcstrings.h: Makefile
-	$(srcdir)/updateminiupnpcstrings.sh $(srcdir)/miniupnpcstrings.h.in $@
-
-DISTCLEANFILES = $(builddir)/miniupnpcstrings.h
diff --git a/third-party/miniupnp/Makefile.in b/user/transmission/third-party/miniupnp/Makefile.in
deleted file mode 100644
index 8668b2a..0000000
--- a/third-party/miniupnp/Makefile.in
+++ /dev/null
@@ -1,621 +0,0 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = third-party/miniupnp
-DIST_COMMON = README $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/acx-pthread.m4 \
-	$(top_srcdir)/m4/check-ssl.m4 $(top_srcdir)/m4/glib-gettext.m4 \
-	$(top_srcdir)/m4/intltool.m4 $(top_srcdir)/m4/libtool.m4 \
-	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
-	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
-	$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/m4/zlib.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-ARFLAGS = cru
-AM_V_AR = $(am__v_AR_$(V))
-am__v_AR_ = $(am__v_AR_$(AM_DEFAULT_VERBOSITY))
-am__v_AR_0 = @echo "  AR    " $@;
-AM_V_at = $(am__v_at_$(V))
-am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
-am__v_at_0 = @
-libminiupnp_a_AR = $(AR) $(ARFLAGS)
-libminiupnp_a_LIBADD =
-am_libminiupnp_a_OBJECTS = connecthostport.$(OBJEXT) \
-	igd_desc_parse.$(OBJEXT) minisoap.$(OBJEXT) \
-	minissdpc.$(OBJEXT) miniupnpc.$(OBJEXT) miniwget.$(OBJEXT) \
-	minixml.$(OBJEXT) upnpcommands.$(OBJEXT) \
-	upnpreplyparse.$(OBJEXT)
-libminiupnp_a_OBJECTS = $(am_libminiupnp_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-AM_V_lt = $(am__v_lt_$(V))
-am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
-am__v_lt_0 = --silent
-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-AM_V_CC = $(am__v_CC_$(V))
-am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
-am__v_CC_0 = @echo "  CC    " $@;
-CCLD = $(CC)
-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CCLD = $(am__v_CCLD_$(V))
-am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
-am__v_CCLD_0 = @echo "  CCLD  " $@;
-AM_V_GEN = $(am__v_GEN_$(V))
-am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
-am__v_GEN_0 = @echo "  GEN   " $@;
-SOURCES = $(libminiupnp_a_SOURCES)
-DIST_SOURCES = $(libminiupnp_a_SOURCES)
-HEADERS = $(noinst_HEADERS)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-ALL_LINGUAS = @ALL_LINGUAS@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CANBERRA_MINIMUM = @CANBERRA_MINIMUM@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CURL_MINIMUM = @CURL_MINIMUM@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DBUS_BINDING_TOOL = @DBUS_BINDING_TOOL@
-DBUS_GLIB_CFLAGS = @DBUS_GLIB_CFLAGS@
-DBUS_GLIB_LIBS = @DBUS_GLIB_LIBS@
-DBUS_GLIB_MINIMUM = @DBUS_GLIB_MINIMUM@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DHT_CFLAGS = @DHT_CFLAGS@
-DHT_LIBS = @DHT_LIBS@
-DLLTOOL = @DLLTOOL@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GIO_CFLAGS = @GIO_CFLAGS@
-GIO_LIBS = @GIO_LIBS@
-GIO_MINIMUM = @GIO_MINIMUM@
-GLIB_MINIMUM = @GLIB_MINIMUM@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-GTK_CFLAGS = @GTK_CFLAGS@
-GTK_LIBS = @GTK_LIBS@
-GTK_MINIMUM = @GTK_MINIMUM@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
-INTLTOOL_MERGE = @INTLTOOL_MERGE@
-INTLTOOL_PERL = @INTLTOOL_PERL@
-INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBAPPINDICATOR_CFLAGS = @LIBAPPINDICATOR_CFLAGS@
-LIBAPPINDICATOR_LIBS = @LIBAPPINDICATOR_LIBS@
-LIBAPPINDICATOR_MINIMUM = @LIBAPPINDICATOR_MINIMUM@
-LIBCANBERRA_CFLAGS = @LIBCANBERRA_CFLAGS@
-LIBCANBERRA_LIBS = @LIBCANBERRA_LIBS@
-LIBCURL_CFLAGS = @LIBCURL_CFLAGS@
-LIBCURL_LIBS = @LIBCURL_LIBS@
-LIBEVENT_CFLAGS = @LIBEVENT_CFLAGS@
-LIBEVENT_LIBS = @LIBEVENT_LIBS@
-LIBEVENT_MINIUM = @LIBEVENT_MINIUM@
-LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
-LIBNOTIFY_LIBS = @LIBNOTIFY_LIBS@
-LIBNOTIFY_MINIMUM = @LIBNOTIFY_MINIMUM@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBUTP_CFLAGS = @LIBUTP_CFLAGS@
-LIBUTP_LIBS = @LIBUTP_LIBS@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MSGFMT = @MSGFMT@
-MSGMERGE = @MSGMERGE@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OPENSSL_CFLAGS = @OPENSSL_CFLAGS@
-OPENSSL_LIBS = @OPENSSL_LIBS@
-OPENSSL_MINIMUM = @OPENSSL_MINIMUM@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PEERID_PREFIX = @PEERID_PREFIX@
-PKG_CONFIG = @PKG_CONFIG@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-PTHREAD_CC = @PTHREAD_CC@
-PTHREAD_CFLAGS = @PTHREAD_CFLAGS@
-PTHREAD_LIBS = @PTHREAD_LIBS@
-RANLIB = @RANLIB@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-USERAGENT_PREFIX = @USERAGENT_PREFIX@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-WINDRES = @WINDRES@
-XGETTEXT = @XGETTEXT@
-ZLIB_CFLAGS = @ZLIB_CFLAGS@
-ZLIB_LDFLAGS = @ZLIB_LDFLAGS@
-ZLIB_LIBS = @ZLIB_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-acx_pthread_config = @acx_pthread_config@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-transmissionlocaledir = @transmissionlocaledir@
-noinst_LIBRARIES = libminiupnp.a
-AM_CFLAGS = @PTHREAD_CFLAGS@ -DNDEBUG
-libminiupnp_a_SOURCES = \
-    connecthostport.c \
-    igd_desc_parse.c \
-    minisoap.c \
-    minissdpc.c \
-    miniupnpc.c \
-    miniwget.c \
-    minixml.c \
-    upnpcommands.c \
-    upnpreplyparse.c
-
-noinst_HEADERS = \
-    bsdqueue.h \
-    codelength.h \
-    connecthostport.h \
-    declspec.h \
-    igd_desc_parse.h \
-    minisoap.h \
-    minissdpc.h \
-    miniupnpc.h \
-    miniwget.h \
-    minixml.h \
-    upnpcommands.h \
-    upnpreplyparse.h
-
-EXTRA_DIST = \
-    README \
-    LICENSE \
-    miniupnpcstrings.h.in \
-    updateminiupnpcstrings.sh
-
-BUILT_SOURCES = \
-    miniupnpcstrings.h
-
-DISTCLEANFILES = $(builddir)/miniupnpcstrings.h
-all: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu third-party/miniupnp/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu third-party/miniupnp/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-clean-noinstLIBRARIES:
-	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
-libminiupnp.a: $(libminiupnp_a_OBJECTS) $(libminiupnp_a_DEPENDENCIES) 
-	$(AM_V_at)-rm -f libminiupnp.a
-	$(AM_V_AR)$(libminiupnp_a_AR) libminiupnp.a $(libminiupnp_a_OBJECTS) $(libminiupnp_a_LIBADD)
-	$(AM_V_at)$(RANLIB) libminiupnp.a
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/connecthostport.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/igd_desc_parse.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minisoap.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minissdpc.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/miniupnpc.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/miniwget.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minixml.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/upnpcommands.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/upnpreplyparse.Po@am__quote@
-
-.c.o:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c $<
-
-.c.obj:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	set x; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) check-am
-all-am: Makefile $(LIBRARIES) $(HEADERS)
-installdirs:
-install: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: all check install install-am install-strip
-
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstLIBRARIES ctags distclean \
-	distclean-compile distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
-	pdf pdf-am ps ps-am tags uninstall uninstall-am
-
-
-miniupnpcstrings.h: Makefile
-	$(srcdir)/updateminiupnpcstrings.sh $(srcdir)/miniupnpcstrings.h.in $@
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff --git a/third-party/miniupnp/README b/user/transmission/third-party/miniupnp/README
deleted file mode 100644
index 4295070..0000000
--- a/third-party/miniupnp/README
+++ /dev/null
@@ -1,56 +0,0 @@
-Project: miniupnp
-Project web page: http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
-Author: Thomas Bernard
-Copyright (c) 2005-2009 Thomas Bernard
-This software is subject to the conditions detailed in the
-LICENSE file provided within this distribution.
-
-For the comfort of Win32 users, bsdqueue.h is included in the distribution.
-Its licence is included in the header of the file.
-bsdqueue.h is a copy of the sys/queue.h of an OpenBSD system.
-
-* miniupnp Client *
-
-To compile, simply run 'gmake' (could be 'make' on your system).
-Under win32, to compile with MinGW, type "mingw32make.bat".
-The compilation is known to work under linux, FreeBSD,
-OpenBSD, MacOS X, AmigaOS and cygwin.
-The official AmigaOS4.1 SDK was used for AmigaOS4 and GeekGadgets for AmigaOS3.
-
-To install the library and headers on the system use :
-> su
-> make install
-> exit
-
-alternatively, to install in a specific location, use :
-> INSTALLPREFIX=/usr/local make install
-
-upnpc.c is a sample client using the libminiupnpc.
-To use the libminiupnpc in your application, link it with
-libminiupnpc.a (or .so) and use the following functions found in miniupnpc.h,
-upnpcommands.h and miniwget.h :
-- upnpDiscover()
-- miniwget()
-- parserootdesc()
-- GetUPNPUrls()
-- UPNP_* (calling UPNP methods)
-
-Note : use #include <miniupnpc/miniupnpc.h> etc... for the includes
-and -lminiupnpc for the link
-
-Discovery process is speeded up when MiniSSDPd is running on the machine.
-
-* Python module *
-
-you can build a python module with 'make pythonmodule' 
-and install it with 'make installpythonmodule'.
-setup.py (and setupmingw32.py) are included in the distribution.
-
-
-Feel free to contact me if you have any problem :
-e-mail : miniupnp@free.fr
-
-If you are using libminiupnpc in your application, please
-send me an email !
-
-
diff --git a/third-party/miniupnp/bsdqueue.h b/user/transmission/third-party/miniupnp/bsdqueue.h
deleted file mode 100644
index 1fe0599..0000000
--- a/third-party/miniupnp/bsdqueue.h
+++ /dev/null
@@ -1,531 +0,0 @@
-/*	$OpenBSD: queue.h,v 1.31 2005/11/25 08:06:25 otto Exp $	*/
-/*	$NetBSD: queue.h,v 1.11 1996/05/16 05:17:14 mycroft Exp $	*/
-
-/*
- * Copyright (c) 1991, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)queue.h	8.5 (Berkeley) 8/20/94
- */
-
-#ifndef	_SYS_QUEUE_H_
-#define	_SYS_QUEUE_H_
-
-/*
- * This file defines five types of data structures: singly-linked lists, 
- * lists, simple queues, tail queues, and circular queues.
- *
- *
- * A singly-linked list is headed by a single forward pointer. The elements
- * are singly linked for minimum space and pointer manipulation overhead at
- * the expense of O(n) removal for arbitrary elements. New elements can be
- * added to the list after an existing element or at the head of the list.
- * Elements being removed from the head of the list should use the explicit
- * macro for this purpose for optimum efficiency. A singly-linked list may
- * only be traversed in the forward direction.  Singly-linked lists are ideal
- * for applications with large datasets and few or no removals or for
- * implementing a LIFO queue.
- *
- * A list is headed by a single forward pointer (or an array of forward
- * pointers for a hash table header). The elements are doubly linked
- * so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before
- * or after an existing element or at the head of the list. A list
- * may only be traversed in the forward direction.
- *
- * A simple queue is headed by a pair of pointers, one the head of the
- * list and the other to the tail of the list. The elements are singly
- * linked to save space, so elements can only be removed from the
- * head of the list. New elements can be added to the list before or after
- * an existing element, at the head of the list, or at the end of the
- * list. A simple queue may only be traversed in the forward direction.
- *
- * A tail queue is headed by a pair of pointers, one to the head of the
- * list and the other to the tail of the list. The elements are doubly
- * linked so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before or
- * after an existing element, at the head of the list, or at the end of
- * the list. A tail queue may be traversed in either direction.
- *
- * A circle queue is headed by a pair of pointers, one to the head of the
- * list and the other to the tail of the list. The elements are doubly
- * linked so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before or after
- * an existing element, at the head of the list, or at the end of the list.
- * A circle queue may be traversed in either direction, but has a more
- * complex end of list detection.
- *
- * For details on the use of these macros, see the queue(3) manual page.
- */
-
-#ifdef QUEUE_MACRO_DEBUG
-#define _Q_INVALIDATE(a) (a) = ((void *)-1)
-#else
-#define _Q_INVALIDATE(a)
-#endif
-
-/*
- * Singly-linked List definitions.
- */
-#define SLIST_HEAD(name, type)						\
-struct name {								\
-	struct type *slh_first;	/* first element */			\
-}
- 
-#define	SLIST_HEAD_INITIALIZER(head)					\
-	{ NULL }
-
-#ifdef SLIST_ENTRY
-#undef SLIST_ENTRY
-#endif
-
-#define SLIST_ENTRY(type)						\
-struct {								\
-	struct type *sle_next;	/* next element */			\
-}
- 
-/*
- * Singly-linked List access methods.
- */
-#define	SLIST_FIRST(head)	((head)->slh_first)
-#define	SLIST_END(head)		NULL
-#define	SLIST_EMPTY(head)	(SLIST_FIRST(head) == SLIST_END(head))
-#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
-
-#define	SLIST_FOREACH(var, head, field)					\
-	for((var) = SLIST_FIRST(head);					\
-	    (var) != SLIST_END(head);					\
-	    (var) = SLIST_NEXT(var, field))
-
-#define	SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
-	for ((varp) = &SLIST_FIRST((head));				\
-	    ((var) = *(varp)) != SLIST_END(head);			\
-	    (varp) = &SLIST_NEXT((var), field))
-
-/*
- * Singly-linked List functions.
- */
-#define	SLIST_INIT(head) {						\
-	SLIST_FIRST(head) = SLIST_END(head);				\
-}
-
-#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
-	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
-	(slistelm)->field.sle_next = (elm);				\
-} while (0)
-
-#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
-	(elm)->field.sle_next = (head)->slh_first;			\
-	(head)->slh_first = (elm);					\
-} while (0)
-
-#define	SLIST_REMOVE_NEXT(head, elm, field) do {			\
-	(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;	\
-} while (0)
-
-#define	SLIST_REMOVE_HEAD(head, field) do {				\
-	(head)->slh_first = (head)->slh_first->field.sle_next;		\
-} while (0)
-
-#define SLIST_REMOVE(head, elm, type, field) do {			\
-	if ((head)->slh_first == (elm)) {				\
-		SLIST_REMOVE_HEAD((head), field);			\
-	} else {							\
-		struct type *curelm = (head)->slh_first;		\
-									\
-		while (curelm->field.sle_next != (elm))			\
-			curelm = curelm->field.sle_next;		\
-		curelm->field.sle_next =				\
-		    curelm->field.sle_next->field.sle_next;		\
-		_Q_INVALIDATE((elm)->field.sle_next);			\
-	}								\
-} while (0)
-
-/*
- * List definitions.
- */
-#define LIST_HEAD(name, type)						\
-struct name {								\
-	struct type *lh_first;	/* first element */			\
-}
-
-#define LIST_HEAD_INITIALIZER(head)					\
-	{ NULL }
-
-#define LIST_ENTRY(type)						\
-struct {								\
-	struct type *le_next;	/* next element */			\
-	struct type **le_prev;	/* address of previous next element */	\
-}
-
-/*
- * List access methods
- */
-#define	LIST_FIRST(head)		((head)->lh_first)
-#define	LIST_END(head)			NULL
-#define	LIST_EMPTY(head)		(LIST_FIRST(head) == LIST_END(head))
-#define	LIST_NEXT(elm, field)		((elm)->field.le_next)
-
-#define LIST_FOREACH(var, head, field)					\
-	for((var) = LIST_FIRST(head);					\
-	    (var)!= LIST_END(head);					\
-	    (var) = LIST_NEXT(var, field))
-
-/*
- * List functions.
- */
-#define	LIST_INIT(head) do {						\
-	LIST_FIRST(head) = LIST_END(head);				\
-} while (0)
-
-#define LIST_INSERT_AFTER(listelm, elm, field) do {			\
-	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
-		(listelm)->field.le_next->field.le_prev =		\
-		    &(elm)->field.le_next;				\
-	(listelm)->field.le_next = (elm);				\
-	(elm)->field.le_prev = &(listelm)->field.le_next;		\
-} while (0)
-
-#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
-	(elm)->field.le_prev = (listelm)->field.le_prev;		\
-	(elm)->field.le_next = (listelm);				\
-	*(listelm)->field.le_prev = (elm);				\
-	(listelm)->field.le_prev = &(elm)->field.le_next;		\
-} while (0)
-
-#define LIST_INSERT_HEAD(head, elm, field) do {				\
-	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
-		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
-	(head)->lh_first = (elm);					\
-	(elm)->field.le_prev = &(head)->lh_first;			\
-} while (0)
-
-#define LIST_REMOVE(elm, field) do {					\
-	if ((elm)->field.le_next != NULL)				\
-		(elm)->field.le_next->field.le_prev =			\
-		    (elm)->field.le_prev;				\
-	*(elm)->field.le_prev = (elm)->field.le_next;			\
-	_Q_INVALIDATE((elm)->field.le_prev);				\
-	_Q_INVALIDATE((elm)->field.le_next);				\
-} while (0)
-
-#define LIST_REPLACE(elm, elm2, field) do {				\
-	if (((elm2)->field.le_next = (elm)->field.le_next) != NULL)	\
-		(elm2)->field.le_next->field.le_prev =			\
-		    &(elm2)->field.le_next;				\
-	(elm2)->field.le_prev = (elm)->field.le_prev;			\
-	*(elm2)->field.le_prev = (elm2);				\
-	_Q_INVALIDATE((elm)->field.le_prev);				\
-	_Q_INVALIDATE((elm)->field.le_next);				\
-} while (0)
-
-/*
- * Simple queue definitions.
- */
-#define SIMPLEQ_HEAD(name, type)					\
-struct name {								\
-	struct type *sqh_first;	/* first element */			\
-	struct type **sqh_last;	/* addr of last next element */		\
-}
-
-#define SIMPLEQ_HEAD_INITIALIZER(head)					\
-	{ NULL, &(head).sqh_first }
-
-#define SIMPLEQ_ENTRY(type)						\
-struct {								\
-	struct type *sqe_next;	/* next element */			\
-}
-
-/*
- * Simple queue access methods.
- */
-#define	SIMPLEQ_FIRST(head)	    ((head)->sqh_first)
-#define	SIMPLEQ_END(head)	    NULL
-#define	SIMPLEQ_EMPTY(head)	    (SIMPLEQ_FIRST(head) == SIMPLEQ_END(head))
-#define	SIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)
-
-#define SIMPLEQ_FOREACH(var, head, field)				\
-	for((var) = SIMPLEQ_FIRST(head);				\
-	    (var) != SIMPLEQ_END(head);					\
-	    (var) = SIMPLEQ_NEXT(var, field))
-
-/*
- * Simple queue functions.
- */
-#define	SIMPLEQ_INIT(head) do {						\
-	(head)->sqh_first = NULL;					\
-	(head)->sqh_last = &(head)->sqh_first;				\
-} while (0)
-
-#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
-	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
-		(head)->sqh_last = &(elm)->field.sqe_next;		\
-	(head)->sqh_first = (elm);					\
-} while (0)
-
-#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
-	(elm)->field.sqe_next = NULL;					\
-	*(head)->sqh_last = (elm);					\
-	(head)->sqh_last = &(elm)->field.sqe_next;			\
-} while (0)
-
-#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
-	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
-		(head)->sqh_last = &(elm)->field.sqe_next;		\
-	(listelm)->field.sqe_next = (elm);				\
-} while (0)
-
-#define SIMPLEQ_REMOVE_HEAD(head, field) do {			\
-	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
-		(head)->sqh_last = &(head)->sqh_first;			\
-} while (0)
-
-/*
- * Tail queue definitions.
- */
-#define TAILQ_HEAD(name, type)						\
-struct name {								\
-	struct type *tqh_first;	/* first element */			\
-	struct type **tqh_last;	/* addr of last next element */		\
-}
-
-#define TAILQ_HEAD_INITIALIZER(head)					\
-	{ NULL, &(head).tqh_first }
-
-#define TAILQ_ENTRY(type)						\
-struct {								\
-	struct type *tqe_next;	/* next element */			\
-	struct type **tqe_prev;	/* address of previous next element */	\
-}
-
-/* 
- * tail queue access methods 
- */
-#define	TAILQ_FIRST(head)		((head)->tqh_first)
-#define	TAILQ_END(head)			NULL
-#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
-#define TAILQ_LAST(head, headname)					\
-	(*(((struct headname *)((head)->tqh_last))->tqh_last))
-/* XXX */
-#define TAILQ_PREV(elm, headname, field)				\
-	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
-#define	TAILQ_EMPTY(head)						\
-	(TAILQ_FIRST(head) == TAILQ_END(head))
-
-#define TAILQ_FOREACH(var, head, field)					\
-	for((var) = TAILQ_FIRST(head);					\
-	    (var) != TAILQ_END(head);					\
-	    (var) = TAILQ_NEXT(var, field))
-
-#define TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
-	for((var) = TAILQ_LAST(head, headname);				\
-	    (var) != TAILQ_END(head);					\
-	    (var) = TAILQ_PREV(var, headname, field))
-
-/*
- * Tail queue functions.
- */
-#define	TAILQ_INIT(head) do {						\
-	(head)->tqh_first = NULL;					\
-	(head)->tqh_last = &(head)->tqh_first;				\
-} while (0)
-
-#define TAILQ_INSERT_HEAD(head, elm, field) do {			\
-	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
-		(head)->tqh_first->field.tqe_prev =			\
-		    &(elm)->field.tqe_next;				\
-	else								\
-		(head)->tqh_last = &(elm)->field.tqe_next;		\
-	(head)->tqh_first = (elm);					\
-	(elm)->field.tqe_prev = &(head)->tqh_first;			\
-} while (0)
-
-#define TAILQ_INSERT_TAIL(head, elm, field) do {			\
-	(elm)->field.tqe_next = NULL;					\
-	(elm)->field.tqe_prev = (head)->tqh_last;			\
-	*(head)->tqh_last = (elm);					\
-	(head)->tqh_last = &(elm)->field.tqe_next;			\
-} while (0)
-
-#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
-	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
-		(elm)->field.tqe_next->field.tqe_prev =			\
-		    &(elm)->field.tqe_next;				\
-	else								\
-		(head)->tqh_last = &(elm)->field.tqe_next;		\
-	(listelm)->field.tqe_next = (elm);				\
-	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
-} while (0)
-
-#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
-	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
-	(elm)->field.tqe_next = (listelm);				\
-	*(listelm)->field.tqe_prev = (elm);				\
-	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
-} while (0)
-
-#define TAILQ_REMOVE(head, elm, field) do {				\
-	if (((elm)->field.tqe_next) != NULL)				\
-		(elm)->field.tqe_next->field.tqe_prev =			\
-		    (elm)->field.tqe_prev;				\
-	else								\
-		(head)->tqh_last = (elm)->field.tqe_prev;		\
-	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
-	_Q_INVALIDATE((elm)->field.tqe_prev);				\
-	_Q_INVALIDATE((elm)->field.tqe_next);				\
-} while (0)
-
-#define TAILQ_REPLACE(head, elm, elm2, field) do {			\
-	if (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)	\
-		(elm2)->field.tqe_next->field.tqe_prev =		\
-		    &(elm2)->field.tqe_next;				\
-	else								\
-		(head)->tqh_last = &(elm2)->field.tqe_next;		\
-	(elm2)->field.tqe_prev = (elm)->field.tqe_prev;			\
-	*(elm2)->field.tqe_prev = (elm2);				\
-	_Q_INVALIDATE((elm)->field.tqe_prev);				\
-	_Q_INVALIDATE((elm)->field.tqe_next);				\
-} while (0)
-
-/*
- * Circular queue definitions.
- */
-#define CIRCLEQ_HEAD(name, type)					\
-struct name {								\
-	struct type *cqh_first;		/* first element */		\
-	struct type *cqh_last;		/* last element */		\
-}
-
-#define CIRCLEQ_HEAD_INITIALIZER(head)					\
-	{ CIRCLEQ_END(&head), CIRCLEQ_END(&head) }
-
-#define CIRCLEQ_ENTRY(type)						\
-struct {								\
-	struct type *cqe_next;		/* next element */		\
-	struct type *cqe_prev;		/* previous element */		\
-}
-
-/*
- * Circular queue access methods 
- */
-#define	CIRCLEQ_FIRST(head)		((head)->cqh_first)
-#define	CIRCLEQ_LAST(head)		((head)->cqh_last)
-#define	CIRCLEQ_END(head)		((void *)(head))
-#define	CIRCLEQ_NEXT(elm, field)	((elm)->field.cqe_next)
-#define	CIRCLEQ_PREV(elm, field)	((elm)->field.cqe_prev)
-#define	CIRCLEQ_EMPTY(head)						\
-	(CIRCLEQ_FIRST(head) == CIRCLEQ_END(head))
-
-#define CIRCLEQ_FOREACH(var, head, field)				\
-	for((var) = CIRCLEQ_FIRST(head);				\
-	    (var) != CIRCLEQ_END(head);					\
-	    (var) = CIRCLEQ_NEXT(var, field))
-
-#define CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
-	for((var) = CIRCLEQ_LAST(head);					\
-	    (var) != CIRCLEQ_END(head);					\
-	    (var) = CIRCLEQ_PREV(var, field))
-
-/*
- * Circular queue functions.
- */
-#define	CIRCLEQ_INIT(head) do {						\
-	(head)->cqh_first = CIRCLEQ_END(head);				\
-	(head)->cqh_last = CIRCLEQ_END(head);				\
-} while (0)
-
-#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
-	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
-	(elm)->field.cqe_prev = (listelm);				\
-	if ((listelm)->field.cqe_next == CIRCLEQ_END(head))		\
-		(head)->cqh_last = (elm);				\
-	else								\
-		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
-	(listelm)->field.cqe_next = (elm);				\
-} while (0)
-
-#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
-	(elm)->field.cqe_next = (listelm);				\
-	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
-	if ((listelm)->field.cqe_prev == CIRCLEQ_END(head))		\
-		(head)->cqh_first = (elm);				\
-	else								\
-		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
-	(listelm)->field.cqe_prev = (elm);				\
-} while (0)
-
-#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
-	(elm)->field.cqe_next = (head)->cqh_first;			\
-	(elm)->field.cqe_prev = CIRCLEQ_END(head);			\
-	if ((head)->cqh_last == CIRCLEQ_END(head))			\
-		(head)->cqh_last = (elm);				\
-	else								\
-		(head)->cqh_first->field.cqe_prev = (elm);		\
-	(head)->cqh_first = (elm);					\
-} while (0)
-
-#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
-	(elm)->field.cqe_next = CIRCLEQ_END(head);			\
-	(elm)->field.cqe_prev = (head)->cqh_last;			\
-	if ((head)->cqh_first == CIRCLEQ_END(head))			\
-		(head)->cqh_first = (elm);				\
-	else								\
-		(head)->cqh_last->field.cqe_next = (elm);		\
-	(head)->cqh_last = (elm);					\
-} while (0)
-
-#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
-	if ((elm)->field.cqe_next == CIRCLEQ_END(head))			\
-		(head)->cqh_last = (elm)->field.cqe_prev;		\
-	else								\
-		(elm)->field.cqe_next->field.cqe_prev =			\
-		    (elm)->field.cqe_prev;				\
-	if ((elm)->field.cqe_prev == CIRCLEQ_END(head))			\
-		(head)->cqh_first = (elm)->field.cqe_next;		\
-	else								\
-		(elm)->field.cqe_prev->field.cqe_next =			\
-		    (elm)->field.cqe_next;				\
-	_Q_INVALIDATE((elm)->field.cqe_prev);				\
-	_Q_INVALIDATE((elm)->field.cqe_next);				\
-} while (0)
-
-#define CIRCLEQ_REPLACE(head, elm, elm2, field) do {			\
-	if (((elm2)->field.cqe_next = (elm)->field.cqe_next) ==		\
-	    CIRCLEQ_END(head))						\
-		(head).cqh_last = (elm2);				\
-	else								\
-		(elm2)->field.cqe_next->field.cqe_prev = (elm2);	\
-	if (((elm2)->field.cqe_prev = (elm)->field.cqe_prev) ==		\
-	    CIRCLEQ_END(head))						\
-		(head).cqh_first = (elm2);				\
-	else								\
-		(elm2)->field.cqe_prev->field.cqe_next = (elm2);	\
-	_Q_INVALIDATE((elm)->field.cqe_prev);				\
-	_Q_INVALIDATE((elm)->field.cqe_next);				\
-} while (0)
-
-#endif	/* !_SYS_QUEUE_H_ */
diff --git a/third-party/miniupnp/codelength.h b/user/transmission/third-party/miniupnp/codelength.h
deleted file mode 100644
index f11e5e9..0000000
--- a/third-party/miniupnp/codelength.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* $Id: codelength.h,v 1.1 2008/10/06 22:04:06 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas BERNARD
- * copyright (c) 2005-2008 Thomas Bernard
- * This software is subjet to the conditions detailed in the
- * provided LICENCE file. */
-#ifndef __CODELENGTH_H__
-#define __CODELENGTH_H__
-
-/* Encode length by using 7bit per Byte :
- * Most significant bit of each byte specifies that the
- * following byte is part of the code */
-#define DECODELENGTH(n, p) n = 0; \
-                           do { n = (n << 7) | (*p & 0x7f); } \
-                           while(*(p++)&0x80);
-
-#define CODELENGTH(n, p) if(n>=268435456) *(p++) = (n >> 28) | 0x80; \
-                         if(n>=2097152) *(p++) = (n >> 21) | 0x80; \
-                         if(n>=16384) *(p++) = (n >> 14) | 0x80; \
-                         if(n>=128) *(p++) = (n >> 7) | 0x80; \
-                         *(p++) = n & 0x7f;
-
-#endif
-
diff --git a/third-party/miniupnp/connecthostport.c b/user/transmission/third-party/miniupnp/connecthostport.c
deleted file mode 100644
index 5e5da3a..0000000
--- a/third-party/miniupnp/connecthostport.c
+++ /dev/null
@@ -1,223 +0,0 @@
-/* $Id: connecthostport.c,v 1.3 2010/12/21 16:13:14 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas Bernard
- * Copyright (c) 2010 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution. */
-
-/* use getaddrinfo() or gethostbyname()
- * uncomment the following line in order to use gethostbyname() */
-#ifdef NO_GETADDRINFO
-#define USE_GETHOSTBYNAME
-#endif
-
-#include <string.h>
-#include <stdio.h>
-#ifdef WIN32
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#include <io.h>
-#define snprintf _snprintf
-#define herror
-#define socklen_t int
-#else /* #ifdef WIN32 */
-#include <unistd.h>
-#include <errno.h>
-#define closesocket close
-#include <netdb.h>
-/* defining MINIUPNPC_IGNORE_EINTR enable the ignore of interruptions
- * during the connect() call */
-#define MINIUPNPC_IGNORE_EINTR
-#ifndef USE_GETHOSTBYNAME
-#include <sys/types.h>
-#include <sys/socket.h>
-#endif /* #ifndef USE_GETHOSTBYNAME */
-#endif /* #else WIN32 */
-
-/* definition of PRINT_SOCKET_ERROR */
-#ifdef WIN32
-#define PRINT_SOCKET_ERROR(x)    printf("Socket error: %s, %d\n", x, WSAGetLastError());
-#else
-#define PRINT_SOCKET_ERROR(x) perror(x)
-#endif
-
-#if defined(__amigaos__) || defined(__amigaos4__)
-#define herror(A) printf("%s\n", A)
-#endif
-
-#include "connecthostport.h"
-
-/* connecthostport()
- * return a socket connected (TCP) to the host and port
- * or -1 in case of error */
-int connecthostport(const char * host, unsigned short port)
-{
-	int s, n;
-#ifdef USE_GETHOSTBYNAME
-	struct sockaddr_in dest;
-	struct hostent *hp;
-#else /* #ifdef USE_GETHOSTBYNAME */
-	char port_str[8];
-	struct addrinfo *ai, *p;
-	struct addrinfo hints;
-#endif /* #ifdef USE_GETHOSTBYNAME */
-#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT
-	struct timeval timeout;
-#endif /* #ifdef MINIUPNPC_SET_SOCKET_TIMEOUT */
-	
-#ifdef USE_GETHOSTBYNAME
-	hp = gethostbyname(host);
-	if(hp == NULL)
-	{
-		herror(host);
-		return -1;
-	}
-	memcpy(&dest.sin_addr, hp->h_addr, sizeof(dest.sin_addr));
-	memset(dest.sin_zero, 0, sizeof(dest.sin_zero));
-	s = socket(PF_INET, SOCK_STREAM, 0);
-	if(s < 0)
-	{
-		PRINT_SOCKET_ERROR("socket");
-		return -1;
-	}
-#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT
-	/* setting a 3 seconds timeout for the connect() call */
-	timeout.tv_sec = 3;
-	timeout.tv_usec = 0;
-	if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(struct timeval)) < 0)
-	{
-		PRINT_SOCKET_ERROR("setsockopt");
-	}
-	timeout.tv_sec = 3;
-	timeout.tv_usec = 0;
-	if(setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(struct timeval)) < 0)
-	{
-		PRINT_SOCKET_ERROR("setsockopt");
-	}
-#endif /* #ifdef MINIUPNPC_SET_SOCKET_TIMEOUT */
-	dest.sin_family = AF_INET;
-	dest.sin_port = htons(port);
-	n = connect(s, (struct sockaddr *)&dest, sizeof(struct sockaddr_in));
-#ifdef MINIUPNPC_IGNORE_EINTR
-	while(n < 0 && errno == EINTR)
-	{
-		socklen_t len;
-		fd_set wset;
-		int err;
-		FD_ZERO(&wset);
-		FD_SET(s, &wset);
-		if((n = select(s + 1, NULL, &wset, NULL, NULL)) == -1 && errno == EINTR)
-			continue;
-		/*len = 0;*/
-		/*n = getpeername(s, NULL, &len);*/
-		len = sizeof(err);
-		if(getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {
-			PRINT_SOCKET_ERROR("getsockopt");
-			closesocket(s);
-			return -1;
-		}
-		if(err != 0) {
-			errno = err;
-			n = -1;
-		}
-	}
-#endif /* #ifdef MINIUPNPC_IGNORE_EINTR */
-	if(n<0)
-	{
-		PRINT_SOCKET_ERROR("connect");
-		closesocket(s);
-		return -1;
-	}
-#else /* #ifdef USE_GETHOSTBYNAME */
-	/* use getaddrinfo() instead of gethostbyname() */
-	memset(&hints, 0, sizeof(hints));
-	/* hints.ai_flags = AI_ADDRCONFIG; */
-#ifdef AI_NUMERICSERV
-	hints.ai_flags = AI_NUMERICSERV;
-#endif
-	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_family = AF_UNSPEC; /* AF_INET, AF_INET6 or AF_UNSPEC */
-	/* hints.ai_protocol = IPPROTO_TCP; */
-	snprintf(port_str, sizeof(port_str), "%hu", port);
-	n = getaddrinfo(host, port_str, &hints, &ai);
-	if(n != 0)
-	{
-#ifdef WIN32
-		fprintf(stderr, "getaddrinfo() error : %d\n", n);
-#else
-		fprintf(stderr, "getaddrinfo() error : %s\n", gai_strerror(n));
-#endif
-		return -1;
-	}
-	s = -1;
-	for(p = ai; p; p = p->ai_next)
-	{
-		s = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
-		if(s < 0)
-			continue;
-#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT
-		/* setting a 3 seconds timeout for the connect() call */
-		timeout.tv_sec = 3;
-		timeout.tv_usec = 0;
-		if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(struct timeval)) < 0)
-		{
-			PRINT_SOCKET_ERROR("setsockopt");
-		}
-		timeout.tv_sec = 3;
-		timeout.tv_usec = 0;
-		if(setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(struct timeval)) < 0)
-		{
-			PRINT_SOCKET_ERROR("setsockopt");
-		}
-#endif /* #ifdef MINIUPNPC_SET_SOCKET_TIMEOUT */
-		n = connect(s, p->ai_addr, p->ai_addrlen);
-#ifdef MINIUPNPC_IGNORE_EINTR
-		while(n < 0 && errno == EINTR)
-		{
-			socklen_t len;
-			fd_set wset;
-			int err;
-			FD_ZERO(&wset);
-			FD_SET(s, &wset);
-			if((n = select(s + 1, NULL, &wset, NULL, NULL)) == -1 && errno == EINTR)
-				continue;
-			/*len = 0;*/
-			/*n = getpeername(s, NULL, &len);*/
-			len = sizeof(err);
-			if(getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {
-				PRINT_SOCKET_ERROR("getsockopt");
-				closesocket(s);
-				freeaddrinfo(ai);
-				return -1;
-			}
-			if(err != 0) {
-				errno = err;
-				n = -1;
-			}
-		}
-#endif /* #ifdef MINIUPNPC_IGNORE_EINTR */
-		if(n < 0)
-		{
-			closesocket(s);
-			continue;
-		}
-		else
-		{
-			break;
-		}
-	}
-	freeaddrinfo(ai);
-	if(s < 0)
-	{
-		PRINT_SOCKET_ERROR("socket");
-		return -1;
-	}
-	if(n < 0)
-	{
-		PRINT_SOCKET_ERROR("connect");
-		return -1;
-	}
-#endif /* #ifdef USE_GETHOSTBYNAME */
-	return s;
-}
-
diff --git a/third-party/miniupnp/connecthostport.h b/user/transmission/third-party/miniupnp/connecthostport.h
deleted file mode 100644
index 57e24eb..0000000
--- a/third-party/miniupnp/connecthostport.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* $Id: connecthostport.h,v 1.1 2010/04/04 23:21:03 nanard Exp $ */
-/* Project: miniupnp
- * http://miniupnp.free.fr/
- * Author: Thomas Bernard
- * Copyright (c) 2010 Thomas Bernard
- * This software is subjects to the conditions detailed
- * in the LICENCE file provided within this distribution */
-#ifndef __CONNECTHOSTPORT_H__
-#define __CONNECTHOSTPORT_H__
-
-/* connecthostport()
- * return a socket connected (TCP) to the host and port
- * or -1 in case of error */
-int connecthostport(const char * host, unsigned short port);
-
-#endif
-
diff --git a/third-party/miniupnp/declspec.h b/user/transmission/third-party/miniupnp/declspec.h
deleted file mode 100644
index b804247..0000000
--- a/third-party/miniupnp/declspec.h
+++ /dev/null
@@ -1,15 +0,0 @@
-#ifndef __DECLSPEC_H__
-#define __DECLSPEC_H__
-
-#if defined(WIN32) && !defined(STATICLIB)
-	#ifdef MINIUPNP_EXPORTS
-		#define LIBSPEC __declspec(dllexport)
-	#else
-		#define LIBSPEC __declspec(dllimport)
-	#endif
-#else
-	#define LIBSPEC
-#endif
-
-#endif
-
diff --git a/third-party/miniupnp/igd_desc_parse.c b/user/transmission/third-party/miniupnp/igd_desc_parse.c
deleted file mode 100644
index 8df6950..0000000
--- a/third-party/miniupnp/igd_desc_parse.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/* $Id: igd_desc_parse.c,v 1.11 2010/12/11 17:56:51 nanard Exp $ */
-/* Project : miniupnp
- * http://miniupnp.free.fr/
- * Author : Thomas Bernard
- * Copyright (c) 2005-2010 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution. */
-
-#include "igd_desc_parse.h"
-#include <stdio.h>
-#include <string.h>
-
-/* Start element handler :
- * update nesting level counter and copy element name */
-void IGDstartelt(void * d, const char * name, int l)
-{
-	struct IGDdatas * datas = (struct IGDdatas *)d;
-	memcpy( datas->cureltname, name, l);
-	datas->cureltname[l] = '\0';
-	datas->level++;
-	if( (l==7) && !memcmp(name, "service", l) ) {
-		datas->tmp.controlurl[0] = '\0';
-		datas->tmp.eventsuburl[0] = '\0';
-		datas->tmp.scpdurl[0] = '\0';
-		datas->tmp.servicetype[0] = '\0';
-	}
-}
-
-/* End element handler :
- * update nesting level counter and update parser state if
- * service element is parsed */
-void IGDendelt(void * d, const char * name, int l)
-{
-	struct IGDdatas * datas = (struct IGDdatas *)d;
-	datas->level--;
-	/*printf("endelt %2d %.*s\n", datas->level, l, name);*/
-	if( (l==7) && !memcmp(name, "service", l) )
-	{
-		/*
-		if( datas->state < 1
-			&& !strcmp(datas->servicetype,
-				//	"urn:schemas-upnp-org:service:WANIPConnection:1") )
-				"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1"))
-			datas->state ++;
-		*/
-		if(0==strcmp(datas->tmp.servicetype,
-				"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1")) {
-			memcpy(&datas->CIF, &datas->tmp, sizeof(struct IGDdatas_service));
-		} else if(0==strcmp(datas->tmp.servicetype,
-				"urn:schemas-upnp-org:service:WANIPConnection:1")
-				 || 0==strcmp(datas->tmp.servicetype,
-				"urn:schemas-upnp-org:service:WANPPPConnection:1") ) {
-			if(datas->first.servicetype[0] == '\0') {
-				memcpy(&datas->first, &datas->tmp, sizeof(struct IGDdatas_service));
-			} else {
-				memcpy(&datas->second, &datas->tmp, sizeof(struct IGDdatas_service));
-			}
-		}
-	}
-}
-
-/* Data handler :
- * copy data depending on the current element name and state */
-void IGDdata(void * d, const char * data, int l)
-{
-	struct IGDdatas * datas = (struct IGDdatas *)d;
-	char * dstmember = 0;
-	/*printf("%2d %s : %.*s\n",
-           datas->level, datas->cureltname, l, data);	*/
-	if( !strcmp(datas->cureltname, "URLBase") )
-		dstmember = datas->urlbase;
-	else if( !strcmp(datas->cureltname, "serviceType") )
-		dstmember = datas->tmp.servicetype;
-	else if( !strcmp(datas->cureltname, "controlURL") )
-		dstmember = datas->tmp.controlurl;
-	else if( !strcmp(datas->cureltname, "eventSubURL") )
-		dstmember = datas->tmp.eventsuburl;
-	else if( !strcmp(datas->cureltname, "SCPDURL") )
-		dstmember = datas->tmp.scpdurl;
-/*	else if( !strcmp(datas->cureltname, "deviceType") )
-		dstmember = datas->devicetype_tmp;*/
-	if(dstmember)
-	{
-		if(l>=MINIUPNPC_URL_MAXSIZE)
-			l = MINIUPNPC_URL_MAXSIZE-1;
-		memcpy(dstmember, data, l);
-		dstmember[l] = '\0';
-	}
-}
-
-void printIGD(struct IGDdatas * d)
-{
-	printf("urlbase = '%s'\n", d->urlbase);
-	printf("WAN Device (Common interface config) :\n");
-	/*printf(" deviceType = '%s'\n", d->CIF.devicetype);*/
-	printf(" serviceType = '%s'\n", d->CIF.servicetype);
-	printf(" controlURL = '%s'\n", d->CIF.controlurl);
-	printf(" eventSubURL = '%s'\n", d->CIF.eventsuburl);
-	printf(" SCPDURL = '%s'\n", d->CIF.scpdurl);
-	printf("primary WAN Connection Device (IP or PPP Connection):\n");
-	/*printf(" deviceType = '%s'\n", d->first.devicetype);*/
-	printf(" servicetype = '%s'\n", d->first.servicetype);
-	printf(" controlURL = '%s'\n", d->first.controlurl);
-	printf(" eventSubURL = '%s'\n", d->first.eventsuburl);
-	printf(" SCPDURL = '%s'\n", d->first.scpdurl);
-	printf("secondary WAN Connection Device (IP or PPP Connection):\n");
-	/*printf(" deviceType = '%s'\n", d->second.devicetype);*/
-	printf(" servicetype = '%s'\n", d->second.servicetype);
-	printf(" controlURL = '%s'\n", d->second.controlurl);
-	printf(" eventSubURL = '%s'\n", d->second.eventsuburl);
-	printf(" SCPDURL = '%s'\n", d->second.scpdurl);
-}
-
-
diff --git a/third-party/miniupnp/igd_desc_parse.h b/user/transmission/third-party/miniupnp/igd_desc_parse.h
deleted file mode 100644
index 40cca60..0000000
--- a/third-party/miniupnp/igd_desc_parse.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* $Id: igd_desc_parse.h,v 1.7 2010/04/05 20:36:59 nanard Exp $ */
-/* Project : miniupnp
- * http://miniupnp.free.fr/
- * Author : Thomas Bernard
- * Copyright (c) 2005-2010 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution.
- * */
-#ifndef __IGD_DESC_PARSE_H__
-#define __IGD_DESC_PARSE_H__
-
-/* Structure to store the result of the parsing of UPnP
- * descriptions of Internet Gateway Devices */
-#define MINIUPNPC_URL_MAXSIZE (128)
-struct IGDdatas_service {
-	char controlurl[MINIUPNPC_URL_MAXSIZE];
-	char eventsuburl[MINIUPNPC_URL_MAXSIZE];
-	char scpdurl[MINIUPNPC_URL_MAXSIZE];
-	char servicetype[MINIUPNPC_URL_MAXSIZE];
-	/*char devicetype[MINIUPNPC_URL_MAXSIZE];*/
-};
-
-struct IGDdatas {
-	char cureltname[MINIUPNPC_URL_MAXSIZE];
-	char urlbase[MINIUPNPC_URL_MAXSIZE];
-	int level;
-	/*int state;*/
-	/* "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1" */
-	struct IGDdatas_service CIF;
-	/* "urn:schemas-upnp-org:service:WANIPConnection:1"
-	 * "urn:schemas-upnp-org:service:WANPPPConnection:1" */
-	struct IGDdatas_service first;
-	/* if both WANIPConnection and WANPPPConnection are present */
-	struct IGDdatas_service second;
-	/* tmp */
-	struct IGDdatas_service tmp;
-};
-
-void IGDstartelt(void *, const char *, int);
-void IGDendelt(void *, const char *, int);
-void IGDdata(void *, const char *, int);
-void printIGD(struct IGDdatas *);
-
-#endif
-
diff --git a/third-party/miniupnp/minisoap.c b/user/transmission/third-party/miniupnp/minisoap.c
deleted file mode 100644
index a834c5e..0000000
--- a/third-party/miniupnp/minisoap.c
+++ /dev/null
@@ -1,120 +0,0 @@
-/* $Id: minisoap.c,v 1.20 2010/12/11 17:56:51 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas Bernard
- * Copyright (c) 2005-2009 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution.
- *
- * Minimal SOAP implementation for UPnP protocol.
- */
-#include <stdio.h>
-#include <string.h>
-#ifdef WIN32
-#include <io.h>
-#include <winsock2.h>
-#define snprintf _snprintf
-#else
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#endif
-#include "minisoap.h"
-#include "miniupnpcstrings.h"
-
-/* only for malloc */
-#include <stdlib.h>
-
-#ifdef WIN32
-#define PRINT_SOCKET_ERROR(x)    printf("Socket error: %s, %d\n", x, WSAGetLastError());
-#else
-#define PRINT_SOCKET_ERROR(x) perror(x)
-#endif
-
-/* httpWrite sends the headers and the body to the socket
- * and returns the number of bytes sent */
-static int
-httpWrite(int fd, const char * body, int bodysize,
-          const char * headers, int headerssize)
-{
-	int n = 0;
-	/*n = write(fd, headers, headerssize);*/
-	/*if(bodysize>0)
-		n += write(fd, body, bodysize);*/
-	/* Note : my old linksys router only took into account
-	 * soap request that are sent into only one packet */
-	char * p;
-	/* TODO: AVOID MALLOC */
-	p = malloc(headerssize+bodysize);
-	if(!p)
-	  return 0;
-	memcpy(p, headers, headerssize);
-	memcpy(p+headerssize, body, bodysize);
-	/*n = write(fd, p, headerssize+bodysize);*/
-	n = send(fd, p, headerssize+bodysize, 0);
-	if(n<0) {
-	  PRINT_SOCKET_ERROR("send");
-	}
-	/* disable send on the socket */
-	/* draytek routers dont seems to like that... */
-#if 0
-#ifdef WIN32
-	if(shutdown(fd, SD_SEND)<0) {
-#else
-	if(shutdown(fd, SHUT_WR)<0)	{ /*SD_SEND*/
-#endif
-		PRINT_SOCKET_ERROR("shutdown");
-	}
-#endif
-	free(p);
-	return n;
-}
-
-/* self explanatory  */
-int soapPostSubmit(int fd,
-                   const char * url,
-				   const char * host,
-				   unsigned short port,
-				   const char * action,
-				   const char * body,
-				   const char * httpversion)
-{
-	int bodysize;
-	char headerbuf[512];
-	int headerssize;
-	char portstr[8];
-	bodysize = (int)strlen(body);
-	/* We are not using keep-alive HTTP connections.
-	 * HTTP/1.1 needs the header Connection: close to do that.
-	 * This is the default with HTTP/1.0
-	 * Using HTTP/1.1 means we need to support chunked transfer-encoding :
-	 * When using HTTP/1.1, the router "BiPAC 7404VNOX" always use chunked
-	 * transfer encoding. */
-    /* Connection: Close is normally there only in HTTP/1.1 but who knows */
-	portstr[0] = '\0';
-	if(port != 80)
-		snprintf(portstr, sizeof(portstr), ":%hu", port);
-	headerssize = snprintf(headerbuf, sizeof(headerbuf),
-                       "POST %s HTTP/%s\r\n"
-	                   "Host: %s%s\r\n"
-					   "User-Agent: " OS_STRING ", UPnP/1.0, MiniUPnPc/" MINIUPNPC_VERSION_STRING "\r\n"
-	                   "Content-Length: %d\r\n"
-					   "Content-Type: text/xml\r\n"
-					   "SOAPAction: \"%s\"\r\n"
-					   "Connection: Close\r\n"
-					   "Cache-Control: no-cache\r\n"	/* ??? */
-					   "Pragma: no-cache\r\n"
-					   "\r\n",
-					   url, httpversion, host, portstr, bodysize, action);
-#ifdef DEBUG
-	/*printf("SOAP request : headersize=%d bodysize=%d\n",
-	       headerssize, bodysize);
-	*/
-	printf("SOAP request : POST %s HTTP/%s - Host: %s%s\n",
-	        url, httpversion, host, portstr);
-	printf("SOAPAction: \"%s\" - Content-Length: %d\n", action, bodysize);
-	/*printf("%s", headerbuf);*/
-#endif
-	return httpWrite(fd, body, bodysize, headerbuf, headerssize);
-}
-
-
diff --git a/third-party/miniupnp/minisoap.h b/user/transmission/third-party/miniupnp/minisoap.h
deleted file mode 100644
index 696725f..0000000
--- a/third-party/miniupnp/minisoap.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* $Id: minisoap.h,v 1.4 2010/04/12 20:39:41 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas Bernard
- * Copyright (c) 2005 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution. */
-#ifndef __MINISOAP_H__
-#define __MINISOAP_H__
-
-/*int httpWrite(int, const char *, int, const char *);*/
-int soapPostSubmit(int, const char *, const char *, unsigned short,
-		   const char *, const char *, const char *);
-
-#endif
-
diff --git a/third-party/miniupnp/minissdpc.c b/user/transmission/third-party/miniupnp/minissdpc.c
deleted file mode 100644
index e5e8528..0000000
--- a/third-party/miniupnp/minissdpc.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/* $Id: minissdpc.c,v 1.14 2010/11/25 09:57:25 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas BERNARD
- * copyright (c) 2005-2009 Thomas Bernard
- * This software is subjet to the conditions detailed in the
- * provided LICENCE file. */
-/*#include <syslog.h>*/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/types.h>
-#if defined(WIN32) || defined(__amigaos__) || defined(__amigaos4__)
-#ifdef WIN32
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#include <io.h>
-#include <winsock.h>
-#include <stdint.h>
-#endif
-#if defined(__amigaos__) || defined(__amigaos4__)
-#include <sys/socket.h>
-#endif
-#if defined(__amigaos__)
-#define uint16_t unsigned short
-#endif
-/* Hack */
-#define UNIX_PATH_LEN   108
-struct sockaddr_un {
-  uint16_t sun_family;
-  char     sun_path[UNIX_PATH_LEN];
-};
-#else
-#include <sys/socket.h>
-#include <sys/un.h>
-#endif
-
-#include "minissdpc.h"
-#include "miniupnpc.h"
-
-#include "codelength.h"
-
-struct UPNPDev *
-getDevicesFromMiniSSDPD(const char * devtype, const char * socketpath)
-{
-	struct UPNPDev * tmp;
-	struct UPNPDev * devlist = NULL;
-	unsigned char buffer[2048];
-	ssize_t n;
-	unsigned char * p;
-	unsigned char * url;
-	unsigned int i;
-	unsigned int urlsize, stsize, usnsize, l;
-	int s;
-	struct sockaddr_un addr;
-
-	s = socket(AF_UNIX, SOCK_STREAM, 0);
-	if(s < 0)
-	{
-		/*syslog(LOG_ERR, "socket(unix): %m");*/
-		perror("socket(unix)");
-		return NULL;
-	}
-	addr.sun_family = AF_UNIX;
-	strncpy(addr.sun_path, socketpath, sizeof(addr.sun_path));
-	/* TODO : check if we need to handle the EINTR */
-	if(connect(s, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) < 0)
-	{
-		/*syslog(LOG_WARNING, "connect(\"%s\"): %m", socketpath);*/
-		close(s);
-		return NULL;
-	}
-	stsize = strlen(devtype);
-	buffer[0] = 1; /* request type 1 : request devices/services by type */
-	p = buffer + 1;
-	l = stsize;	CODELENGTH(l, p);
-	if(p + stsize > buffer + sizeof(buffer))
-	{
-		/* devtype is too long ! */
-		close(s);
-		return NULL;
-	}
-	memcpy(p, devtype, stsize);
-	p += stsize;
-	if(write(s, buffer, p - buffer) < 0)
-	{
-		/*syslog(LOG_ERR, "write(): %m");*/
-		perror("minissdpc.c: write()");
-		close(s);
-		return NULL;
-	}
-	n = read(s, buffer, sizeof(buffer));
-	if(n<=0)
-	{
-		perror("minissdpc.c: read()");
-		close(s);
-		return NULL;
-	}
-	p = buffer + 1;
-	for(i = 0; i < buffer[0]; i++)
-	{
-		if(p+2>=buffer+sizeof(buffer))
-			break;
-		DECODELENGTH(urlsize, p);
-		if(p+urlsize+2>=buffer+sizeof(buffer))
-			break;
-		url = p;
-		p += urlsize;
-		DECODELENGTH(stsize, p);
-		if(p+stsize+2>=buffer+sizeof(buffer))
-			break;
-		tmp = (struct UPNPDev *)malloc(sizeof(struct UPNPDev)+urlsize+stsize);
-		tmp->pNext = devlist;
-		tmp->descURL = tmp->buffer;
-		tmp->st = tmp->buffer + 1 + urlsize;
-		memcpy(tmp->buffer, url, urlsize);
-		tmp->buffer[urlsize] = '\0';
-		memcpy(tmp->buffer + urlsize + 1, p, stsize);
-		p += stsize;
-		tmp->buffer[urlsize+1+stsize] = '\0';
-		devlist = tmp;
-		/* added for compatibility with recent versions of MiniSSDPd 
-		 * >= 2007/12/19 */
-		DECODELENGTH(usnsize, p);
-		p += usnsize;
-		if(p>buffer + sizeof(buffer))
-			break;
-	}
-	close(s);
-	return devlist;
-}
-
diff --git a/third-party/miniupnp/minissdpc.h b/user/transmission/third-party/miniupnp/minissdpc.h
deleted file mode 100644
index 25e91ce..0000000
--- a/third-party/miniupnp/minissdpc.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* $Id: minissdpc.h,v 1.1 2007/08/31 15:15:33 nanard Exp $ */
-/* Project: miniupnp
- * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * Author: Thomas Bernard
- * Copyright (c) 2005-2007 Thomas Bernard
- * This software is subjects to the conditions detailed
- * in the LICENCE file provided within this distribution */
-#ifndef __MINISSDPC_H__
-#define __MINISSDPC_H__
-
-struct UPNPDev *
-getDevicesFromMiniSSDPD(const char * devtype, const char * socketpath);
-
-#endif
-
diff --git a/third-party/miniupnp/miniupnpc.c b/user/transmission/third-party/miniupnp/miniupnpc.c
deleted file mode 100644
index d91591c..0000000
--- a/third-party/miniupnp/miniupnpc.c
+++ /dev/null
@@ -1,969 +0,0 @@
-/* $Id: miniupnpc.c,v 1.85 2010/12/21 16:13:14 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas BERNARD
- * copyright (c) 2005-2010 Thomas Bernard
- * This software is subjet to the conditions detailed in the
- * provided LICENSE file. */
-#define __EXTENSIONS__ 1
-#if !defined(MACOSX) && !defined(__sun)
-#if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__) && !defined(__NetBSD__)
-#ifndef __cplusplus
-#define _XOPEN_SOURCE 600
-#endif
-#endif
-#ifndef __BSD_VISIBLE
-#define __BSD_VISIBLE 1
-#endif
-#endif
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#ifdef WIN32
-/* Win32 Specific includes and defines */
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#include <io.h>
-#include <iphlpapi.h>
-#define snprintf _snprintf
-#if defined(_MSC_VER) && (_MSC_VER >= 1400)
-#define strncasecmp _memicmp
-#else /* defined(_MSC_VER) && (_MSC_VER >= 1400) */
-#define strncasecmp memicmp
-#endif /* defined(_MSC_VER) && (_MSC_VER >= 1400) */
-#define MAXHOSTNAMELEN 64
-#else /* #ifdef WIN32 */
-/* Standard POSIX includes */
-#include <unistd.h>
-#if defined(__amigaos__) && !defined(__amigaos4__)
-/* Amiga OS 3 specific stuff */
-#define socklen_t int
-#else
-#include <sys/select.h>
-#endif
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/param.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#if !defined(__amigaos__) && !defined(__amigaos4__)
-#include <poll.h>
-#endif
-#include <strings.h>
-#include <errno.h>
-#define closesocket close
-#define MINIUPNPC_IGNORE_EINTR
-#endif /* #else WIN32 */
-#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT
-#include <sys/time.h>
-#endif
-#if defined(__amigaos__) || defined(__amigaos4__)
-/* Amiga OS specific stuff */
-#define TIMEVAL struct timeval
-#endif
-
-#include "miniupnpc.h"
-#include "minissdpc.h"
-#include "miniwget.h"
-#include "minisoap.h"
-#include "minixml.h"
-#include "upnpcommands.h"
-#include "connecthostport.h"
-
-#ifdef WIN32
-#define PRINT_SOCKET_ERROR(x)    printf("Socket error: %s, %d\n", x, WSAGetLastError());
-#else
-#define PRINT_SOCKET_ERROR(x) perror(x)
-#endif
-
-#define SOAPPREFIX "s"
-#define SERVICEPREFIX "u"
-#define SERVICEPREFIX2 'u'
-
-/* root description parsing */
-LIBSPEC void parserootdesc(const char * buffer, int bufsize, struct IGDdatas * data)
-{
-	struct xmlparser parser;
-	/* xmlparser object */
-	parser.xmlstart = buffer;
-	parser.xmlsize = bufsize;
-	parser.data = data;
-	parser.starteltfunc = IGDstartelt;
-	parser.endeltfunc = IGDendelt;
-	parser.datafunc = IGDdata;
-	parser.attfunc = 0;
-	parsexml(&parser);
-#ifdef DEBUG
-	printIGD(data);
-#endif
-}
-
-#if 0
-/* getcontentlenfromline() : parse the Content-Length HTTP header line.
- * Content-length: nnn */
-static int getcontentlenfromline(const char * p, int n)
-{
-	static const char contlenstr[] = "content-length";
-	const char * p2 = contlenstr;
-	int a = 0;
-	while(*p2)
-	{
-		if(n==0)
-			return -1;
-		if(*p2 != *p && *p2 != (*p + 32))
-			return -1;
-		p++; p2++; n--;
-	}
-	if(n==0)
-		return -1;
-	if(*p != ':')
-		return -1;
-	p++; n--;
-	while(*p == ' ')
-	{
-		if(n==0)
-			return -1;
-		p++; n--;
-	}
-	while(*p >= '0' && *p <= '9')
-	{
-		if(n==0)
-			return -1;
-		a = (a * 10) + (*p - '0');
-		p++; n--;
-	}
-	return a;
-}
-
-/* getContentLengthAndHeaderLength()
- * retrieve header length and content length from an HTTP response
- * TODO : retrieve Transfer-Encoding: header value, in order to support
- *        HTTP/1.1, chunked transfer encoding must be supported. */
-static void
-getContentLengthAndHeaderLength(char * p, int n,
-                                int * contentlen, int * headerlen)
-{
-	char * line;
-	int linelen;
-	int r;
-	line = p;
-	while(line < p + n)
-	{
-		linelen = 0;
-		while(line[linelen] != '\r' && line[linelen] != '\r')
-		{
-			if(line+linelen >= p+n)
-				return;
-			linelen++;
-		}
-		r = getcontentlenfromline(line, linelen);
-		if(r>0)
-			*contentlen = r;
-		line = line + linelen + 2;
-		if(line[0] == '\r' && line[1] == '\n')
-		{
-			*headerlen = (line - p) + 2;
-			return;
-		}
-	}
-}
-#endif
-
-/* simpleUPnPcommand2 :
- * not so simple !
- * return values :
- *   0 - OK
- *  -1 - error */
-static int simpleUPnPcommand2(int s, const char * url, const char * service,
-		       const char * action, struct UPNParg * args,
-		       char * buffer, int * bufsize, const char * httpversion)
-{
-	char hostname[MAXHOSTNAMELEN+1];
-	unsigned short port = 0;
-	char * path;
-	char soapact[128];
-	char soapbody[2048];
-	char * buf;
-	/*int buffree;*/
-    int n;
-	/*int contentlen, headerlen;*/	/* for the response */
-
-	snprintf(soapact, sizeof(soapact), "%s#%s", service, action);
-	if(args==NULL)
-	{
-		/*soapbodylen = */snprintf(soapbody, sizeof(soapbody),
-						"<?xml version=\"1.0\"?>\r\n"
-	    	              "<" SOAPPREFIX ":Envelope "
-						  "xmlns:" SOAPPREFIX "=\"http://schemas.xmlsoap.org/soap/envelope/\" "
-						  SOAPPREFIX ":encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
-						  "<" SOAPPREFIX ":Body>"
-						  "<" SERVICEPREFIX ":%s xmlns:" SERVICEPREFIX "=\"%s\">"
-						  "</" SERVICEPREFIX ":%s>"
-						  "</" SOAPPREFIX ":Body></" SOAPPREFIX ":Envelope>"
-					 	  "\r\n", action, service, action);
-	}
-	else
-	{
-		char * p;
-		const char * pe, * pv;
-		int soapbodylen;
-		soapbodylen = snprintf(soapbody, sizeof(soapbody),
-						"<?xml version=\"1.0\"?>\r\n"
-	    	            "<" SOAPPREFIX ":Envelope "
-						"xmlns:" SOAPPREFIX "=\"http://schemas.xmlsoap.org/soap/envelope/\" "
-						SOAPPREFIX ":encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
-						"<" SOAPPREFIX ":Body>"
-						"<" SERVICEPREFIX ":%s xmlns:" SERVICEPREFIX "=\"%s\">",
-						action, service);
-		p = soapbody + soapbodylen;
-		while(args->elt)
-		{
-			/* check that we are never overflowing the string... */
-			if(soapbody + sizeof(soapbody) <= p + 100)
-			{
-				/* we keep a margin of at least 100 bytes */
-				*bufsize = 0;
-				return -1;
-			}
-			*(p++) = '<';
-			pe = args->elt;
-			while(*pe)
-				*(p++) = *(pe++);
-			*(p++) = '>';
-			if((pv = args->val))
-			{
-				while(*pv)
-					*(p++) = *(pv++);
-			}
-			*(p++) = '<';
-			*(p++) = '/';
-			pe = args->elt;
-			while(*pe)
-				*(p++) = *(pe++);
-			*(p++) = '>';
-			args++;
-		}
-		*(p++) = '<';
-		*(p++) = '/';
-		*(p++) = SERVICEPREFIX2;
-		*(p++) = ':';
-		pe = action;
-		while(*pe)
-			*(p++) = *(pe++);
-		strncpy(p, "></" SOAPPREFIX ":Body></" SOAPPREFIX ":Envelope>\r\n",
-		        soapbody + sizeof(soapbody) - p);
-	}
-	if(!parseURL(url, hostname, &port, &path)) return -1;
-	if(s<0)
-	{
-		s = connecthostport(hostname, port);
-		if(s < 0)
-		{
-			*bufsize = 0;
-			return -1;
-		}
-	}
-
-	n = soapPostSubmit(s, path, hostname, port, soapact, soapbody, httpversion);
-	if(n<=0) {
-#ifdef DEBUG
-		printf("Error sending SOAP request\n");
-#endif
-		closesocket(s);
-		return -1;
-	}
-
-#if 0
-	contentlen = -1;
-	headerlen = -1;
-	buf = buffer;
-	buffree = *bufsize;
-	*bufsize = 0;
-	while ((n = ReceiveData(s, buf, buffree, 5000)) > 0) {
-		buffree -= n;
-		buf += n;
-		*bufsize += n;
-		getContentLengthAndHeaderLength(buffer, *bufsize,
-		                                &contentlen, &headerlen);
-#ifdef DEBUG
-		printf("received n=%dbytes bufsize=%d ContLen=%d HeadLen=%d\n",
-		       n, *bufsize, contentlen, headerlen);
-#endif
-		/* break if we received everything */
-		if(contentlen > 0 && headerlen > 0 && *bufsize >= contentlen+headerlen)
-			break;
-	}
-#endif
-	buf = getHTTPResponse(s, &n);
-	if(n > 0 && buf)
-	{
-#ifdef DEBUG
-		printf("SOAP Response :\n%.*s\n", n, buf);
-#endif
-		if(*bufsize > n)
-		{
-			memcpy(buffer, buf, n);
-			*bufsize = n;
-		}
-		else
-		{
-			memcpy(buffer, buf, *bufsize);
-		}
-		free(buf);
-		buf = 0;
-	}
-	closesocket(s);
-	return 0;
-}
-
-/* simpleUPnPcommand :
- * not so simple !
- * return values :
- *   0 - OK
- *  -1 - error */
-int simpleUPnPcommand(int s, const char * url, const char * service,
-		       const char * action, struct UPNParg * args,
-		       char * buffer, int * bufsize)
-{
-	int result;
-	/*int origbufsize = *bufsize;*/
-
-	result = simpleUPnPcommand2(s, url, service, action, args, buffer, bufsize, "1.1");
-/*
-	result = simpleUPnPcommand2(s, url, service, action, args, buffer, bufsize, "1.0");
-	if (result < 0 || *bufsize == 0)
-	{
-#if DEBUG
-	    printf("Error or no result from SOAP request; retrying with HTTP/1.1\n");
-#endif
-		*bufsize = origbufsize;
-		result = simpleUPnPcommand2(s, url, service, action, args, buffer, bufsize, "1.1");
-	}
-*/
-	return result;
-}
-
-/* parseMSEARCHReply()
- * the last 4 arguments are filled during the parsing :
- *    - location/locationsize : "location:" field of the SSDP reply packet
- *    - st/stsize : "st:" field of the SSDP reply packet.
- * The strings are NOT null terminated */
-static void
-parseMSEARCHReply(const char * reply, int size,
-                  const char * * location, int * locationsize,
-			      const char * * st, int * stsize)
-{
-	int a, b, i;
-	i = 0;
-	a = i;	/* start of the line */
-	b = 0;
-	while(i<size)
-	{
-		switch(reply[i])
-		{
-		case ':':
-				if(b==0)
-				{
-					b = i; /* end of the "header" */
-					/*for(j=a; j<b; j++)
-					{
-						putchar(reply[j]);
-					}
-					*/
-				}
-				break;
-		case '\x0a':
-		case '\x0d':
-				if(b!=0)
-				{
-					/*for(j=b+1; j<i; j++)
-					{
-						putchar(reply[j]);
-					}
-					putchar('\n');*/
-					do { b++; } while(reply[b]==' ');
-					if(0==strncasecmp(reply+a, "location", 8))
-					{
-						*location = reply+b;
-						*locationsize = i-b;
-					}
-					else if(0==strncasecmp(reply+a, "st", 2))
-					{
-						*st = reply+b;
-						*stsize = i-b;
-					}
-					b = 0;
-				}
-				a = i+1;
-				break;
-		default:
-				break;
-		}
-		i++;
-	}
-}
-
-/* port upnp discover : SSDP protocol */
-#define PORT 1900
-#define XSTR(s) STR(s)
-#define STR(s) #s
-#define UPNP_MCAST_ADDR "239.255.255.250"
-
-/* upnpDiscover() :
- * return a chained list of all devices found or NULL if
- * no devices was found.
- * It is up to the caller to free the chained list
- * delay is in millisecond (poll) */
-LIBSPEC struct UPNPDev * upnpDiscover(int delay, const char * multicastif,
-                              const char * minissdpdsock, int sameport)
-{
-	struct UPNPDev * tmp;
-	struct UPNPDev * devlist = 0;
-	int opt = 1;
-	static const char MSearchMsgFmt[] = 
-	"M-SEARCH * HTTP/1.1\r\n"
-	"HOST: " UPNP_MCAST_ADDR ":" XSTR(PORT) "\r\n"
-	"ST: %s\r\n"
-	"MAN: \"ssdp:discover\"\r\n"
-	"MX: %u\r\n"
-	"\r\n";
-	static const char * const deviceList[] = {
-		"urn:schemas-upnp-org:device:InternetGatewayDevice:1",
-		"urn:schemas-upnp-org:service:WANIPConnection:1",
-		"urn:schemas-upnp-org:service:WANPPPConnection:1",
-		"upnp:rootdevice",
-		0
-	};
-	int deviceIndex = 0;
-	char bufr[1536];	/* reception and emission buffer */
-	int sudp;
-	int n;
-	struct sockaddr sockudp_r;
-	unsigned int mx;
-#ifdef NO_GETADDRINFO
-	struct sockaddr_in sockudp_w;
-#else
-	int rv;
-	struct addrinfo hints, *servinfo, *p;
-#endif
-#ifdef WIN32
-	MIB_IPFORWARDROW ip_forward;
-#endif
-
-#if !defined(WIN32) && !defined(__amigaos__) && !defined(__amigaos4__)
-	/* first try to get infos from minissdpd ! */
-	if(!minissdpdsock)
-		minissdpdsock = "/var/run/minissdpd.sock";
-	while(!devlist && deviceList[deviceIndex]) {
-		devlist = getDevicesFromMiniSSDPD(deviceList[deviceIndex],
-		                                  minissdpdsock);
-		/* We return what we have found if it was not only a rootdevice */
-		if(devlist && !strstr(deviceList[deviceIndex], "rootdevice"))
-			return devlist;
-		deviceIndex++;
-	}
-	deviceIndex = 0;
-#endif
-	/* fallback to direct discovery */
-#ifdef WIN32
-	sudp = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-#else
-	sudp = socket(PF_INET, SOCK_DGRAM, 0);
-#endif
-	if(sudp < 0)
-	{
-		PRINT_SOCKET_ERROR("socket");
-		return NULL;
-	}
-	/* reception */
-	memset(&sockudp_r, 0, sizeof(struct sockaddr));
-	if(0/*ipv6*/) {
-		struct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_r;
-		p->sin6_family = AF_INET6;
-		if(sameport)
-			p->sin6_port = htons(PORT);
-		p->sin6_addr = in6addr_any;//IN6ADDR_ANY_INIT;/*INADDR_ANY;*/
-	} else {
-		struct sockaddr_in * p = (struct sockaddr_in *)&sockudp_r;
-		p->sin_family = AF_INET;
-		if(sameport)
-			p->sin_port = htons(PORT);
-		p->sin_addr.s_addr = INADDR_ANY;
-	}
-#ifdef WIN32
-/* This code could help us to use the right Network interface for 
- * SSDP multicast traffic */
-/* Get IP associated with the index given in the ip_forward struct
- * in order to give this ip to setsockopt(sudp, IPPROTO_IP, IP_MULTICAST_IF) */
-	if(GetBestRoute(inet_addr("223.255.255.255"), 0, &ip_forward) == NO_ERROR) {
-		DWORD dwRetVal = 0;
-		PMIB_IPADDRTABLE pIPAddrTable;
-		DWORD dwSize = 0;
-#ifdef DEBUG
-		IN_ADDR IPAddr;
-#endif
-		int i;
-#ifdef DEBUG
-		printf("ifIndex=%lu nextHop=%lx \n", ip_forward.dwForwardIfIndex, ip_forward.dwForwardNextHop);
-#endif
-		pIPAddrTable = (MIB_IPADDRTABLE *) malloc(sizeof (MIB_IPADDRTABLE));
-		if (GetIpAddrTable(pIPAddrTable, &dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {
-			free(pIPAddrTable);
-			pIPAddrTable = (MIB_IPADDRTABLE *) malloc(dwSize);
-		}
-		if(pIPAddrTable) {
-			dwRetVal = GetIpAddrTable( pIPAddrTable, &dwSize, 0 );
-#ifdef DEBUG
-			printf("\tNum Entries: %ld\n", pIPAddrTable->dwNumEntries);
-#endif
-			for (i=0; i < (int) pIPAddrTable->dwNumEntries; i++) {
-#ifdef DEBUG
-				printf("\n\tInterface Index[%d]:\t%ld\n", i, pIPAddrTable->table[i].dwIndex);
-				IPAddr.S_un.S_addr = (u_long) pIPAddrTable->table[i].dwAddr;
-				printf("\tIP Address[%d]:     \t%s\n", i, inet_ntoa(IPAddr) );
-				IPAddr.S_un.S_addr = (u_long) pIPAddrTable->table[i].dwMask;
-				printf("\tSubnet Mask[%d]:    \t%s\n", i, inet_ntoa(IPAddr) );
-				IPAddr.S_un.S_addr = (u_long) pIPAddrTable->table[i].dwBCastAddr;
-				printf("\tBroadCast[%d]:      \t%s (%ld)\n", i, inet_ntoa(IPAddr), pIPAddrTable->table[i].dwBCastAddr);
-				printf("\tReassembly size[%d]:\t%ld\n", i, pIPAddrTable->table[i].dwReasmSize);
-				printf("\tType and State[%d]:", i);
-				printf("\n");
-#endif
-				if (pIPAddrTable->table[i].dwIndex == ip_forward.dwForwardIfIndex) {
-					/* Set the address of this interface to be used */
-					struct in_addr mc_if;
-					memset(&mc_if, 0, sizeof(mc_if));
-					mc_if.s_addr = pIPAddrTable->table[i].dwAddr;
-					if(setsockopt(sudp, IPPROTO_IP, IP_MULTICAST_IF, (const char *)&mc_if, sizeof(mc_if)) < 0) {
-						PRINT_SOCKET_ERROR("setsockopt");
-					}
-					((struct sockaddr_in *)&sockudp_r)->sin_addr.s_addr = pIPAddrTable->table[i].dwAddr;
-#ifndef DEBUG
-					break;
-#endif
-				}
-			}
-			free(pIPAddrTable);
-			pIPAddrTable = NULL;
-		}
-	}
-#endif
-
-#ifdef WIN32
-	if (setsockopt(sudp, SOL_SOCKET, SO_REUSEADDR, (const char *)&opt, sizeof (opt)) < 0)
-#else
-	if (setsockopt(sudp, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)
-#endif
-	{
-		PRINT_SOCKET_ERROR("setsockopt");
-		return NULL;
-	}
-
-	if(multicastif)
-	{
-		struct in_addr mc_if;
-		mc_if.s_addr = inet_addr(multicastif);
-		if(0/*ipv6*/) {
-		} else {
-			((struct sockaddr_in *)&sockudp_r)->sin_addr.s_addr = mc_if.s_addr;
-		}
-		if(setsockopt(sudp, IPPROTO_IP, IP_MULTICAST_IF, (const char *)&mc_if, sizeof(mc_if)) < 0)
-		{
-			PRINT_SOCKET_ERROR("setsockopt");
-		}
-	}
-
-	/* Avant d'envoyer le paquet on bind pour recevoir la reponse */
-    if (bind(sudp, &sockudp_r, 0/*ipv6*/?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in)) != 0)
-	{
-        PRINT_SOCKET_ERROR("bind");
-		closesocket(sudp);
-		return NULL;
-    }
-
-	/* Calculating maximum response time in seconds */
-	mx = ((unsigned int)delay) / 1000u;
-	/* receiving SSDP response packet */
-	for(n = 0;;)
-	{
-	if(n == 0)
-	{
-		/* sending the SSDP M-SEARCH packet */
-		n = snprintf(bufr, sizeof(bufr),
-		             MSearchMsgFmt, deviceList[deviceIndex++], mx);
-		/*printf("Sending %s", bufr);*/
-#ifdef NO_GETADDRINFO
-		/* the following code is not using getaddrinfo */
-		/* emission */
-		memset(&sockudp_w, 0, sizeof(struct sockaddr_in));
-		sockudp_w.sin_family = AF_INET;
-		sockudp_w.sin_port = htons(PORT);
-		sockudp_w.sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);
-		n = sendto(sudp, bufr, n, 0,
-		           (struct sockaddr *)&sockudp_w, sizeof(struct sockaddr_in));
-		if (n < 0) {
-			PRINT_SOCKET_ERROR("sendto");
-			closesocket(sudp);
-			return devlist;
-		}
-#else /* #ifdef NO_GETADDRINFO */
-		memset(&hints, 0, sizeof(hints));
-		hints.ai_family = AF_UNSPEC; // AF_INET6 or AF_INET
-		hints.ai_socktype = SOCK_DGRAM;
-		/*hints.ai_flags = */
-		if ((rv = getaddrinfo(UPNP_MCAST_ADDR, XSTR(PORT), &hints, &servinfo)) != 0) {
-#ifdef WIN32
-		    fprintf(stderr, "getaddrinfo() failed: %d\n", rv);
-#else
-		    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
-#endif
-		    return devlist;
-		}
-		for(p = servinfo; p; p = p->ai_next) {
-			n = sendto(sudp, bufr, n, 0, p->ai_addr, p->ai_addrlen);
-			if (n < 0) {
-				PRINT_SOCKET_ERROR("sendto");
-				continue;
-			}
-		}
-		freeaddrinfo(servinfo);
-		if(n < 0) {
-			closesocket(sudp);
-			return devlist;
-		}
-#endif /* #ifdef NO_GETADDRINFO */
-	}
-	/* Waiting for SSDP REPLY packet to M-SEARCH */
-	n = ReceiveData(sudp, bufr, sizeof(bufr), delay);
-	if (n < 0) {
-		/* error */
-		closesocket(sudp);
-		return devlist;
-	} else if (n == 0) {
-		/* no data or Time Out */
-		if (devlist || (deviceList[deviceIndex] == 0)) {
-			/* no more device type to look for... */
-			closesocket(sudp);
-			return devlist;
-		}
-	} else {
-		const char * descURL=NULL;
-		int urlsize=0;
-		const char * st=NULL;
-		int stsize=0;
-        /*printf("%d byte(s) :\n%s\n", n, bufr);*/ /* affichage du message */
-		parseMSEARCHReply(bufr, n, &descURL, &urlsize, &st, &stsize);
-		if(st&&descURL)
-		{
-#ifdef DEBUG
-			printf("M-SEARCH Reply:\nST: %.*s\nLocation: %.*s\n",
-			       stsize, st, urlsize, descURL);
-#endif
-			for(tmp=devlist; tmp; tmp = tmp->pNext) {
-				if(memcmp(tmp->descURL, descURL, urlsize) == 0 &&
-				   tmp->descURL[urlsize] == '\0' &&
-				   memcmp(tmp->st, st, stsize) == 0 &&
-				   tmp->st[stsize] == '\0')
-					break;
-			}
-			/* at the exit of the loop above, tmp is null if
-			 * no duplicate device was found */
-			if(tmp)
-				continue;
-			tmp = (struct UPNPDev *)malloc(sizeof(struct UPNPDev)+urlsize+stsize);
-			tmp->pNext = devlist;
-			tmp->descURL = tmp->buffer;
-			tmp->st = tmp->buffer + 1 + urlsize;
-			memcpy(tmp->buffer, descURL, urlsize);
-			tmp->buffer[urlsize] = '\0';
-			memcpy(tmp->buffer + urlsize + 1, st, stsize);
-			tmp->buffer[urlsize+1+stsize] = '\0';
-			devlist = tmp;
-		}
-	}
-	}
-}
-
-/* freeUPNPDevlist() should be used to
- * free the chained list returned by upnpDiscover() */
-LIBSPEC void freeUPNPDevlist(struct UPNPDev * devlist)
-{
-	struct UPNPDev * next;
-	while(devlist)
-	{
-		next = devlist->pNext;
-		free(devlist);
-		devlist = next;
-	}
-}
-
-static void
-url_cpy_or_cat(char * dst, const char * src, int n)
-{
-	if(  (src[0] == 'h')
-	   &&(src[1] == 't')
-	   &&(src[2] == 't')
-	   &&(src[3] == 'p')
-	   &&(src[4] == ':')
-	   &&(src[5] == '/')
-	   &&(src[6] == '/'))
-	{
-		strncpy(dst, src, n);
-	}
-	else
-	{
-		int l = strlen(dst);
-		if(src[0] != '/')
-			dst[l++] = '/';
-		if(l<=n)
-			strncpy(dst + l, src, n - l);
-	}
-}
-
-/* Prepare the Urls for usage...
- */
-LIBSPEC void GetUPNPUrls(struct UPNPUrls * urls, struct IGDdatas * data,
-                 const char * descURL)
-{
-	char * p;
-	int n1, n2, n3;
-	n1 = strlen(data->urlbase);
-	if(n1==0)
-		n1 = strlen(descURL);
-	n1 += 2;	/* 1 byte more for Null terminator, 1 byte for '/' if needed */
-	n2 = n1; n3 = n1;
-	n1 += strlen(data->first.scpdurl);
-	n2 += strlen(data->first.controlurl);
-	n3 += strlen(data->CIF.controlurl);
-
-	urls->ipcondescURL = (char *)malloc(n1);
-	urls->controlURL = (char *)malloc(n2);
-	urls->controlURL_CIF = (char *)malloc(n3);
-	/* maintenant on chope la desc du WANIPConnection */
-	if(data->urlbase[0] != '\0')
-		strncpy(urls->ipcondescURL, data->urlbase, n1);
-	else
-		strncpy(urls->ipcondescURL, descURL, n1);
-	p = strchr(urls->ipcondescURL+7, '/');
-	if(p) p[0] = '\0';
-	strncpy(urls->controlURL, urls->ipcondescURL, n2);
-	strncpy(urls->controlURL_CIF, urls->ipcondescURL, n3);
-	
-	url_cpy_or_cat(urls->ipcondescURL, data->first.scpdurl, n1);
-
-	url_cpy_or_cat(urls->controlURL, data->first.controlurl, n2);
-
-	url_cpy_or_cat(urls->controlURL_CIF, data->CIF.controlurl, n3);
-
-#ifdef DEBUG
-	printf("urls->ipcondescURL='%s' %u n1=%d\n", urls->ipcondescURL,
-	       (unsigned)strlen(urls->ipcondescURL), n1);
-	printf("urls->controlURL='%s' %u n2=%d\n", urls->controlURL,
-	       (unsigned)strlen(urls->controlURL), n2);
-	printf("urls->controlURL_CIF='%s' %u n3=%d\n", urls->controlURL_CIF,
-	       (unsigned)strlen(urls->controlURL_CIF), n3);
-#endif
-}
-
-LIBSPEC void
-FreeUPNPUrls(struct UPNPUrls * urls)
-{
-	if(!urls)
-		return;
-	free(urls->controlURL);
-	urls->controlURL = 0;
-	free(urls->ipcondescURL);
-	urls->ipcondescURL = 0;
-	free(urls->controlURL_CIF);
-	urls->controlURL_CIF = 0;
-}
-
-
-int ReceiveData(int socket, char * data, int length, int timeout)
-{
-    int n;
-#if !defined(WIN32) && !defined(__amigaos__) && !defined(__amigaos4__)
-    struct pollfd fds[1]; /* for the poll */
-#ifdef MINIUPNPC_IGNORE_EINTR
-    do {
-#endif
-        fds[0].fd = socket;
-        fds[0].events = POLLIN;
-        n = poll(fds, 1, timeout);
-#ifdef MINIUPNPC_IGNORE_EINTR
-    } while(n < 0 && errno == EINTR);
-#endif
-    if(n < 0)
-    {
-        PRINT_SOCKET_ERROR("poll");
-        return -1;
-    }
-    else if(n == 0)
-    {
-        return 0;
-    }
-#else
-    fd_set socketSet;
-    TIMEVAL timeval;
-    FD_ZERO(&socketSet);
-    FD_SET(socket, &socketSet);
-    timeval.tv_sec = timeout / 1000;
-    timeval.tv_usec = (timeout % 1000) * 1000;
-    n = select(FD_SETSIZE, &socketSet, NULL, NULL, &timeval);
-    if(n < 0)
-    {
-        PRINT_SOCKET_ERROR("select");
-        return -1;
-    }
-    else if(n == 0)
-    {
-        return 0;
-    }    
-#endif
-	n = recv(socket, data, length, 0);
-	if(n<0)
-	{
-		PRINT_SOCKET_ERROR("recv");
-	}
-	return n;
-}
-
-int
-UPNPIGD_IsConnected(struct UPNPUrls * urls, struct IGDdatas * data)
-{
-	char status[64];
-	unsigned int uptime;
-	status[0] = '\0';
-	UPNP_GetStatusInfo(urls->controlURL, data->first.servicetype,
-	                   status, &uptime, NULL);
-	if(0 == strcmp("Connected", status))
-	{
-		return 1;
-	}
-	else
-		return 0;
-}
-
-
-/* UPNP_GetValidIGD() :
- * return values :
- *     0 = NO IGD found
- *     1 = A valid connected IGD has been found
- *     2 = A valid IGD has been found but it reported as
- *         not connected
- *     3 = an UPnP device has been found but was not recognized as an IGD
- *
- * In any non zero return case, the urls and data structures
- * passed as parameters are set. Donc forget to call FreeUPNPUrls(urls) to
- * free allocated memory.
- */
-LIBSPEC int
-UPNP_GetValidIGD(struct UPNPDev * devlist,
-                 struct UPNPUrls * urls,
-				 struct IGDdatas * data,
-				 char * lanaddr, int lanaddrlen)
-{
-	char * descXML;
-	int descXMLsize = 0;
-	struct UPNPDev * dev;
-	int ndev = 0;
-	int state; /* state 1 : IGD connected. State 2 : IGD. State 3 : anything */
-	if(!devlist)
-	{
-#ifdef DEBUG
-		printf("Empty devlist\n");
-#endif
-		return 0;
-	}
-	for(state = 1; state <= 3; state++)
-	{
-		for(dev = devlist; dev; dev = dev->pNext)
-		{
-			/* we should choose an internet gateway device.
-		 	* with st == urn:schemas-upnp-org:device:InternetGatewayDevice:1 */
-			descXML = miniwget_getaddr(dev->descURL, &descXMLsize,
-			   	                        lanaddr, lanaddrlen);
-			if(descXML)
-			{
-				ndev++;
-				memset(data, 0, sizeof(struct IGDdatas));
-				memset(urls, 0, sizeof(struct UPNPUrls));
-				parserootdesc(descXML, descXMLsize, data);
-				free(descXML);
-				descXML = NULL;
-				if(0==strcmp(data->CIF.servicetype,
-				   "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1")
-				   || state >= 3 )
-				{
-				  GetUPNPUrls(urls, data, dev->descURL);
-
-#ifdef DEBUG
-				  printf("UPNPIGD_IsConnected(%s) = %d\n",
-				     urls->controlURL,
-			         UPNPIGD_IsConnected(urls, data));
-#endif
-				  if((state >= 2) || UPNPIGD_IsConnected(urls, data))
-					return state;
-				  FreeUPNPUrls(urls);
-				  if(data->second.servicetype[0] != '\0') {
-#ifdef DEBUG
-				    printf("We tried %s, now we try %s !\n",
-				           data->first.servicetype, data->second.servicetype);
-#endif
-				    /* swaping WANPPPConnection and WANIPConnection ! */
-				    memcpy(&data->tmp, &data->first, sizeof(struct IGDdatas_service));
-				    memcpy(&data->first, &data->second, sizeof(struct IGDdatas_service));
-				    memcpy(&data->second, &data->tmp, sizeof(struct IGDdatas_service));
-				    GetUPNPUrls(urls, data, dev->descURL);
-#ifdef DEBUG
-				    printf("UPNPIGD_IsConnected(%s) = %d\n",
-				       urls->controlURL,
-			           UPNPIGD_IsConnected(urls, data));
-#endif
-				    if((state >= 2) || UPNPIGD_IsConnected(urls, data))
-					  return state;
-				    FreeUPNPUrls(urls);
-				  }
-				}
-				memset(data, 0, sizeof(struct IGDdatas));
-			}
-#ifdef DEBUG
-			else
-			{
-				printf("error getting XML description %s\n", dev->descURL);
-			}
-#endif
-		}
-	}
-	return 0;
-}
-
-/* UPNP_GetIGDFromUrl()
- * Used when skipping the discovery process.
- * return value :
- *   0 - Not ok
- *   1 - OK */
-int
-UPNP_GetIGDFromUrl(const char * rootdescurl,
-                   struct UPNPUrls * urls,
-                   struct IGDdatas * data,
-                   char * lanaddr, int lanaddrlen)
-{
-	char * descXML;
-	int descXMLsize = 0;
-	descXML = miniwget_getaddr(rootdescurl, &descXMLsize,
-	   	                       lanaddr, lanaddrlen);
-	if(descXML) {
-		memset(data, 0, sizeof(struct IGDdatas));
-		memset(urls, 0, sizeof(struct UPNPUrls));
-		parserootdesc(descXML, descXMLsize, data);
-		free(descXML);
-		descXML = NULL;
-		GetUPNPUrls(urls, data, rootdescurl);
-		return 1;
-	} else {
-		return 0;
-	}
-}
-
diff --git a/third-party/miniupnp/miniupnpc.h b/user/transmission/third-party/miniupnp/miniupnpc.h
deleted file mode 100644
index 2379ba1..0000000
--- a/third-party/miniupnp/miniupnpc.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/* $Id: miniupnpc.h,v 1.19 2009/10/10 19:15:35 nanard Exp $ */
-/* Project: miniupnp
- * http://miniupnp.free.fr/
- * Author: Thomas Bernard
- * Copyright (c) 2005-2006 Thomas Bernard
- * This software is subjects to the conditions detailed
- * in the LICENCE file provided within this distribution */
-#ifndef __MINIUPNPC_H__
-#define __MINIUPNPC_H__
-
-#include "declspec.h"
-#include "igd_desc_parse.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Structures definitions : */
-struct UPNParg { const char * elt; const char * val; };
-
-int simpleUPnPcommand(int, const char *, const char *,
-                      const char *, struct UPNParg *,
-                      char *, int *);
-
-struct UPNPDev {
-	struct UPNPDev * pNext;
-	char * descURL;
-	char * st;
-	char buffer[2];
-};
-
-/* upnpDiscover()
- * discover UPnP devices on the network.
- * The discovered devices are returned as a chained list.
- * It is up to the caller to free the list with freeUPNPDevlist().
- * delay (in millisecond) is the maximum time for waiting any device
- * response.
- * If available, device list will be obtained from MiniSSDPd.
- * Default path for minissdpd socket will be used if minissdpdsock argument
- * is NULL.
- * If multicastif is not NULL, it will be used instead of the default
- * multicast interface for sending SSDP discover packets.
- * If sameport is not null, SSDP packets will be sent from the source port
- * 1900 (same as destination port) otherwise system assign a source port. */
-LIBSPEC struct UPNPDev * upnpDiscover(int delay, const char * multicastif,
-                                      const char * minissdpdsock, int sameport);
-/* freeUPNPDevlist()
- * free list returned by upnpDiscover() */
-LIBSPEC void freeUPNPDevlist(struct UPNPDev * devlist);
-
-/* parserootdesc() :
- * parse root XML description of a UPnP device and fill the IGDdatas
- * structure. */
-LIBSPEC void parserootdesc(const char *, int, struct IGDdatas *);
-
-/* structure used to get fast access to urls
- * controlURL: controlURL of the WANIPConnection
- * ipcondescURL: url of the description of the WANIPConnection
- * controlURL_CIF: controlURL of the WANCommonInterfaceConfig
- */
-struct UPNPUrls {
-	char * controlURL;
-	char * ipcondescURL;
-	char * controlURL_CIF;
-};
-
-/* UPNP_GetValidIGD() :
- * return values :
- *     0 = NO IGD found
- *     1 = A valid connected IGD has been found
- *     2 = A valid IGD has been found but it reported as
- *         not connected
- *     3 = an UPnP device has been found but was not recognized as an IGD
- *
- * In any non zero return case, the urls and data structures
- * passed as parameters are set. Donc forget to call FreeUPNPUrls(urls) to
- * free allocated memory.
- */
-LIBSPEC int
-UPNP_GetValidIGD(struct UPNPDev * devlist,
-                 struct UPNPUrls * urls,
-				 struct IGDdatas * data,
-				 char * lanaddr, int lanaddrlen);
-
-/* UPNP_GetIGDFromUrl()
- * Used when skipping the discovery process.
- * return value :
- *   0 - Not ok
- *   1 - OK */
-LIBSPEC int
-UPNP_GetIGDFromUrl(const char * rootdescurl,
-                   struct UPNPUrls * urls,
-                   struct IGDdatas * data,
-                   char * lanaddr, int lanaddrlen);
-
-LIBSPEC void GetUPNPUrls(struct UPNPUrls *, struct IGDdatas *, const char *);
-
-LIBSPEC void FreeUPNPUrls(struct UPNPUrls *);
-
-/* Reads data from the specified socket. 
- * Returns the number of bytes read if successful, zero if no bytes were 
- * read or if we timed out. Returns negative if there was an error. */
-int ReceiveData(int socket, char * data, int length, int timeout);
-
-/* return 0 or 1 */
-LIBSPEC int UPNPIGD_IsConnected(struct UPNPUrls *, struct IGDdatas *);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
diff --git a/third-party/miniupnp/miniupnpcstrings.h.in b/user/transmission/third-party/miniupnp/miniupnpcstrings.h.in
deleted file mode 100644
index 8ab3f29..0000000
--- a/third-party/miniupnp/miniupnpcstrings.h.in
+++ /dev/null
@@ -1,15 +0,0 @@
-/* $Id: miniupnpcstrings.h.in,v 1.2 2009/10/30 09:18:18 nanard Exp $ */
-/* Project: miniupnp
- * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * Author: Thomas Bernard
- * Copyright (c) 2005-2009 Thomas Bernard
- * This software is subjects to the conditions detailed
- * in the LICENCE file provided within this distribution */
-#ifndef __MINIUPNPCSTRINGS_H__
-#define __MINIUPNPCSTRINGS_H__
-
-#define OS_STRING "OS/version"
-#define MINIUPNPC_VERSION_STRING "1.4"
-
-#endif
-
diff --git a/third-party/miniupnp/miniwget.c b/user/transmission/third-party/miniupnp/miniwget.c
deleted file mode 100644
index 89afe2e..0000000
--- a/third-party/miniupnp/miniwget.c
+++ /dev/null
@@ -1,459 +0,0 @@
-/* $Id: miniwget.c,v 1.41 2010/12/12 23:52:02 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas Bernard
- * Copyright (c) 2005-2010 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution. */
- 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include "miniupnpc.h"
-#ifdef WIN32
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#include <io.h>
-#define MAXHOSTNAMELEN 64
-#define MIN(x,y) (((x)<(y))?(x):(y))
-#define snprintf _snprintf
-#define socklen_t int
-#if defined(_MSC_VER) && (_MSC_VER >= 1400)
-#define strncasecmp _memicmp
-#else /* defined(_MSC_VER) && (_MSC_VER >= 1400) */
-#define strncasecmp memicmp
-#endif /* defined(_MSC_VER) && (_MSC_VER >= 1400) */
-#else /* #ifdef WIN32 */
-#include <unistd.h>
-#include <sys/param.h>
-#if defined(__amigaos__) && !defined(__amigaos4__)
-#define socklen_t int
-#else /* #if defined(__amigaos__) && !defined(__amigaos4__) */
-#include <sys/select.h>
-#endif /* #else defined(__amigaos__) && !defined(__amigaos4__) */
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#define closesocket close
-/* defining MINIUPNPC_IGNORE_EINTR enable the ignore of interruptions
- * during the connect() call */
-#define MINIUPNPC_IGNORE_EINTR
-#endif /* #else WIN32 */
-#if defined(__sun) || defined(sun)
-#define MIN(x,y) (((x)<(y))?(x):(y))
-#endif
-
-#include "miniupnpcstrings.h"
-#include "miniwget.h"
-#include "connecthostport.h"
-
-/*
- * Read a HTTP response from a socket.
- * Process Content-Length and Transfer-encoding headers.
- */
-void *
-getHTTPResponse(int s, int * size)
-{
-	char buf[2048];
-	int n;
-	int headers = 1;
-	int chunked = 0;
-	int content_length = -1;
-	unsigned int chunksize = 0;
-	unsigned int bytestocopy = 0;
-	/* buffers : */
-	char * header_buf;
-	int header_buf_len = 2048;
-	int header_buf_used = 0;
-	char * content_buf;
-	int content_buf_len = 2048;
-	int content_buf_used = 0;
-
-	header_buf = malloc(header_buf_len);
-	content_buf = malloc(content_buf_len);
-
-	while((n = ReceiveData(s, buf, 2048, 5000)) > 0)
-	{
-		if(headers)
-		{
-			int i;
-			int linestart=0;
-			int colon=0;
-			int valuestart=0;
-			if(header_buf_used + n > header_buf_len) {
-				header_buf = realloc(header_buf, header_buf_used + n);
-				header_buf_len = header_buf_used + n;
-			}
-			memcpy(header_buf + header_buf_used, buf, n);
-			header_buf_used += n;
-			for(i = 0; i < (header_buf_used-3); i++) {
-				if(colon <= linestart && header_buf[i]==':')
-				{
-					colon = i;
-					while(i < (n-3)
-					      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\t'))
-						i++;
-					valuestart = i + 1;
-				}
-				/* detecting end of line */
-				else if(header_buf[i]=='\r' && header_buf[i+1]=='\n')
-				{
-					if(colon > linestart && valuestart > colon)
-					{
-#ifdef DEBUG
-						printf("header='%.*s', value='%.*s'\n",
-						       colon-linestart, header_buf+linestart,
-						       i-valuestart, header_buf+valuestart);
-#endif
-						if(0==strncasecmp(header_buf+linestart, "content-length", colon-linestart))
-						{
-							content_length = atoi(header_buf+valuestart);
-#ifdef DEBUG
-							printf("Content-Length: %d\n", content_length);
-#endif
-						}
-						else if(0==strncasecmp(header_buf+linestart, "transfer-encoding", colon-linestart)
-						   && 0==strncasecmp(buf+valuestart, "chunked", 7))
-						{
-#ifdef DEBUG
-							printf("chunked transfer-encoding!\n");
-#endif
-							chunked = 1;
-						}
-					}
-					linestart = i+2;
-					colon = linestart;
-					valuestart = 0;
-				} 
-				/* searching for the end of the HTTP headers */
-				if(header_buf[i]=='\r' && header_buf[i+1]=='\n'
-				   && header_buf[i+2]=='\r' && header_buf[i+3]=='\n')
-				{
-					headers = 0;	/* end */
-					i += 4;
-					if(i < header_buf_used)
-					{
-						if(chunked)
-						{
-							while(i<header_buf_used)
-							{
-								while(i<header_buf_used && isxdigit(header_buf[i]))
-								{
-									if(header_buf[i] >= '0' && header_buf[i] <= '9')
-										chunksize = (chunksize << 4) + (header_buf[i] - '0');
-									else
-										chunksize = (chunksize << 4) + ((header_buf[i] | 32) - 'a' + 10);
-									i++;
-								}
-								/* discarding chunk-extension */
-								while(i < header_buf_used && header_buf[i] != '\r') i++;
-								if(i < header_buf_used && header_buf[i] == '\r') i++;
-								if(i < header_buf_used && header_buf[i] == '\n') i++;
-#ifdef DEBUG
-								printf("chunksize = %u (%x)\n", chunksize, chunksize);
-#endif
-								if(chunksize == 0)
-								{
-#ifdef DEBUG
-									printf("end of HTTP content !\n");
-#endif
-									goto end_of_stream;	
-								}
-								bytestocopy = ((int)chunksize < header_buf_used - i)?chunksize:(header_buf_used - i);
-#ifdef DEBUG
-								printf("chunksize=%u bytestocopy=%u (i=%d header_buf_used=%d)\n",
-								       chunksize, bytestocopy, i, header_buf_used);
-#endif
-								if(content_buf_len < (int)(content_buf_used + bytestocopy))
-								{
-									content_buf = realloc(content_buf, content_buf_used + bytestocopy);
-									content_buf_len = content_buf_used + bytestocopy;
-								}
-								memcpy(content_buf + content_buf_used, header_buf + i, bytestocopy);
-								content_buf_used += bytestocopy;
-								chunksize -= bytestocopy;
-								i += bytestocopy;
-							}
-						}
-						else
-						{
-							if(content_buf_len < header_buf_used - i)
-							{
-								content_buf = realloc(content_buf, header_buf_used - i);
-								content_buf_len = header_buf_used - i;
-							}
-							memcpy(content_buf, header_buf + i, header_buf_used - i);
-							content_buf_used = header_buf_used - i;
-							i = header_buf_used;
-						}
-					}
-				}
-			}
-		}
-		else
-		{
-			/* content */
-			if(chunked)
-			{
-				int i = 0;
-				while(i < n)
-				{
-					if(chunksize == 0)
-					{
-						/* reading chunk size */
-						if(i<n && buf[i] == '\r') i++;
-						if(i<n && buf[i] == '\n') i++;
-						while(i<n && isxdigit(buf[i]))
-						{
-							if(buf[i] >= '0' && buf[i] <= '9')
-								chunksize = (chunksize << 4) + (buf[i] - '0');
-							else
-								chunksize = (chunksize << 4) + ((buf[i] | 32) - 'a' + 10);
-							i++;
-						}
-						while(i<n && buf[i] != '\r') i++; /* discarding chunk-extension */
-						if(i<n && buf[i] == '\r') i++;
-						if(i<n && buf[i] == '\n') i++;
-#ifdef DEBUG
-						printf("chunksize = %u (%x)\n", chunksize, chunksize);
-#endif
-						if(chunksize == 0)
-						{
-#ifdef DEBUG
-							printf("end of HTTP content - %d %d\n", i, n);
-							/*printf("'%.*s'\n", n-i, buf+i);*/
-#endif
-							goto end_of_stream;
-						}
-					}
-					bytestocopy = ((int)chunksize < n - i)?chunksize:(n - i);
-					if((int)(content_buf_used + bytestocopy) > content_buf_len)
-					{
-						content_buf = (char *)realloc((void *)content_buf, 
-						                              content_buf_used + bytestocopy);
-						content_buf_len = content_buf_used + bytestocopy;
-					}
-					memcpy(content_buf + content_buf_used, buf + i, bytestocopy);
-					content_buf_used += bytestocopy;
-					i += bytestocopy;
-					chunksize -= bytestocopy;
-				}
-			}
-			else
-			{
-				if(content_buf_used + n > content_buf_len)
-				{
-					content_buf = (char *)realloc((void *)content_buf, 
-					                              content_buf_used + n);
-					content_buf_len = content_buf_used + n;
-				}
-				memcpy(content_buf + content_buf_used, buf, n);
-				content_buf_used += n;
-			}
-		}
-		if(content_length > 0 && content_buf_used >= content_length)
-		{
-#ifdef DEBUG
-			printf("End of HTTP content\n");
-#endif
-			break;
-		}
-	}
-end_of_stream:
-	free(header_buf); header_buf = NULL;
-	*size = content_buf_used;
-	if(content_buf_used == 0)
-	{
-		free(content_buf);
-		content_buf = NULL;
-	}
-	return content_buf;
-}
-
-/* miniwget3() :
- * do all the work.
- * Return NULL if something failed. */
-static void *
-miniwget3(const char * url, const char * host,
-		  unsigned short port, const char * path,
-		  int * size, char * addr_str, int addr_str_len, const char * httpversion)
-{
-	char buf[2048];
-    int s;
-	int n;
-	int len;
-	int sent;
-
-	*size = 0;
-	s = connecthostport(host, port);
-	if(s < 0)
-		return NULL;
-
-	/* get address for caller ! */
-	if(addr_str)
-	{
-		struct sockaddr saddr;
-		socklen_t saddrlen;
-
-		saddrlen = sizeof(saddr);
-		if(getsockname(s, &saddr, &saddrlen) < 0)
-		{
-			perror("getsockname");
-		}
-		else
-		{
-#if defined(__amigaos__) && !defined(__amigaos4__)
-	/* using INT WINAPI WSAAddressToStringA(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);
-     * But his function make a string with the port :  nn.nn.nn.nn:port */
-/*		if(WSAAddressToStringA((SOCKADDR *)&saddr, sizeof(saddr),
-                            NULL, addr_str, (DWORD *)&addr_str_len))
-		{
-		    printf("WSAAddressToStringA() failed : %d\n", WSAGetLastError());
-		}*/
-			strncpy(addr_str, inet_ntoa(((struct sockaddr_in *)&saddr)->sin_addr), addr_str_len);
-#else
-			/*inet_ntop(AF_INET, &saddr.sin_addr, addr_str, addr_str_len);*/
-			n = getnameinfo(&saddr, saddrlen,
-			                addr_str, addr_str_len,
-			                NULL, 0,
-			                NI_NUMERICHOST | NI_NUMERICSERV);
-			if(n != 0) {
-#ifdef WIN32
-				fprintf(stderr, "getnameinfo() failed : %d\n", n);
-#else
-				fprintf(stderr, "getnameinfo() failed : %s\n", gai_strerror(n));
-#endif
-			}
-#endif
-		}
-#ifdef DEBUG
-		printf("address miniwget : %s\n", addr_str);
-#endif
-	}
-
-	len = snprintf(buf, sizeof(buf),
-                 "GET %s HTTP/%s\r\n"
-			     "Host: %s:%d\r\n"
-				 "Connection: Close\r\n"
-				 "User-Agent: " OS_STRING ", UPnP/1.0, MiniUPnPc/" MINIUPNPC_VERSION_STRING "\r\n"
-
-				 "\r\n",
-			   path, httpversion, host, port);
-	sent = 0;
-	/* sending the HTTP request */
-	while(sent < len)
-	{
-		n = send(s, buf+sent, len-sent, 0);
-		if(n < 0)
-		{
-			perror("send");
-			closesocket(s);
-			return NULL;
-		}
-		else
-		{
-			sent += n;
-		}
-	}
-	return getHTTPResponse(s, size);
-}
-
-/* miniwget2() :
- * Call miniwget3(); retry with HTTP/1.1 if 1.0 fails. */
-static void *
-miniwget2(const char * url, const char * host,
-		  unsigned short port, const char * path,
-		  int * size, char * addr_str, int addr_str_len)
-{
-	char * respbuffer;
-
-	respbuffer = miniwget3(url, host, port, path, size, addr_str, addr_str_len, "1.1");
-/*
-	respbuffer = miniwget3(url, host, port, path, size, addr_str, addr_str_len, "1.0");
-	if (*size == 0)
-	{
-#ifdef DEBUG
-		printf("Retrying with HTTP/1.1\n");
-#endif
-		free(respbuffer);
-		respbuffer = miniwget3(url, host, port, path, size, addr_str, addr_str_len, "1.1");
-	}
-*/
-	return respbuffer;
-}
-
-
-
-
-/* parseURL()
- * arguments :
- *   url :		source string not modified
- *   hostname :	hostname destination string (size of MAXHOSTNAMELEN+1)
- *   port :		port (destination)
- *   path :		pointer to the path part of the URL 
- *
- * Return values :
- *    0 - Failure
- *    1 - Success         */
-int parseURL(const char * url, char * hostname, unsigned short * port, char * * path)
-{
-	char * p1, *p2, *p3;
-	p1 = strstr(url, "://");
-	if(!p1)
-		return 0;
-	p1 += 3;
-	if(  (url[0]!='h') || (url[1]!='t')
-	   ||(url[2]!='t') || (url[3]!='p'))
-		return 0;
-	p2 = strchr(p1, ':');
-	p3 = strchr(p1, '/');
-	if(!p3)
-		return 0;
-	memset(hostname, 0, MAXHOSTNAMELEN + 1);
-	if(!p2 || (p2>p3))
-	{
-		strncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p3-p1)));
-		*port = 80;
-	}
-	else
-	{
-		strncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p2-p1)));
-		*port = 0;
-		p2++;
-		while( (*p2 >= '0') && (*p2 <= '9'))
-		{
-			*port *= 10;
-			*port += (unsigned short)(*p2 - '0');
-			p2++;
-		}
-	}
-	*path = p3;
-	return 1;
-}
-
-void * miniwget(const char * url, int * size)
-{
-	unsigned short port;
-	char * path;
-	/* protocol://host:port/chemin */
-	char hostname[MAXHOSTNAMELEN+1];
-	*size = 0;
-	if(!parseURL(url, hostname, &port, &path))
-		return NULL;
-	return miniwget2(url, hostname, port, path, size, 0, 0);
-}
-
-void * miniwget_getaddr(const char * url, int * size, char * addr, int addrlen)
-{
-	unsigned short port;
-	char * path;
-	/* protocol://host:port/chemin */
-	char hostname[MAXHOSTNAMELEN+1];
-	*size = 0;
-	if(addr)
-		addr[0] = '\0';
-	if(!parseURL(url, hostname, &port, &path))
-		return NULL;
-	return miniwget2(url, hostname, port, path, size, addr, addrlen);
-}
-
diff --git a/third-party/miniupnp/miniwget.h b/user/transmission/third-party/miniupnp/miniwget.h
deleted file mode 100644
index 8314b40..0000000
--- a/third-party/miniupnp/miniwget.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* $Id: miniwget.h,v 1.6 2010/12/09 16:11:33 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas Bernard
- * Copyright (c) 2005 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution.
- * */
-#ifndef __MINIWGET_H__
-#define __MINIWGET_H__
-
-#include "declspec.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-LIBSPEC void * getHTTPResponse(int s, int * size);
-
-LIBSPEC void * miniwget(const char *, int *);
-
-LIBSPEC void * miniwget_getaddr(const char *, int *, char *, int);
-
-int parseURL(const char *, char *, unsigned short *, char * *);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
diff --git a/third-party/miniupnp/minixml.c b/user/transmission/third-party/miniupnp/minixml.c
deleted file mode 100644
index 83c6acd..0000000
--- a/third-party/miniupnp/minixml.c
+++ /dev/null
@@ -1,191 +0,0 @@
-/* $Id: minixml.c,v 1.7 2009/10/10 19:15:35 nanard Exp $ */
-/* minixml.c : the minimum size a xml parser can be ! */
-/* Project : miniupnp
- * webpage: http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * Author : Thomas Bernard
-
-Copyright (c) 2005-2009, Thomas BERNARD 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice,
-      this list of conditions and the following disclaimer in the documentation
-      and/or other materials provided with the distribution.
-    * The name of the author may not be used to endorse or promote products
-	  derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "minixml.h"
-
-/* parseatt : used to parse the argument list
- * return 0 (false) in case of success and -1 (true) if the end
- * of the xmlbuffer is reached. */
-static int parseatt(struct xmlparser * p)
-{
-	const char * attname;
-	int attnamelen;
-	const char * attvalue;
-	int attvaluelen;
-	while(p->xml < p->xmlend)
-	{
-		if(*p->xml=='/' || *p->xml=='>')
-			return 0;
-		if( !IS_WHITE_SPACE(*p->xml) )
-		{
-			char sep;
-			attname = p->xml;
-			attnamelen = 0;
-			while(*p->xml!='=' && !IS_WHITE_SPACE(*p->xml) )
-			{
-				attnamelen++; p->xml++;
-				if(p->xml >= p->xmlend)
-					return -1;
-			}
-			while(*(p->xml++) != '=')
-			{
-				if(p->xml >= p->xmlend)
-					return -1;
-			}
-			while(IS_WHITE_SPACE(*p->xml))
-			{
-				p->xml++;
-				if(p->xml >= p->xmlend)
-					return -1;
-			}
-			sep = *p->xml;
-			if(sep=='\'' || sep=='\"')
-			{
-				p->xml++;
-				if(p->xml >= p->xmlend)
-					return -1;
-				attvalue = p->xml;
-				attvaluelen = 0;
-				while(*p->xml != sep)
-				{
-					attvaluelen++; p->xml++;
-					if(p->xml >= p->xmlend)
-						return -1;
-				}
-			}
-			else
-			{
-				attvalue = p->xml;
-				attvaluelen = 0;
-				while(   !IS_WHITE_SPACE(*p->xml)
-					  && *p->xml != '>' && *p->xml != '/')
-				{
-					attvaluelen++; p->xml++;
-					if(p->xml >= p->xmlend)
-						return -1;
-				}
-			}
-			/*printf("%.*s='%.*s'\n",
-			       attnamelen, attname, attvaluelen, attvalue);*/
-			if(p->attfunc)
-				p->attfunc(p->data, attname, attnamelen, attvalue, attvaluelen);
-		}
-		p->xml++;
-	}
-	return -1;
-}
-
-/* parseelt parse the xml stream and
- * call the callback functions when needed... */
-static void parseelt(struct xmlparser * p)
-{
-	int i;
-	const char * elementname;
-	while(p->xml < (p->xmlend - 1))
-	{
-		if((p->xml)[0]=='<' && (p->xml)[1]!='?')
-		{
-			i = 0; elementname = ++p->xml;
-			while( !IS_WHITE_SPACE(*p->xml)
-				  && (*p->xml!='>') && (*p->xml!='/')
-				 )
-			{
-				i++; p->xml++;
-				if (p->xml >= p->xmlend)
-					return;
-				/* to ignore namespace : */
-				if(*p->xml==':')
-				{
-					i = 0;
-					elementname = ++p->xml;
-				}
-			}
-			if(i>0)
-			{
-				if(p->starteltfunc)
-					p->starteltfunc(p->data, elementname, i);
-				if(parseatt(p))
-					return;
-				if(*p->xml!='/')
-				{
-					const char * data;
-					i = 0; data = ++p->xml;
-					if (p->xml >= p->xmlend)
-						return;
-					while( IS_WHITE_SPACE(*p->xml) )
-					{
-						p->xml++;
-						if (p->xml >= p->xmlend)
-							return;
-					}
-					while(*p->xml!='<')
-					{
-						i++; p->xml++;
-						if (p->xml >= p->xmlend)
-							return;
-					}
-					if(i>0 && p->datafunc)
-						p->datafunc(p->data, data, i);
-				}
-			}
-			else if(*p->xml == '/')
-			{
-				i = 0; elementname = ++p->xml;
-				if (p->xml >= p->xmlend)
-					return;
-				while((*p->xml != '>'))
-				{
-					i++; p->xml++;
-					if (p->xml >= p->xmlend)
-						return;
-				}
-				if(p->endeltfunc)
-					p->endeltfunc(p->data, elementname, i);
-				p->xml++;
-			}
-		}
-		else
-		{
-			p->xml++;
-		}
-	}
-}
-
-/* the parser must be initialized before calling this function */
-void parsexml(struct xmlparser * parser)
-{
-	parser->xml = parser->xmlstart;
-	parser->xmlend = parser->xmlstart + parser->xmlsize;
-	parseelt(parser);
-}
-
-
diff --git a/third-party/miniupnp/minixml.h b/user/transmission/third-party/miniupnp/minixml.h
deleted file mode 100644
index 857c70e..0000000
--- a/third-party/miniupnp/minixml.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* $Id: minixml.h,v 1.6 2006/11/30 11:47:21 nanard Exp $ */
-/* minimal xml parser
- *
- * Project : miniupnp
- * Website : http://miniupnp.free.fr/
- * Author : Thomas Bernard
- * Copyright (c) 2005 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution.
- * */
-#ifndef __MINIXML_H__
-#define __MINIXML_H__
-#define IS_WHITE_SPACE(c) ((c==' ') || (c=='\t') || (c=='\r') || (c=='\n'))
-
-/* if a callback function pointer is set to NULL,
- * the function is not called */
-struct xmlparser {
-	const char *xmlstart;
-	const char *xmlend;
-	const char *xml;	/* pointer to current character */
-	int xmlsize;
-	void * data;
-	void (*starteltfunc) (void *, const char *, int);
-	void (*endeltfunc) (void *, const char *, int);
-	void (*datafunc) (void *, const char *, int);
-	void (*attfunc) (void *, const char *, int, const char *, int);
-};
-
-/* parsexml()
- * the xmlparser structure must be initialized before the call
- * the following structure members have to be initialized :
- * xmlstart, xmlsize, data, *func
- * xml is for internal usage, xmlend is computed automatically */
-void parsexml(struct xmlparser *);
-
-#endif
-
diff --git a/third-party/miniupnp/updateminiupnpcstrings.sh b/user/transmission/third-party/miniupnp/updateminiupnpcstrings.sh
deleted file mode 100755
index a798184..0000000
--- a/third-party/miniupnp/updateminiupnpcstrings.sh
+++ /dev/null
@@ -1,29 +0,0 @@
-#! /bin/sh
-# $Id: updateminiupnpcstrings.sh,v 1.4 2009/07/29 08:34:01 nanard Exp $
-
-TEMPLATE_FILE=$1
-OUTPUT_FILE=$2
-
-# detecting the OS name and version
-OS_NAME=`uname -s`
-OS_VERSION=`uname -r`
-if [ -f /etc/debian_version ]; then
-	OS_NAME=Debian
-	OS_VERSION=`cat /etc/debian_version`
-fi
-# use lsb_release (Linux Standard Base) when available
-if os_name=`lsb_release -i -s 2>/dev/null`; then
-    OS_NAME=$os_name
-    OS_VERSION=`lsb_release -r -s`
-fi
-
-echo "Detected OS [$OS_NAME] version [$OS_VERSION]"
-
-EXPR="s|OS_STRING \".*\"|OS_STRING \"${OS_NAME}/${OS_VERSION}\"|"
-#echo $EXPR
-#echo "Backing up $OUTPUT_FILE to $OUTPUT_FILE.bak."
-#cp $OUTPUT_FILE $OUTPUT_FILE.bak
-test -f ${TEMPLATE_FILE}
-echo "setting OS_STRING macro value to ${OS_NAME}/${OS_VERSION} in $OUTPUT_FILE."
-sed -e "$EXPR" < $TEMPLATE_FILE > $OUTPUT_FILE
-
diff --git a/third-party/miniupnp/upnpcommands.c b/user/transmission/third-party/miniupnp/upnpcommands.c
deleted file mode 100644
index 20e48d8..0000000
--- a/third-party/miniupnp/upnpcommands.c
+++ /dev/null
@@ -1,611 +0,0 @@
-/* $Id: upnpcommands.c,v 1.26 2010/06/09 10:59:09 nanard Exp $ */
-/* Project : miniupnp
- * Author : Thomas Bernard
- * Copyright (c) 2005-2010 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided in this distribution.
- * */
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include "upnpcommands.h"
-#include "miniupnpc.h"
-
-static UNSIGNED_INTEGER
-my_atoui(const char * s)
-{
-	return s ? ((UNSIGNED_INTEGER)STRTOUI(s, NULL, 0)) : 0;
-}
-
-/*
- * */
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalBytesSent(const char * controlURL,
-					const char * servicetype)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	unsigned int r = 0;
-	char * p;
-	if(simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalBytesSent", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	ParseNameValue(buffer, bufsize, &pdata);
-	/*DisplayNameValueList(buffer, bufsize);*/
-	p = GetValueFromNameValueList(&pdata, "NewTotalBytesSent");
-	r = my_atoui(p);
-	ClearNameValueList(&pdata);
-	return r;
-}
-
-/*
- * */
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalBytesReceived(const char * controlURL,
-						const char * servicetype)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	unsigned int r = 0;
-	char * p;
-	if(simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalBytesReceived", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	ParseNameValue(buffer, bufsize, &pdata);
-	/*DisplayNameValueList(buffer, bufsize);*/
-	p = GetValueFromNameValueList(&pdata, "NewTotalBytesReceived");
-	r = my_atoui(p);
-	ClearNameValueList(&pdata);
-	return r;
-}
-
-/*
- * */
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalPacketsSent(const char * controlURL,
-						const char * servicetype)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	unsigned int r = 0;
-	char * p;
-	if(simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalPacketsSent", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	ParseNameValue(buffer, bufsize, &pdata);
-	/*DisplayNameValueList(buffer, bufsize);*/
-	p = GetValueFromNameValueList(&pdata, "NewTotalPacketsSent");
-	r = my_atoui(p);
-	ClearNameValueList(&pdata);
-	return r;
-}
-
-/*
- * */
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalPacketsReceived(const char * controlURL,
-						const char * servicetype)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	unsigned int r = 0;
-	char * p;
-	if(simpleUPnPcommand(-1, controlURL, servicetype, "GetTotalPacketsReceived", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	ParseNameValue(buffer, bufsize, &pdata);
-	/*DisplayNameValueList(buffer, bufsize);*/
-	p = GetValueFromNameValueList(&pdata, "NewTotalPacketsReceived");
-	r = my_atoui(p);
-	ClearNameValueList(&pdata);
-	return r;
-}
-
-/* UPNP_GetStatusInfo() call the corresponding UPNP method
- * returns the current status and uptime */
-LIBSPEC int
-UPNP_GetStatusInfo(const char * controlURL,
-				const char * servicetype,
-				char * status, 
-				unsigned int * uptime,
-				char * lastconnerror)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	char * p;
-	char * up;
-	char * err;
-	int ret = UPNPCOMMAND_UNKNOWN_ERROR;
-
-	if(!status && !uptime)
-		return UPNPCOMMAND_INVALID_ARGS;
-
-	if(simpleUPnPcommand(-1, controlURL, servicetype, "GetStatusInfo", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	ParseNameValue(buffer, bufsize, &pdata);
-	/*DisplayNameValueList(buffer, bufsize);*/
-	up = GetValueFromNameValueList(&pdata, "NewUptime");
-	p = GetValueFromNameValueList(&pdata, "NewConnectionStatus");
-	err = GetValueFromNameValueList(&pdata, "NewLastConnectionError");
-	if(p && up)
-	  ret = UPNPCOMMAND_SUCCESS;
-
-	if(status) {
-		if(p){
-			strncpy(status, p, 64 );
-			status[63] = '\0';
-		}else
-			status[0]= '\0';
-	}
-
-	if(uptime) {
-		if(up)
-			sscanf(up,"%u",uptime);
-		else
-			uptime = 0;
-	}
-
-	if(lastconnerror) {
-		if(err) {
-			strncpy(lastconnerror, err, 64 );
-			lastconnerror[63] = '\0';
-		} else
-			lastconnerror[0] = '\0';
-	}
-
-	p = GetValueFromNameValueList(&pdata, "errorCode");
-	if(p) {
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(p, "%d", &ret);
-	}
-	ClearNameValueList(&pdata);
-	return ret;
-}
-
-/* UPNP_GetConnectionTypeInfo() call the corresponding UPNP method
- * returns the connection type */
-LIBSPEC int
-UPNP_GetConnectionTypeInfo(const char * controlURL,
-                           const char * servicetype,
-                           char * connectionType)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	char * p;
-	int ret = UPNPCOMMAND_UNKNOWN_ERROR;
-
-	if(!connectionType)
-		return UPNPCOMMAND_INVALID_ARGS;
-
-	if(simpleUPnPcommand(-1, controlURL, servicetype,
-	                  "GetConnectionTypeInfo", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	ParseNameValue(buffer, bufsize, &pdata);
-	p = GetValueFromNameValueList(&pdata, "NewConnectionType");
-	/*p = GetValueFromNameValueList(&pdata, "NewPossibleConnectionTypes");*/
-	/* PossibleConnectionTypes will have several values.... */
-	if(p) {
-		strncpy(connectionType, p, 64 );
-		connectionType[63] = '\0';
-		ret = UPNPCOMMAND_SUCCESS;
-	} else
-		connectionType[0] = '\0';
-	p = GetValueFromNameValueList(&pdata, "errorCode");
-	if(p) {
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(p, "%d", &ret);
-	}
-	ClearNameValueList(&pdata);
-	return ret;
-}
-
-/* UPNP_GetLinkLayerMaxBitRate() call the corresponding UPNP method.
- * Returns 2 values: Downloadlink bandwidth and Uplink bandwidth.
- * One of the values can be null 
- * Note : GetLinkLayerMaxBitRates belongs to WANPPPConnection:1 only 
- * We can use the GetCommonLinkProperties from WANCommonInterfaceConfig:1 */
-LIBSPEC int
-UPNP_GetLinkLayerMaxBitRates(const char * controlURL,
-                             const char * servicetype,
-                             unsigned int * bitrateDown,
-                             unsigned int* bitrateUp)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	int ret = UPNPCOMMAND_UNKNOWN_ERROR;
-	char * down;
-	char * up;
-	char * p;
-
-	if(!bitrateDown && !bitrateUp)
-		return UPNPCOMMAND_INVALID_ARGS;
-
-	/* shouldn't we use GetCommonLinkProperties ? */
-	if(simpleUPnPcommand(-1, controlURL, servicetype,
-	                  "GetCommonLinkProperties", 0, buffer, &bufsize) < 0) {
-	                  /*"GetLinkLayerMaxBitRates", 0, buffer, &bufsize);*/
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	/*DisplayNameValueList(buffer, bufsize);*/
-	ParseNameValue(buffer, bufsize, &pdata);
-	/*down = GetValueFromNameValueList(&pdata, "NewDownstreamMaxBitRate");*/
-	/*up = GetValueFromNameValueList(&pdata, "NewUpstreamMaxBitRate");*/
-	down = GetValueFromNameValueList(&pdata, "NewLayer1DownstreamMaxBitRate");
-	up = GetValueFromNameValueList(&pdata, "NewLayer1UpstreamMaxBitRate");
-	/*GetValueFromNameValueList(&pdata, "NewWANAccessType");*/
-	/*GetValueFromNameValueList(&pdata, "NewPhysicalLinkSatus");*/
-	if(down && up)
-		ret = UPNPCOMMAND_SUCCESS;
-
-	if(bitrateDown) {
-		if(down)
-			sscanf(down,"%u",bitrateDown);
-		else
-			*bitrateDown = 0;
-	}
-
-	if(bitrateUp) {
-		if(up)
-			sscanf(up,"%u",bitrateUp);
-		else
-			*bitrateUp = 0;
-	}
-	p = GetValueFromNameValueList(&pdata, "errorCode");
-	if(p) {
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(p, "%d", &ret);
-	}
-	ClearNameValueList(&pdata);
-	return ret;
-}
-
-
-/* UPNP_GetExternalIPAddress() call the corresponding UPNP method.
- * if the third arg is not null the value is copied to it.
- * at least 16 bytes must be available
- * 
- * Return values :
- * 0 : SUCCESS
- * NON ZERO : ERROR Either an UPnP error code or an unknown error.
- *
- * 402 Invalid Args - See UPnP Device Architecture section on Control.
- * 501 Action Failed - See UPnP Device Architecture section on Control.
- */
-LIBSPEC int
-UPNP_GetExternalIPAddress(const char * controlURL,
-                          const char * servicetype,
-                          char * extIpAdd)
-{
-	struct NameValueParserData pdata;
-	char buffer[4096];
-	int bufsize = 4096;
-	char * p;
-	int ret = UPNPCOMMAND_UNKNOWN_ERROR;
-
-	if(!extIpAdd || !controlURL || !servicetype)
-		return UPNPCOMMAND_INVALID_ARGS;
-
-	if(simpleUPnPcommand(-1, controlURL, servicetype, "GetExternalIPAddress", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	/*DisplayNameValueList(buffer, bufsize);*/
-	ParseNameValue(buffer, bufsize, &pdata);
-	/*printf("external ip = %s\n", GetValueFromNameValueList(&pdata, "NewExternalIPAddress") );*/
-	p = GetValueFromNameValueList(&pdata, "NewExternalIPAddress");
-	if(p) {
-		strncpy(extIpAdd, p, 16 );
-		extIpAdd[15] = '\0';
-		ret = UPNPCOMMAND_SUCCESS;
-	} else
-		extIpAdd[0] = '\0';
-
-	p = GetValueFromNameValueList(&pdata, "errorCode");
-	if(p) {
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(p, "%d", &ret);
-	}
-
-	ClearNameValueList(&pdata);
-	return ret;
-}
-
-LIBSPEC int
-UPNP_AddPortMapping(const char * controlURL, const char * servicetype,
-                    const char * extPort,
-					const char * inPort,
-					const char * inClient,
-					const char * desc,
-					const char * proto,
-                    const char * remoteHost)
-{
-	struct UPNParg * AddPortMappingArgs;
-	char buffer[4096];
-	int bufsize = 4096;
-	struct NameValueParserData pdata;
-	const char * resVal;
-	int ret;
-
-	if(!inPort || !inClient || !proto || !extPort)
-		return UPNPCOMMAND_INVALID_ARGS;
-
-	AddPortMappingArgs = calloc(9, sizeof(struct UPNParg));
-	AddPortMappingArgs[0].elt = "NewRemoteHost";
-	AddPortMappingArgs[0].val = remoteHost;
-	AddPortMappingArgs[1].elt = "NewExternalPort";
-	AddPortMappingArgs[1].val = extPort;
-	AddPortMappingArgs[2].elt = "NewProtocol";
-	AddPortMappingArgs[2].val = proto;
-	AddPortMappingArgs[3].elt = "NewInternalPort";
-	AddPortMappingArgs[3].val = inPort;
-	AddPortMappingArgs[4].elt = "NewInternalClient";
-	AddPortMappingArgs[4].val = inClient;
-	AddPortMappingArgs[5].elt = "NewEnabled";
-	AddPortMappingArgs[5].val = "1";
-	AddPortMappingArgs[6].elt = "NewPortMappingDescription";
-	AddPortMappingArgs[6].val = desc?desc:"libminiupnpc";
-	AddPortMappingArgs[7].elt = "NewLeaseDuration";
-	AddPortMappingArgs[7].val = "0";
-	if(simpleUPnPcommand(-1, controlURL, servicetype, "AddPortMapping", AddPortMappingArgs, buffer, &bufsize) < 0) {
-		free(AddPortMappingArgs);
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	/*DisplayNameValueList(buffer, bufsize);*/
-	/*buffer[bufsize] = '\0';*/
-	/*puts(buffer);*/
-	ParseNameValue(buffer, bufsize, &pdata);
-	resVal = GetValueFromNameValueList(&pdata, "errorCode");
-	if(resVal) {
-		/*printf("AddPortMapping errorCode = '%s'\n", resVal); */
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(resVal, "%d", &ret);
-	} else {
-		ret = UPNPCOMMAND_SUCCESS;
-	}
-	ClearNameValueList(&pdata);
-	free(AddPortMappingArgs);
-	return ret;
-}
-
-LIBSPEC int
-UPNP_DeletePortMapping(const char * controlURL, const char * servicetype,
-                       const char * extPort, const char * proto,
-                       const char * remoteHost)
-{
-	/*struct NameValueParserData pdata;*/
-	struct UPNParg * DeletePortMappingArgs;
-	char buffer[4096];
-	int bufsize = 4096;
-	struct NameValueParserData pdata;
-	const char * resVal;
-	int ret;
-
-	if(!extPort || !proto)
-		return UPNPCOMMAND_INVALID_ARGS;
-
-	DeletePortMappingArgs = calloc(4, sizeof(struct UPNParg));
-	DeletePortMappingArgs[0].elt = "NewRemoteHost";
-	DeletePortMappingArgs[0].val = remoteHost;
-	DeletePortMappingArgs[1].elt = "NewExternalPort";
-	DeletePortMappingArgs[1].val = extPort;
-	DeletePortMappingArgs[2].elt = "NewProtocol";
-	DeletePortMappingArgs[2].val = proto;
-	if(simpleUPnPcommand(-1, controlURL, servicetype,
-	                     "DeletePortMapping",
-	                     DeletePortMappingArgs, buffer, &bufsize) < 0 ) {
-		free(DeletePortMappingArgs);
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	/*DisplayNameValueList(buffer, bufsize);*/
-	ParseNameValue(buffer, bufsize, &pdata);
-	resVal = GetValueFromNameValueList(&pdata, "errorCode");
-	if(resVal) {
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(resVal, "%d", &ret);
-	} else {
-		ret = UPNPCOMMAND_SUCCESS;
-	}
-	ClearNameValueList(&pdata);
-	free(DeletePortMappingArgs);
-	return ret;
-}
-
-LIBSPEC int
-UPNP_GetGenericPortMappingEntry(const char * controlURL,
-                                const char * servicetype,
-							 const char * index,
-							 char * extPort,
-							 char * intClient,
-							 char * intPort,
-							 char * protocol,
-							 char * desc,
-							 char * enabled,
-							 char * rHost,
-							 char * duration)
-{
-	struct NameValueParserData pdata;
-	struct UPNParg * GetPortMappingArgs;
-	char buffer[4096];
-	int bufsize = 4096;
-	char * p;
-	int r = UPNPCOMMAND_UNKNOWN_ERROR;
-	if(!index)
-		return UPNPCOMMAND_INVALID_ARGS;
-	intClient[0] = '\0';
-	intPort[0] = '\0';
-	GetPortMappingArgs = calloc(2, sizeof(struct UPNParg));
-	GetPortMappingArgs[0].elt = "NewPortMappingIndex";
-	GetPortMappingArgs[0].val = index;
-	if(simpleUPnPcommand(-1, controlURL, servicetype,
-	                  "GetGenericPortMappingEntry",
-					  GetPortMappingArgs, buffer, &bufsize) < 0) {
-		free(GetPortMappingArgs);
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	ParseNameValue(buffer, bufsize, &pdata);
-	p = GetValueFromNameValueList(&pdata, "NewRemoteHost");
-	if(p && rHost)
-	{
-		strncpy(rHost, p, 64);
-		rHost[63] = '\0';
-	}
-	p = GetValueFromNameValueList(&pdata, "NewExternalPort");
-	if(p && extPort)
-	{
-		strncpy(extPort, p, 6);
-		extPort[5] = '\0';
-		r = UPNPCOMMAND_SUCCESS;
-	}
-	p = GetValueFromNameValueList(&pdata, "NewProtocol");
-	if(p && protocol)
-	{
-		strncpy(protocol, p, 4);
-		protocol[3] = '\0';
-	}
-	p = GetValueFromNameValueList(&pdata, "NewInternalClient");
-	if(p && intClient)
-	{
-		strncpy(intClient, p, 16);
-		intClient[15] = '\0';
-		r = 0;
-	}
-	p = GetValueFromNameValueList(&pdata, "NewInternalPort");
-	if(p && intPort)
-	{
-		strncpy(intPort, p, 6);
-		intPort[5] = '\0';
-	}
-	p = GetValueFromNameValueList(&pdata, "NewEnabled");
-	if(p && enabled)
-	{
-		strncpy(enabled, p, 4);
-		enabled[3] = '\0';
-	}
-	p = GetValueFromNameValueList(&pdata, "NewPortMappingDescription");
-	if(p && desc)
-	{
-		strncpy(desc, p, 80);
-		desc[79] = '\0';
-	}
-	p = GetValueFromNameValueList(&pdata, "NewLeaseDuration");
-	if(p && duration)
-	{
-		strncpy(duration, p, 16);
-		duration[15] = '\0';
-	}
-	p = GetValueFromNameValueList(&pdata, "errorCode");
-	if(p) {
-		r = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(p, "%d", &r);
-	}
-	ClearNameValueList(&pdata);
-	free(GetPortMappingArgs);
-	return r;
-}
-
-LIBSPEC int
-UPNP_GetPortMappingNumberOfEntries(const char * controlURL,
-                                   const char * servicetype,
-                                   unsigned int * numEntries)
-{
- 	struct NameValueParserData pdata;
- 	char buffer[4096];
- 	int bufsize = 4096;
- 	char* p;
-	int ret = UPNPCOMMAND_UNKNOWN_ERROR;
- 	if(simpleUPnPcommand(-1, controlURL, servicetype, "GetPortMappingNumberOfEntries", 0, buffer, &bufsize) < 0) {
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-#ifdef DEBUG
-	DisplayNameValueList(buffer, bufsize);
-#endif
- 	ParseNameValue(buffer, bufsize, &pdata);
-
- 	p = GetValueFromNameValueList(&pdata, "NewPortMappingNumberOfEntries");
- 	if(numEntries && p) {
-		*numEntries = 0;
- 		sscanf(p, "%u", numEntries);
-		ret = UPNPCOMMAND_SUCCESS;
- 	}
-
-	p = GetValueFromNameValueList(&pdata, "errorCode");
-	if(p) {
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(p, "%d", &ret);
-	}
-
- 	ClearNameValueList(&pdata);
-	return ret;
-}
-
-/* UPNP_GetSpecificPortMappingEntry retrieves an existing port mapping
- * the result is returned in the intClient and intPort strings
- * please provide 16 and 6 bytes of data */
-LIBSPEC int
-UPNP_GetSpecificPortMappingEntry(const char * controlURL,
-                                 const char * servicetype,
-                                 const char * extPort,
-							     const char * proto,
-                                 char * intClient,
-                                 char * intPort)
-{
-	struct NameValueParserData pdata;
-	struct UPNParg * GetPortMappingArgs;
-	char buffer[4096];
-	int bufsize = 4096;
-	char * p;
-	int ret = UPNPCOMMAND_UNKNOWN_ERROR;
-
-	if(!intPort || !intClient || !extPort || !proto)
-		return UPNPCOMMAND_INVALID_ARGS;
-
-	GetPortMappingArgs = calloc(4, sizeof(struct UPNParg));
-	GetPortMappingArgs[0].elt = "NewRemoteHost";
-	GetPortMappingArgs[1].elt = "NewExternalPort";
-	GetPortMappingArgs[1].val = extPort;
-	GetPortMappingArgs[2].elt = "NewProtocol";
-	GetPortMappingArgs[2].val = proto;
-	if(simpleUPnPcommand(-1, controlURL, servicetype,
-	                     "GetSpecificPortMappingEntry",
-	                     GetPortMappingArgs, buffer, &bufsize) < 0) {
-		free(GetPortMappingArgs);
-		return UPNPCOMMAND_HTTP_ERROR;
-	}
-	/*DisplayNameValueList(buffer, bufsize);*/
-	ParseNameValue(buffer, bufsize, &pdata);
-
-	p = GetValueFromNameValueList(&pdata, "NewInternalClient");
-	if(p) {
-		strncpy(intClient, p, 16);
-		intClient[15] = '\0';
-		ret = UPNPCOMMAND_SUCCESS;
-	} else
-		intClient[0] = '\0';
-
-	p = GetValueFromNameValueList(&pdata, "NewInternalPort");
-	if(p) {
-		strncpy(intPort, p, 6);
-		intPort[5] = '\0';
-	} else
-		intPort[0] = '\0';
-
-	p = GetValueFromNameValueList(&pdata, "errorCode");
-	if(p) {
-		ret = UPNPCOMMAND_UNKNOWN_ERROR;
-		sscanf(p, "%d", &ret);
-	}
-
-	ClearNameValueList(&pdata);
-	free(GetPortMappingArgs);
-	return ret;
-}
-
-
diff --git a/third-party/miniupnp/upnpcommands.h b/user/transmission/third-party/miniupnp/upnpcommands.h
deleted file mode 100644
index 5561bea..0000000
--- a/third-party/miniupnp/upnpcommands.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/* $Id: upnpcommands.h,v 1.18 2010/06/09 10:59:09 nanard Exp $ */
-/* Miniupnp project : http://miniupnp.free.fr/
- * Author : Thomas Bernard
- * Copyright (c) 2005-2010 Thomas Bernard
- * This software is subject to the conditions detailed in the
- * LICENCE file provided within this distribution */
-#ifndef __UPNPCOMMANDS_H__
-#define __UPNPCOMMANDS_H__
-
-#include "upnpreplyparse.h"
-#include "declspec.h"
-
-/* MiniUPnPc return codes : */
-#define UPNPCOMMAND_SUCCESS (0)
-#define UPNPCOMMAND_UNKNOWN_ERROR (-1)
-#define UPNPCOMMAND_INVALID_ARGS (-2)
-#define UPNPCOMMAND_HTTP_ERROR (-3)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)
-#define UNSIGNED_INTEGER unsigned long long
-#define STRTOUI	strtoull
-#else
-#define UNSIGNED_INTEGER unsigned int
-#define STRTOUI	strtoul
-#endif
-
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalBytesSent(const char * controlURL,
-					const char * servicetype);
-
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalBytesReceived(const char * controlURL,
-						const char * servicetype);
-
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalPacketsSent(const char * controlURL,
-					const char * servicetype);
-
-LIBSPEC UNSIGNED_INTEGER
-UPNP_GetTotalPacketsReceived(const char * controlURL,
-					const char * servicetype);
-
-/* UPNP_GetStatusInfo()
- * status and lastconnerror are 64 byte buffers
- * Return values :
- * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR
- * or a UPnP Error code */
-LIBSPEC int
-UPNP_GetStatusInfo(const char * controlURL,
-			       const char * servicetype,
-				   char * status,
-				   unsigned int * uptime,
-                   char * lastconnerror);
-
-/* UPNP_GetConnectionTypeInfo()
- * argument connectionType is a 64 character buffer
- * Return Values :
- * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR
- * or a UPnP Error code */
-LIBSPEC int
-UPNP_GetConnectionTypeInfo(const char * controlURL,
-                           const char * servicetype,
-						   char * connectionType);
-
-/* UPNP_GetExternalIPAddress() call the corresponding UPNP method.
- * if the third arg is not null the value is copied to it.
- * at least 16 bytes must be available 
- *
- * Return values :
- * 0 : SUCCESS
- * NON ZERO : ERROR Either an UPnP error code or an unknown error.
- * 
- * possible UPnP Errors :
- * 402 Invalid Args - See UPnP Device Architecture section on Control.
- * 501 Action Failed - See UPnP Device Architecture section on Control. */
-LIBSPEC int
-UPNP_GetExternalIPAddress(const char * controlURL,
-                          const char * servicetype,
-                          char * extIpAdd);
-
-/* UPNP_GetLinkLayerMaxBitRates()
- * call WANCommonInterfaceConfig:1#GetCommonLinkProperties
- *
- * return values :
- * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR
- * or a UPnP Error Code. */
-LIBSPEC int
-UPNP_GetLinkLayerMaxBitRates(const char* controlURL,
-							const char* servicetype,
-							unsigned int * bitrateDown,
-							unsigned int * bitrateUp);
-
-/* UPNP_AddPortMapping()
- * if desc is NULL, it will be defaulted to "libminiupnpc"
- * remoteHost is usually NULL because IGD don't support it.
- *
- * Return values :
- * 0 : SUCCESS
- * NON ZERO : ERROR. Either an UPnP error code or an unknown error.
- * 
- * List of possible UPnP errors for AddPortMapping :
- * errorCode errorDescription (short) - Description (long)
- * 402 Invalid Args - See UPnP Device Architecture section on Control.
- * 501 Action Failed - See UPnP Device Architecture section on Control.
- * 715 WildCardNotPermittedInSrcIP - The source IP address cannot be
- *                                   wild-carded
- * 716 WildCardNotPermittedInExtPort - The external port cannot be wild-carded
- * 718 ConflictInMappingEntry - The port mapping entry specified conflicts
- *                     with a mapping assigned previously to another client
- * 724 SamePortValuesRequired - Internal and External port values
- *                              must be the same 
- * 725 OnlyPermanentLeasesSupported - The NAT implementation only supports
- *                  permanent lease times on port mappings
- * 726 RemoteHostOnlySupportsWildcard - RemoteHost must be a wildcard
- *                             and cannot be a specific IP address or DNS name
- * 727 ExternalPortOnlySupportsWildcard - ExternalPort must be a wildcard and
- *                                        cannot be a specific port value */
-LIBSPEC int
-UPNP_AddPortMapping(const char * controlURL, const char * servicetype,
-                    const char * extPort,
-				    const char * inPort,
-					const char * inClient,
-					const char * desc,
-                    const char * proto,
-                    const char * remoteHost);
-
-/* UPNP_DeletePortMapping()
- * Use same argument values as what was used for AddPortMapping().
- * remoteHost is usually NULL because IGD don't support it.
- * Return Values :
- * 0 : SUCCESS
- * NON ZERO : error. Either an UPnP error code or an undefined error.
- *
- * List of possible UPnP errors for DeletePortMapping :
- * 402 Invalid Args - See UPnP Device Architecture section on Control.
- * 714 NoSuchEntryInArray - The specified value does not exist in the array */
-LIBSPEC int
-UPNP_DeletePortMapping(const char * controlURL, const char * servicetype,
-                       const char * extPort, const char * proto,
-                       const char * remoteHost);
-
-/* UPNP_GetPortMappingNumberOfEntries()
- * not supported by all routers */
-LIBSPEC int
-UPNP_GetPortMappingNumberOfEntries(const char* controlURL, const char* servicetype, unsigned int * num);
-
-/* UPNP_GetSpecificPortMappingEntry retrieves an existing port mapping
- * the result is returned in the intClient and intPort strings
- * please provide 16 and 6 bytes of data
- *
- * return value :
- * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR
- * or a UPnP Error Code. */
-LIBSPEC int
-UPNP_GetSpecificPortMappingEntry(const char * controlURL,
-                                 const char * servicetype,
-                                 const char * extPort,
-                                 const char * proto,
-                                 char * intClient,
-                                 char * intPort);
-
-/* UPNP_GetGenericPortMappingEntry()
- *
- * return value :
- * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR
- * or a UPnP Error Code.
- *
- * Possible UPNP Error codes :
- * 402 Invalid Args - See UPnP Device Architecture section on Control.
- * 713 SpecifiedArrayIndexInvalid - The specified array index is out of bounds
- */
-LIBSPEC int
-UPNP_GetGenericPortMappingEntry(const char * controlURL,
-                                const char * servicetype,
-								const char * index,
-								char * extPort,
-								char * intClient,
-								char * intPort,
-								char * protocol,
-								char * desc,
-								char * enabled,
-								char * rHost,
-								char * duration);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
diff --git a/third-party/miniupnp/upnpreplyparse.c b/user/transmission/third-party/miniupnp/upnpreplyparse.c
deleted file mode 100644
index c72b4c8..0000000
--- a/third-party/miniupnp/upnpreplyparse.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/* $Id: upnpreplyparse.c,v 1.10 2008/02/21 13:05:27 nanard Exp $ */
-/* MiniUPnP project
- * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006 Thomas Bernard 
- * This software is subject to the conditions detailed
- * in the LICENCE file provided within the distribution */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "upnpreplyparse.h"
-#include "minixml.h"
-
-static void
-NameValueParserStartElt(void * d, const char * name, int l)
-{
-    struct NameValueParserData * data = (struct NameValueParserData *)d;
-    if(l>63)
-        l = 63;
-    memcpy(data->curelt, name, l);
-    data->curelt[l] = '\0';
-}
-
-static void
-NameValueParserGetData(void * d, const char * datas, int l)
-{
-    struct NameValueParserData * data = (struct NameValueParserData *)d;
-    struct NameValue * nv;
-    nv = malloc(sizeof(struct NameValue));
-    if(l>63)
-        l = 63;
-    strncpy(nv->name, data->curelt, 64);
-	nv->name[63] = '\0';
-    memcpy(nv->value, datas, l);
-    nv->value[l] = '\0';
-    LIST_INSERT_HEAD( &(data->head), nv, entries);
-}
-
-void
-ParseNameValue(const char * buffer, int bufsize,
-                    struct NameValueParserData * data)
-{
-    struct xmlparser parser;
-    LIST_INIT(&(data->head));
-    /* init xmlparser object */
-    parser.xmlstart = buffer;
-    parser.xmlsize = bufsize;
-    parser.data = data;
-    parser.starteltfunc = NameValueParserStartElt;
-    parser.endeltfunc = 0;
-    parser.datafunc = NameValueParserGetData;
-	parser.attfunc = 0;
-    parsexml(&parser);
-}
-
-void
-ClearNameValueList(struct NameValueParserData * pdata)
-{
-    struct NameValue * nv;
-    while((nv = pdata->head.lh_first) != NULL)
-    {
-        LIST_REMOVE(nv, entries);
-        free(nv);
-    }
-}
-
-char * 
-GetValueFromNameValueList(struct NameValueParserData * pdata,
-                          const char * Name)
-{
-    struct NameValue * nv;
-    char * p = NULL;
-    for(nv = pdata->head.lh_first;
-        (nv != NULL) && (p == NULL);
-        nv = nv->entries.le_next)
-    {
-        if(strcmp(nv->name, Name) == 0)
-            p = nv->value;
-    }
-    return p;
-}
-
-#if 0
-/* useless now that minixml ignores namespaces by itself */
-char *
-GetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,
-                                  const char * Name)
-{
-	struct NameValue * nv;
-	char * p = NULL;
-	char * pname;
-	for(nv = pdata->head.lh_first;
-	    (nv != NULL) && (p == NULL);
-		nv = nv->entries.le_next)
-	{
-		pname = strrchr(nv->name, ':');
-		if(pname)
-			pname++;
-		else
-			pname = nv->name;
-		if(strcmp(pname, Name)==0)
-			p = nv->value;
-	}
-	return p;
-}
-#endif
-
-/* debug all-in-one function 
- * do parsing then display to stdout */
-#ifdef DEBUG
-void
-DisplayNameValueList(char * buffer, int bufsize)
-{
-    struct NameValueParserData pdata;
-    struct NameValue * nv;
-    ParseNameValue(buffer, bufsize, &pdata);
-    for(nv = pdata.head.lh_first;
-        nv != NULL;
-        nv = nv->entries.le_next)
-    {
-        printf("%s = %s\n", nv->name, nv->value);
-    }
-    ClearNameValueList(&pdata);
-}
-#endif
-
diff --git a/third-party/miniupnp/upnpreplyparse.h b/user/transmission/third-party/miniupnp/upnpreplyparse.h
deleted file mode 100644
index fb7d453..0000000
--- a/third-party/miniupnp/upnpreplyparse.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* $Id: upnpreplyparse.h,v 1.10 2009/07/09 16:01:50 nanard Exp $ */
-/* MiniUPnP project
- * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
- * (c) 2006-2009 Thomas Bernard 
- * This software is subject to the conditions detailed
- * in the LICENCE file provided within the distribution */
-
-#ifndef __UPNPREPLYPARSE_H__
-#define __UPNPREPLYPARSE_H__
-
-#if defined(NO_SYS_QUEUE_H) || defined(WIN32) || defined(__HAIKU__) 
-#include "bsdqueue.h"
-#else
-#include <sys/queue.h>
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct NameValue {
-    LIST_ENTRY(NameValue) entries;
-    char name[64];
-    char value[64];
-};
-
-struct NameValueParserData {
-    LIST_HEAD(listhead, NameValue) head;
-    char curelt[64];
-};
-
-/* ParseNameValue() */
-void
-ParseNameValue(const char * buffer, int bufsize,
-               struct NameValueParserData * data);
-
-/* ClearNameValueList() */
-void
-ClearNameValueList(struct NameValueParserData * pdata);
-
-/* GetValueFromNameValueList() */
-char *
-GetValueFromNameValueList(struct NameValueParserData * pdata,
-                          const char * Name);
-
-/* GetValueFromNameValueListIgnoreNS() */
-char *
-GetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,
-                                  const char * Name);
-
-/* DisplayNameValueList() */
-#ifdef DEBUG
-void
-DisplayNameValueList(char * buffer, int bufsize);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
diff --git a/utils/Makefile.am b/user/transmission/utils/Makefile.am
index 896cb2b6..48f0b56 100644
--- a/utils/Makefile.am
+++ b/user/transmission/utils/Makefile.am
@@ -26,8 +26,6 @@ dist_man_MANS = \
 
 transmission_create_LDADD = \
     $(top_builddir)/libtransmission/libtransmission.a \
-    $(top_builddir)/third-party/miniupnp/libminiupnp.a \
-    $(top_builddir)/third-party/libnatpmp/libnatpmp.a \
     @INTLLIBS@ \
     @DHT_LIBS@ \
     @LIBUTP_LIBS@ \
