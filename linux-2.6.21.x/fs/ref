befs/befs.h:	char *iocharset;
befs/linuxvfs.c:	{Opt_charset, "iocharset=%s"},
befs/linuxvfs.c:	opts->iocharset = NULL;
befs/linuxvfs.c:			kfree(opts->iocharset);
befs/linuxvfs.c:			opts->iocharset = match_strdup(&args[0]);
befs/linuxvfs.c:			if (!opts->iocharset) {
befs/linuxvfs.c:						"iocharset string\n");
befs/linuxvfs.c:	kfree(BEFS_SB(sb)->mount_opts.iocharset);
befs/linuxvfs.c:	BEFS_SB(sb)->mount_opts.iocharset = NULL;
befs/linuxvfs.c:	if (befs_sb->mount_opts.iocharset) {
befs/linuxvfs.c:			   befs_sb->mount_opts.iocharset);
befs/linuxvfs.c:		befs_sb->nls = load_nls(befs_sb->mount_opts.iocharset);
befs/linuxvfs.c:					befs_sb->mount_opts.iocharset);
befs/ChangeLog:* Make directory lookup/read use the NLS if an iocharset is provided. [WD]
Binary file built-in.o matches
cifs/CHANGES:Add missing mount options including iocharset.  SMP fixes in write and open. 
cifs/README:  iocharset     Codepage used to convert local path names to and from
cifs/README:		names if the server supports it.  If iocharset is
cifs/connect.c:	char *iocharset;  /* local code page for mapping to and from Unicode */
cifs/connect.c:		} else if (strnicmp(data, "iocharset", 9) == 0) {
cifs/connect.c:				printk(KERN_WARNING "CIFS: invalid iocharset specified\n");
cifs/connect.c:					vol->iocharset = value;
cifs/connect.c:				/* if iocharset not set load_nls_default used by caller */
cifs/connect.c:				cFYI(1, ("iocharset set to %s",value));
cifs/connect.c:				printk(KERN_WARNING "CIFS: iocharset name too long.\n");
cifs/connect.c:	if(volume_info.iocharset == NULL) {
cifs/connect.c:		cifs_sb->local_nls = load_nls(volume_info.iocharset);
cifs/connect.c:			cERROR(1,("CIFS mount error: iocharset %s not found",volume_info.iocharset));
Binary file fat/cache.o matches
Binary file fat/inode.o matches
Binary file fat/fatent.o matches
Binary file fat/file.o matches
fat/inode.c:static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;
fat/inode.c:	if (sbi->options.iocharset != fat_default_iocharset) {
fat/inode.c:		kfree(sbi->options.iocharset);
fat/inode.c:		sbi->options.iocharset = fat_default_iocharset;
fat/inode.c:			seq_printf(m, ",iocharset=%s", sbi->nls_io->charset);
fat/inode.c:	{Opt_charset, "iocharset=%s"},
fat/inode.c:	char *iocharset;
fat/inode.c:	opts->iocharset = fat_default_iocharset;
fat/inode.c:			if (opts->iocharset != fat_default_iocharset)
fat/inode.c:				kfree(opts->iocharset);
fat/inode.c:			iocharset = match_strdup(&args[0]);
fat/inode.c:			if (!iocharset)
fat/inode.c:			opts->iocharset = iocharset;
fat/inode.c:	if (!strcmp(opts->iocharset, "utf8")) {
fat/inode.c:	/* FIXME: utf8 is using iocharset for upper/lower conversion */
fat/inode.c:		sbi->nls_io = load_nls(sbi->options.iocharset);
fat/inode.c:			       sbi->options.iocharset);
fat/inode.c:	if (sbi->options.iocharset != fat_default_iocharset)
fat/inode.c:		kfree(sbi->options.iocharset);
Binary file fat/built-in.o matches
Binary file fat/dir.o matches
fat/.inode.o.cmd:    $(wildcard include/config/fat/default/iocharset.h) \
Binary file fat/fat.o matches
Binary file fat/misc.o matches
hfs/super.c:		seq_printf(seq, ",iocharset=%s", sbi->nls_io->charset);
hfs/super.c:	opt_codepage, opt_iocharset,
hfs/super.c:	{ opt_iocharset, "iocharset=%s" },
hfs/super.c:		case opt_iocharset:
hfs/super.c:				printk(KERN_ERR "hfs: unable to change iocharset\n");
hfs/super.c:				printk(KERN_ERR "hfs: unable to load iocharset \"%s\"\n", p);
hfs/super.c:			printk(KERN_ERR "hfs: unable to load default iocharset\n");
isofs/isofs.h:	struct nls_table *s_nls_iocharset; /* Native language support table */
isofs/joliet.c:	nls = ISOFS_SB(inode->i_sb)->s_nls_iocharset;
isofs/inode.c:	if (sbi->s_nls_iocharset) {
isofs/inode.c:		unload_nls(sbi->s_nls_iocharset);
isofs/inode.c:		sbi->s_nls_iocharset = NULL;
isofs/inode.c:	char *iocharset;
isofs/inode.c:	Opt_iocharset, Opt_map_a, Opt_map_n, Opt_map_o, Opt_mode, Opt_nojoliet,
isofs/inode.c:	{Opt_iocharset, "iocharset=%s"},
isofs/inode.c:	popt->iocharset = NULL;
isofs/inode.c:		case Opt_iocharset:
isofs/inode.c:			popt->iocharset = match_strdup(&args[0]);
isofs/inode.c:	sbi->s_nls_iocharset = NULL;
isofs/inode.c:		char * p = opt.iocharset ? opt.iocharset : CONFIG_NLS_DEFAULT;
isofs/inode.c:		sbi->s_nls_iocharset = load_nls(p);
isofs/inode.c:		if (! sbi->s_nls_iocharset) {
isofs/inode.c:			if (opt.iocharset)
isofs/inode.c:			sbi->s_nls_iocharset = load_nls_default();
isofs/inode.c:	kfree(opt.iocharset);
isofs/inode.c:	if (sbi->s_nls_iocharset)
isofs/inode.c:		unload_nls(sbi->s_nls_iocharset);
isofs/inode.c:	kfree(opt.iocharset);
jfs/jfs_unicode.c:				"mount with iocharset=utf8 to access\n");
jfs/super.c:	Opt_integrity, Opt_nointegrity, Opt_iocharset, Opt_resize,
jfs/super.c:	{Opt_iocharset, "iocharset=%s"},
jfs/super.c:		case Opt_iocharset:
Kconfig:	string "Default iocharset for FAT"
Kconfig:	  with the "iocharset" mount option for FAT filesystems.
Kconfig:	  supports that, using the codepage and iocharset parameters.
Kconfig:	  supports that, using the codepage and iocharset parameters.
ncpfs/ioctl.c:/* Here we are select the iocharset and the codepage for NLS.
ncpfs/ioctl.c:	struct nls_table *iocharset;
ncpfs/ioctl.c:	iocharset = NULL;
ncpfs/ioctl.c:	user.iocharset[NCP_IOCSNAME_LEN] = 0;
ncpfs/ioctl.c:	if (!user.iocharset[0] || !strcmp(user.iocharset, "default")) {
ncpfs/ioctl.c:		iocharset = load_nls_default();
ncpfs/ioctl.c:	} else if (!strcmp(user.iocharset, "utf8")) {
ncpfs/ioctl.c:		iocharset = load_nls_default();
ncpfs/ioctl.c:		iocharset = load_nls(user.iocharset);
ncpfs/ioctl.c:		if (!iocharset) {
ncpfs/ioctl.c:	server->nls_io = iocharset;
ncpfs/ioctl.c:		strcpy(user.iocharset, "utf8");
ncpfs/ioctl.c:		strncpy(user.iocharset,	server->nls_io->charset, len);
ncpfs/ioctl.c:		user.iocharset[len] = 0;
ntfs/ChangeLog:	- Parse deprecated ntfs driver options (iocharset, show_sys_files,
ntfs/ChangeLog:	- Add -o iocharset as alias to -o nls for backwards compatibility.
ntfs/super.c:		else if (!strcmp(p, "nls") || !strcmp(p, "iocharset")) {
ntfs/super.c:			if (!strcmp(p, "iocharset"))
ntfs/super.c:				ntfs_warning(vol->sb, "Option iocharset is "
smbfs/inode.c:	{ "iocharset",	0, 'i' },
smbfs/inode.c:		seq_printf(s, ",iocharset=%s", mnt->codepage.local_name);
udf/super.c: *	iocharset=	Set the NLS character set
udf/super.c:	Opt_rootdir, Opt_utf8, Opt_iocharset,
udf/super.c:	{Opt_iocharset, "iocharset=%s"},
udf/super.c:			case Opt_iocharset:
udf/super.c:			"utf8 cannot be combined with iocharset\n");
Binary file vfat/namei.o matches
Binary file vfat/built-in.o matches
Binary file vfat/vfat.o matches
