--- cpu-probe.c.c	2010-11-25 23:52:07.964228001 +0600
+++ cpu-probe.c	2010-11-25 23:50:46.788228001 +0600
@@ -31,6 +31,21 @@
  */
 void (*cpu_wait)(void) = NULL;
 
+#if 0
+static void r3081_wait(void)
+{
+	unsigned long cfg = read_c0_conf();
+	write_c0_conf(cfg | R30XX_CONF_HALT);
+}
+
+static void r39xx_wait(void)
+{
+	local_irq_disable();
+	if (!need_resched())
+		write_c0_conf(read_c0_conf() | TX39_CONF_HALT);
+	local_irq_enable();
+}
+#endif
 
 /*
  * There is a race when WAIT instruction executed with interrupt
@@ -52,12 +67,63 @@
  * interrupt is requested" restriction in the MIPS32/MIPS64 architecture makes
  * using this version a gamble.
  */
+#if 0
+static void r4k_wait_irqoff(void)
+{
+	local_irq_disable();
+	if (!need_resched())
+		__asm__("	.set	mips3		\n"
+			"	wait			\n"
+			"	.set	mips0		\n");
+	local_irq_enable();
+}
+#endif
 
 /*
  * The RM7000 variant has to handle erratum 38.  The workaround is to not
  * have any pending stores when the WAIT instruction is executed.
  */
+#if 0
+static void rm7k_wait_irqoff(void)
+{
+	local_irq_disable();
+	if (!need_resched())
+		__asm__(
+		"	.set	push					\n"
+		"	.set	mips3					\n"
+		"	.set	noat					\n"
+		"	mfc0	$1, $12					\n"
+		"	sync						\n"
+		"	mtc0	$1, $12		# stalls until W stage	\n"
+		"	wait						\n"
+		"	mtc0	$1, $12		# stalls until W stage	\n"
+		"	.set	pop					\n");
+	local_irq_enable();
+}
+#endif
+
+#if 0
+/* The Au1xxx wait is available only if using 32khz counter or
+ * external timer source, but specifically not CP0 Counter. */
+int allow_au1k_wait;
 
+static void au1k_wait(void)
+{
+	/* using the wait instruction makes CP0 counter unusable */
+	__asm__("	.set	mips3			\n"
+		"	cache	0x14, 0(%0)		\n"
+		"	cache	0x14, 32(%0)		\n"
+		"	sync				\n"
+		"	nop				\n"
+		"	wait				\n"
+		"	nop				\n"
+		"	nop				\n"
+		"	nop				\n"
+		"	nop				\n"
+		"	.set	mips0			\n"
+		: : "r" (au1k_wait));
+}
+#endif
 
 static int __initdata nowait = 0;
 
@@ -78,6 +144,7 @@
 		printk("Wait instruction disabled.\n");
 		return;
 	}
+#if 1 /* cfho, we only consider AR71xx */
         switch (c->cputype) {
         case CPU_24K:
                 cpu_wait = r4k_wait;
@@ -86,6 +153,55 @@
         default:
                 break;
         }
+#else
+        switch (c->cputype) {
+	case CPU_R3081:
+	case CPU_R3081E:
+		cpu_wait = r3081_wait;
+		break;
+	case CPU_TX3927:
+		cpu_wait = r39xx_wait;
+		break;
+	case CPU_R4200:
+/*	case CPU_R4300: */
+	case CPU_R4600:
+	case CPU_R4640:
+	case CPU_R4650:
+	case CPU_R4700:
+	case CPU_R5000:
+	case CPU_NEVADA:
+	case CPU_RM7000:
+	case CPU_4KC:
+	case CPU_4KEC:
+	case CPU_4KSC:
+	case CPU_5KC:
+/*	case CPU_20KC:*/
+	case CPU_24K:
+	case CPU_25KF:
+	case CPU_34K:
+	case CPU_74K:
+ 	case CPU_PR4450:
+		cpu_wait = r4k_wait;
+		break;
+	case CPU_TX49XX:
+		cpu_wait = r4k_wait_irqoff;
+		break;
+	case CPU_AU1000:
+	case CPU_AU1100:
+	case CPU_AU1500:
+	case CPU_AU1550:
+	case CPU_AU1200:
+		if (allow_au1k_wait)
+			cpu_wait = au1k_wait;
+		break;
+	case CPU_RM9000:
+		if ((c->processor_id & 0x00ff) >= 0x40)
+			cpu_wait = r4k_wait;
+		break;
+	default:
+		break;
+	}
+#endif
 }
 
 void __init check_bugs32(void)
@@ -229,6 +345,20 @@
 			     MIPS_CPU_LLSC;
 		c->tlbsize = 48;
 		break;
+	#if 0
+ 	case PRID_IMP_R4650:
+		/*
+		 * This processor doesn't have an MMU, so it's not
+		 * "real easy" to run Linux on it. It is left purely
+		 * for documentation.  Commented out because it shares
+		 * it's c0_prid id number with the TX3900.
+		 */
+		c->cputype = CPU_R4650;
+	 	c->isa_level = MIPS_CPU_ISA_III;
+		c->options = R4K_OPTS | MIPS_CPU_FPU | MIPS_CPU_LLSC;
+	        c->tlbsize = 48;
+		break;
+	#endif
 	case PRID_IMP_TX39:
 		c->isa_level = MIPS_CPU_ISA_I;
 		c->options = MIPS_CPU_TLB | MIPS_CPU_TX39_CACHE;
@@ -630,6 +760,7 @@
         
 	c->processor_id = read_c0_prid();
 
+#if 1 /* cfho 2009-1020, we only probe MIPs CPU without FPU */
         switch (c->processor_id & 0xff0000) {
         case PRID_COMP_MIPS:
                 cpu_probe_mips(c);
@@ -638,6 +769,41 @@
                 c->cputype = CPU_UNKNOWN;
         }
 
+#else        
+	switch (c->processor_id & 0xff0000) {
+	case PRID_COMP_LEGACY:
+		cpu_probe_legacy(c);
+		break;
+	case PRID_COMP_MIPS:
+		cpu_probe_mips(c);
+		break;
+	case PRID_COMP_ALCHEMY:
+		cpu_probe_alchemy(c);
+		break;
+	case PRID_COMP_SIBYTE:
+		cpu_probe_sibyte(c);
+		break;
+	case PRID_COMP_SANDCRAFT:
+		cpu_probe_sandcraft(c);
+		break;
+ 	case PRID_COMP_PHILIPS:
+		cpu_probe_philips(c);
+		break;
+	default:
+		c->cputype = CPU_UNKNOWN;
+	}
+	if (c->options & MIPS_CPU_FPU) {
+		c->fpu_id = cpu_get_fpu_id();
+
+		if (c->isa_level == MIPS_CPU_ISA_M32R1 ||
+		    c->isa_level == MIPS_CPU_ISA_M32R2 ||
+		    c->isa_level == MIPS_CPU_ISA_M64R1 ||
+		    c->isa_level == MIPS_CPU_ISA_M64R2) {
+			if (c->fpu_id & MIPS_FPIR_3D)
+				c->ases |= MIPS_ASE_MIPS3D;
+		}
+	}
+#endif
 }
 
 __init void cpu_report(void)
